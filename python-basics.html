<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python Explained - Jason&#x27;s Computing Guides</title><meta name="description" content="Here are my Python basics for anyone wanting to learn this programming language."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://aindien.com/python-basics.html"><link rel="alternate" type="application/atom+xml" href="https://aindien.com/feed.xml" title="Jason&#x27;s Computing Guides - RSS"><link rel="alternate" type="application/json" href="https://aindien.com/feed.json" title="Jason&#x27;s Computing Guides - JSON"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://aindien.com/assets/css/style.css?v=166a31b4480c68773db8a06507216db7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://aindien.com/python-basics.html"},"headline":"Python Explained","datePublished":"2023-12-23T16:27-06:00","dateModified":"2025-07-26T18:58-05:00","description":"Here are my Python basics for anyone wanting to learn this programming language.","author":{"@type":"Person","name":"Jason Moore","url":"https://aindien.com/authors/jason-moore/"},"publisher":{"@type":"Organization","name":"Jason Moore"}}</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-393JFJ482L"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-393JFJ482L');</script><script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/5aefa50c3a5900492b165a83f/93dcd5a76da18d3becc7e677f.js");</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://aindien.com/">Jason&#x27;s Computing Guides</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://aindien.com/about-me.html" target="_self">Andromeda</a></li><li><a href="https://aindien.com/c/" target="_self">C++</a></li><li><a href="https://aindien.com/linux/" target="_self">Linux</a></li><li><a href="https://aindien.com/networking/" target="_self">Networking</a></li><li><a href="https://aindien.com/git/" target="_self">Git</a></li><li><a href="https://aindien.com/python/" target="_self">Python</a></li><li><a href="https://aindien.com/ai/" target="_self">AI</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://aindien.com/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://aindien.com/media/website/computing-logo-2.jpg" srcset="https://aindien.com/media/website/responsive/computing-logo-2-xs.jpg 300w, https://aindien.com/media/website/responsive/computing-logo-2-sm.jpg 480w, https://aindien.com/media/website/responsive/computing-logo-2-md.jpg 768w, https://aindien.com/media/website/responsive/computing-logo-2-lg.jpg 1024w, https://aindien.com/media/website/responsive/computing-logo-2-xl.jpg 1360w, https://aindien.com/media/website/responsive/computing-logo-2-2xl.jpg 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2023-12-23T16:27">December 23, 2023</time></div><h1>Python Explained</h1><div class="post__meta post__meta--author"><a href="https://aindien.com/authors/jason-moore/" class="feed__author invert">Jason Moore</a></div></div></header></div><div class="wrapper post__entry"><p>Here are my Python essentials for anyone wanting to learn this programming language. This post will be continually updated.</p><p> </p><p><a target="_blank" href="https://amzn.to/4cmUtgG" rel="noopener">Ankr Store on Amazon.</a></p><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1hicd5sln9">Getting Started With Python</a></li><li><a href="#mcetoc_1hoivvjugj">Python Operations</a></li><li><a href="#mcetoc_1hqanv5426">Statements in Python</a></li><li><a href="#mcetoc_1ht30q8fd8">Branching in Python</a></li><li><a href="#mcetoc_1i113u50u24">Scope Of Functions in Python</a></li><li><a href="#mcetoc_1i54q2ag2a6">Callbacks In Python</a></li><li><a href="#mcetoc_1i54q2ag2a7">Exceptions in Python</a></li><li><a href="#mcetoc_1i7hkg2qe1o">Using Modules in Python</a></li><li><a href="#mcetoc_1i7rlg38q20">Using Strings in Python</a></li><li><a href="#mcetoc_1i8qq0dnn8">Modifying Strings in Python</a></li><li><a href="#mcetoc_1i935g7tg18">Accessing Files in Python</a></li><li><a href="#mcetoc_1i9fdkn49kv">Encapsulating Data in Python</a></li><li><a href="#mcetoc_1i9ukn71s7">Inheritance in Python</a></li><li><a href="#mcetoc_1ib2b31p75">Sending Web Responses in Python</a></li><li><a href="#mcetoc_1im5afsoat">Launching a Window in Python</a></li><li><a href="#mcetoc_1im5afsoau">Creating Random Numbers in Python</a></li><li><a href="#mcetoc_1inpi09jd5">Data Structures in Python</a></li><li><a href="#mcetoc_1iqh0h55ss">Decisions In Your Code</a></li><li><a href="#mcetoc_1j14ip0f116s">List Comprehension in Python</a></li></ul></div><h2 id="mcetoc_1hicd5sln9" class="align-center"><span style="color: #236fa1;"><strong>Getting Started With Python</strong></span></h2><p> </p><p><span style="font-weight: 400;">Python is one of the most popular programming languages. It is used for a lot of different fields including, science, data analysis, and application development. </span></p><p><span style="font-weight: 400;">Its commands are processed by an interpreter. </span></p><p><span style="font-weight: 400;">Most of Python’s keywords are English words that make it easy for beginners to understand. It uses indentation liberally to group statements into blocks of code. This helps in reading and comprehending the code. </span></p><p><span style="font-weight: 400;"> </span></p><p><span style="color: #169179;"><strong>Installing Python</strong></span></p><p><span style="font-weight: 400;">For the Windows operating system, you just go to Python’s website and download the executable.</span></p><p><a href="https://python.org/downloads"><span style="font-weight: 400;">https://python.org/downloads</span></a></p><p><span style="font-weight: 400;">Follow the instructions and you will soon have a functional Python interpreter installed and working. </span></p><p><span style="font-weight: 400;">For Linux systems, Python usually comes with the distribution. So, there will usually be nothing to do except update your version. To update your version, just use your package manager to do this. Linux users will understand what this means immediately. If it is not installed, you can use your package manager to install it. Search python3 to find it.</span></p><p> </p><p><span style="color: #169179;"><strong>Using The Interpreter</strong></span></p><p><span style="font-weight: 400;">The Python interpreter processes text. You type this text in the shell of your operating system or in a text editor.  </span></p><p><span style="font-weight: 400;">You can interact with the Python interpreter a few different ways.</span></p><ul><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">In Windows, open CMD and type python</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">In Linux, open a terminal window and type python</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">From the start menu, you can choose Python</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">From the start menu, you can choose the IDLE program </span></li></ul><p><span style="font-weight: 400;">You can use the interpreter as a calculator with parentheses as needed. </span></p><p> </p><p><span style="color: #169179;"><strong>Your First Program</strong></span></p><p><span style="font-weight: 400;">You can type commands and write your first program from this window. A Python program is just a text file with commands in it and saved with the .py extension. It is also a good idea to create a python folder somewhere to save your programs. </span></p><p><span style="font-weight: 400;">In your interpreter window, we can print some text. That is technically a program but it is what most languages start with. Type:</span></p><p><code><span style="font-weight: 400;">print(‘I am learning Python’)</span></code></p><p><span style="font-weight: 400;">Use the menu to save this to your computer. Call it something like ‘learn.py’. Name it whatever you want though, it does not matter. </span></p><p><span style="font-weight: 400;">You can navigate to the file through your gui and double click it.</span></p><p><span style="font-weight: 400;">You can also navigate to it through your command line. If you do it this way, once you are in the directory where the file is located, just type ‘python learn.py’ to run it.</span></p><p> </p><p><span style="color: #169179;"><strong>Using Variables</strong></span></p><p><span style="font-weight: 400;">All programming languages have variables. Python is no exception. Variables let you store data. You can then run operations on the variables as needed. Name your variables something meaningful.</span></p><p><code><span style="font-weight: 400;">life_counter=0</span></code><br><br><code><span style="font-weight: 400;">temperature=55</span></code></p><p><span style="font-weight: 400;">The first part is the variable name followed by an equals sign. After that contains the value of the variable. All variables must be initialized when created. This means they must be assigned a value when they are first created. </span></p><p><span style="font-weight: 400;">You do not have to specify a data type when creating variables. This is called dynamic typing.</span></p><p> </p><p><span style="color: #169179;"><strong>Comments</strong></span></p><p><span style="font-weight: 400;">Comments are a universal way for programming languages to document code. They are meant to explain the thoughts behind a statement, the purpose of a block of code, and to make it easier on anyone reading the code at a later date.</span></p><p><span style="font-weight: 400;">You use the # symbol in front of a line of text to make it a comment. </span></p><p><code><span style="font-weight: 400;"># The purpose of this variable is to be a counter and keep track of the iterations in a loop</span></code></p><p><span style="font-weight: 400;">You can do multi-line comments by enclosing text within triple quote marks(“””).</span></p><p> </p><p><span style="color: #169179;"><strong>User Input</strong></span></p><p><span style="font-weight: 400;">To capture user input, we use the input() function. It will accept a string inside its parentheses. Afterwards, it will prompt the user for input. User input is read as a text string. The text string is then assigned to a variable. </span></p><p><code><span style="font-weight: 400;">fav_team=input(‘What is your favorite baseball team? : ‘)</span></code><br><br><code><span style="font-weight: 400;">print(fav_team)</span></code></p><p> </p><p><span style="color: #169179;"><strong>Errors</strong></span></p><p><span style="font-weight: 400;">There are three types of errors that can occur. They are:</span></p><ul><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Syntax</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Runtime</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Semantic</span></li></ul><p><span style="font-weight: 400;">Syntax errors are when you use the Python language incorrectly. An example of this is misspelling a keyword. Runtime errors can happen when you run a program. This can be a lot of different things but generally means something was misused. Semantic errors are not technically errors. The program can still run but you get unexpected results.</span></p><p> </p><p><span style="color: #169179;"><strong>Overview</strong></span></p><p><span style="font-weight: 400;">The Python language is processed by the interpreter. It is a high level language because it uses English wording. Indentation is used to group statements into blocks. A Python program is just a text file that uses the .py file extension. The print() function outputs the string enclosed within its parentheses. String values are enclosed within quote marks. </span></p><p><span style="font-weight: 400;">A variable is a container with a name. It stores values and can be used by referencing that variable’s name. Variables can be any data type but they all have to be initialized first with some value. The input() function accepts user input. You can assign this input to a variable to increase your program usefulness. </span></p><p> </p><h2 id="mcetoc_1hoivvjugj" class="align-center"><span style="color: #236fa1;"><strong>Python Operations</strong></span></h2><p> </p><p><span style="font-weight: 400;">Let us get familiar with python operations and how they are used.</span></p><p><span style="font-weight: 400;">If you have not already, make a new folder at the base of your drive and call it python.</span></p><p><span style="font-weight: 400;">We will store our scripts here in case we need them to expand on a subject.</span></p><p><span style="font-weight: 400;">As in other programming languages, use parentheses to direct the order of operations.</span></p><p><span style="font-weight: 400;">Values in our expressions are called operands.</span></p><p><span style="font-weight: 400;">All the different python operations have an order in which they are performed.</span></p><p> </p><p><span style="color: #169179;"><strong>Arithmetic</strong></span></p><p><span style="font-weight: 400;">Define some variables:</span></p><p><code><span style="font-weight: 400;">a=5</span></code><br><code><span style="font-weight: 400;">b=10</span></code><br><br><code><span style="font-weight: 400;">print( a, '+', b, '=', a + b )</span></code><br><code><span style="font-weight: 400;">5 + 10 = 15</span></code><br><br><code><span style="font-weight: 400;">print( a, '-', b, '=', a - b )</span></code><br><code><span style="font-weight: 400;">5 - 10 = -5</span></code><br><br><code><span style="font-weight: 400;">print( a, '*', b, '=', a * b )</span></code><br><code><span style="font-weight: 400;">5 * 10 = 50</span></code><br><br><code><span style="font-weight: 400;">print( b, '/', a, '=', b / a )</span></code><br><code><span style="font-weight: 400;">10 / 5 = 2.0</span></code><br><br><code><span style="font-weight: 400;">print( a, '%', b, '=', a / b )</span></code><br><code><span style="font-weight: 400;">5 % 10 = 0.5</span></code><br><br><code><span style="font-weight: 400;">print( a, '^2 =', a*a, sep = '')</span></code><br><code><span style="font-weight: 400;">5^2 = 25</span></code></p><p><span style="font-weight: 400;">The sep character sequence specifies space in the output. We will use it more later.</span></p><p><span style="font-weight: 400;"><br><br></span></p><p><span style="color: #169179;"><strong>Assigning Values</strong></span></p><p><span style="font-weight: 400;">There are many ways to assign values in python. There are several ways to assign values because these are shortcuts and save time once you learn them.</span></p><p> </p><table><tbody><tr><td><p><span style="font-weight: 400;">=</span></p></td><td><p><span style="font-weight: 400;">a=b</span></p></td><td><p><span style="font-weight: 400;">a=b</span></p></td></tr><tr><td><p><span style="font-weight: 400;">+=</span></p></td><td><p><span style="font-weight: 400;">a+=b</span></p></td><td><p><span style="font-weight: 400;">a=(a+b)</span></p></td></tr><tr><td><p><span style="font-weight: 400;">-=</span></p></td><td><p><span style="font-weight: 400;">a-=b</span></p></td><td><p><span style="font-weight: 400;">a=(a-b)</span></p></td></tr><tr><td><p><span style="font-weight: 400;">*=</span></p></td><td><p><span style="font-weight: 400;">a*=b</span></p></td><td><p><span style="font-weight: 400;">a=(a*b)</span></p></td></tr><tr><td><p><span style="font-weight: 400;">/=</span></p></td><td><p><span style="font-weight: 400;">a/=b</span></p></td><td><p><span style="font-weight: 400;">a=(a/b)</span></p></td></tr><tr><td><p><span style="font-weight: 400;">%=</span></p></td><td><p><span style="font-weight: 400;">a%=b</span></p></td><td><p><span style="font-weight: 400;">a=(a%b)</span></p></td></tr><tr><td><p><span style="font-weight: 400;">//=</span></p></td><td><p><span style="font-weight: 400;">a//b</span></p></td><td><p><span style="font-weight: 400;">a=(a//b)</span></p></td></tr><tr><td><p><span style="font-weight: 400;">**=</span></p></td><td><p><span style="font-weight: 400;">a**b</span></p></td><td><p><span style="font-weight: 400;">a=(a**b)</span></p></td></tr></tbody></table><p><br><br></p><p><span style="font-weight: 400;">These operations are efficient to use. It will save you time by learning these shortcuts slowly.</span></p><p><span style="font-weight: 400;">Also, the ‘=’ operator assigns a value to a variable. It does not test equality between two different variables or values.</span></p><p> </p><p><span style="font-weight: 400;">Let us practice these shortcuts with some simple examples.</span></p><p> </p><p><code><span style="font-weight: 400;">a=10</span></code><br><code><span style="font-weight: 400;">b=20</span></code><br><br><code><span style="font-weight: 400;">print(‘Initializing Variables:\t\t’, ‘a =’ a, ‘\tb =’, b)</span></code><br><code><span style="font-weight: 400;">a += b</span></code><br><br><code><span style="font-weight: 400;">print(‘Addition:\t\t’, ‘a =’, a, ‘(10+20)’)</span></code><br><code><span style="font-weight: 400;">a -= b</span></code><br><br><code><span style="font-weight: 400;">print(‘Subtraction:\t’, ‘a =’, a, ‘(20-10)’)</span></code><br><code><span style="font-weight: 400;">a *= b</span></code><br><br><code><span style="font-weight: 400;">print(‘Multiplication:\t’, ‘a =’, ‘(10*20)’)</span></code><br><code><span style="font-weight: 400;">a /= b</span></code><br><br><code><span style="font-weight: 400;">print(‘’Division:\t’, ‘a =’, a, ‘(20 / 10)’)</span></code><br><code><span style="font-weight: 400;">a %= b</span></code><br><br><code><span style="font-weight: 400;">print(‘Modulo:\t’, ‘a =’, a, ‘(20 % 10)’)</span></code></p><p> </p><p><span style="color: #169179;"><strong>Comparing Values</strong></span></p><p><span style="font-weight: 400;">As in math and other languages, there are several operators for comparing values in python. The most commonly used are:</span></p><p><br><br></p><table><tbody><tr><td><p><span style="font-weight: 400;">==</span></p></td><td><p><span style="font-weight: 400;">Equality</span></p></td></tr><tr><td><p><span style="font-weight: 400;">!=</span></p></td><td><p><span style="font-weight: 400;">Inequality</span></p></td></tr><tr><td><p><span style="font-weight: 400;">&gt;</span></p></td><td><p><span style="font-weight: 400;">Greater Than</span></p></td></tr><tr><td><p><span style="font-weight: 400;">&lt;</span></p></td><td><p><span style="font-weight: 400;">Less Than</span></p></td></tr><tr><td><p><span style="font-weight: 400;">&gt;=</span></p></td><td><p><span style="font-weight: 400;">Greater Than or Equal To</span></p></td></tr><tr><td><p><span style="font-weight: 400;">&lt;=</span></p></td><td><p><span style="font-weight: 400;">Less Than or Equal To</span></p></td></tr><tr><td> </td><td> </td></tr></tbody></table><p> </p><p><span style="font-weight: 400;">This is logic math. For example, the ‘==’ will compare two operands and return true if both are equal in value. The ‘!=’ operator returns true if two operands are not equal. The ‘&gt;’ operator returns true if the first operator is greater than the second. The ‘&lt;’ operator returns true if the first operator is less than the second.</span></p><p> </p><p><span style="font-weight: 400;">The ‘&gt;=’ operator returns true if the operand is greater than or equal to the second. The ‘&lt;=’ returns true if the operand is less than or equal to the second. </span></p><p> </p><p><code><span style="font-weight: 400;">nothing=0</span></code><br><code><span style="font-weight: 400;">zero=0</span></code><br><code><span style="font-weight: 400;">one=1</span></code><br><code><span style="font-weight: 400;">upper= 'A'</span></code><br><code><span style="font-weight: 400;">lower= 'a'</span></code><br><br><code><span style="font-weight: 400;">print('Equality :\t', nothing, '==', zero, nothing == zero)</span></code><br><code><span style="font-weight: 400;">print('Equality :\t', upper, '==', lower, upper == lower)</span></code><br><code><span style="font-weight: 400;">print('Inequality :\t', nothing, '!=', one, nothing != one)</span></code><br><code><span style="font-weight: 400;">print('Greater :\t', nothing, '&gt;', one, nothing &gt; one)</span></code><br><code><span style="font-weight: 400;">print('Lesser :\t', nothing, '&lt;', one, nothing &lt; one)</span></code><br><code><span style="font-weight: 400;">print('Greater or Equal To :\t', nothing, '&gt;=', zero, nothing &gt;= zero)</span></code><br><code><span style="font-weight: 400;">print('Less Than or Equal To :\t', one, '&lt;=', zero, one &lt;= zero)</span></code></p><p> </p><p><span style="color: #169179;"><strong>Logic</strong></span></p><p><span style="font-weight: 400;">Logic operators are used a lot in python. They include:</span></p><p> </p><table><tbody><tr><td><p><span style="font-weight: 400;">and</span></p></td><td><p><span style="font-weight: 400;">Logical And</span></p></td></tr><tr><td><p><span style="font-weight: 400;">or</span></p></td><td><p><span style="font-weight: 400;">Logical Or</span></p></td></tr><tr><td><p><span style="font-weight: 400;">not</span></p></td><td><p><span style="font-weight: 400;">Logical Not</span></p></td></tr></tbody></table><p><br><br></p><p><span style="font-weight: 400;">Logical And will look at two operators and return true if both operands are true.</span></p><p><span style="font-weight: 400;">Logical Or will look at two operators and return true if one of the operands is true.</span></p><p><span style="font-weight: 400;">Logical Not is used with another operand and returns the inverse value of it.</span></p><p><span style="font-weight: 400;">This is called boolean logic.</span></p><p> </p><p><code><span style="font-weight: 400;">t=True</span></code><br><code><span style="font-weight: 400;">f=False</span></code><br><br><code><span style="font-weight: 400;">print('And Logic:')</span></code><br><code><span style="font-weight: 400;">print('t and t =', t and t)</span></code><br><code><span style="font-weight: 400;">print('t and f =', t and f)</span></code><br><code><span style="font-weight: 400;">print('f and f =', f and f)</span></code><br><br><code><span style="font-weight: 400;">print('\nOr Logic:')</span></code><br><code><span style="font-weight: 400;">print('t or t =', t or t)</span></code><br><code><span style="font-weight: 400;">print('t or f =', t or f)</span></code><br><code><span style="font-weight: 400;">print('f or f =', f or f)</span></code><br><br><code><span style="font-weight: 400;">print('\nNot Logic:')</span></code><br><code><span style="font-weight: 400;">print('t =', t, '\tnot t =', not t)</span></code><br><code><span style="font-weight: 400;">print('f =', f, '\tnot f =', not f)</span></code></p><p> </p><p><span style="color: #169179;"><strong>Conditions</strong></span></p><p><span style="font-weight: 400;">Every programming language I have heard of has a way to test conditions to see if they are true or false. Python is no different. You have an expression and if it is true you do a certain action. However, if it is false , you do a different action. It is called the conditional expression. You can use several different operators with the conditional expression.</span></p><p> </p><p><span style="font-weight: 400;">An expression will return a value of some kind. In Python, this is the test expression and up to two actions afterwards. </span></p><p> </p><p><code><span style="font-weight: 400;">a=1</span></code><br><code><span style="font-weight: 400;">b=2</span></code><br><br><code><span style="font-weight: 400;">print('\nVariable a is :', 'One' if(a==1) else 'Not One')</span></code><br><code><span style="font-weight: 400;">print('Variable a is : :', 'Even' if(a%2==0) else 'Odd')</span></code><br><br><code><span style="font-weight: 400;">print('\nVariable b is :', 'One' if (b==1) else 'Not One')</span></code><br><code><span style="font-weight: 400;">print('Variable b is :', 'Even' if (b%2==0) else 'Odd')</span></code><br><br><code><span style="font-weight: 400;">max = a if (a&gt;b) else b</span></code><br><br><code><span style="font-weight: 400;">print('\nGreater Value Is :', max)</span></code></p><p> </p><p><span style="color: #169179;"><strong>Precedence</strong></span></p><p><span style="font-weight: 400;">Operator precedence determines the order in which the interpreter evaluates expressions. You can dictate precedence with certain operators. </span></p><p> </p><p><code><span style="font-weight: 400;">a=2</span></code><br><code><span style="font-weight: 400;">b=4</span></code><br><code><span style="font-weight: 400;">c=8</span></code><br><br><code><span style="font-weight: 400;">print('\nDefault Order :\t', a, '*', c,'+', b, '=', a*c+b)</span></code><br><code><span style="font-weight: 400;">print('Forced Order :\t', a, '* (',c,'+',b,') =', a*(c+b))</span></code><br><br><code><span style="font-weight: 400;">print('\nDefault Order :\t', c, '//', b, '-', a, '=', c//b-a)</span></code><br><code><span style="font-weight: 400;">print('Forced Order :\t', c,'// (',b,'-', a,')=', c//(b-a))</span></code><br><br><code><span style="font-weight: 400;">print('\nDefault Order :\t', c, '%', a, '+', b, '=', c%a+b)</span></code><br><code><span style="font-weight: 400;">print('Forced Order :\t', c, '% (',a,'+',b,')=', c%(a+b))</span></code><br><br><code><span style="font-weight: 400;">print('\nDefault Order :\t', c, '**', a, '+', b, '=', c**a+b)</span></code><br><code><span style="font-weight: 400;">print('Forced Order :\t', c, '** (',a, '+', b,')=', c**(a+b))</span></code></p><p> </p><p><span style="color: #169179;"><strong>Casting Data Types</strong></span></p><p><span style="font-weight: 400;">The most popular data types are string, integer, and float. Data type recognition is especially important when assigning numeric data to variables from user input as it is stored by default as a string data type. The data type of stored values can be easily converted into a different data type using built-in functions. The built-in data type conversion functions return a new object representing the converted value. </span></p><ul><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">int(x) - converts x to an integer whole number</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">float(x) - converts x to a floating-point number</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">str(x) - converts x to a string representation</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">chr(x) - converts x to a character</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">unichr(x) - converts x to a unicode character</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">ord(x) - converts x to its integer value</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">hex(x) - converts x to its hexadecimal value</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">oct(x) - converts integer x to an octal string</span></li></ul><p><span style="font-weight: 400;">The Python built-in type() function can be used  to determine which data type class the value contained in a variable. </span></p><p> </p><p><code><span style="font-weight: 400;">a=input('Enter A Number:')</span></code><br><code><span style="font-weight: 400;">b=input('Now Enter Another Number:')</span></code><br><br><code><span style="font-weight: 400;">sum=a+b</span></code><br><code><span style="font-weight: 400;">print('\nData type sum:', sum, type(sum))</span></code><br><br><code><span style="font-weight: 400;">sum=int(a)+int(b)</span></code><br><code><span style="font-weight: 400;">print('Data type sum:', sum, type(sum))</span></code><br><br><code><span style="font-weight: 400;">sum=float(sum)</span></code><br><code><span style="font-weight: 400;">print('Data type sum:', sum, type(sum))</span></code><br><br><code><span style="font-weight: 400;">sum=chr(int(sum))</span></code><br><code><span style="font-weight: 400;">print('Data type sum:', sum, type(sum))</span></code></p><p><br><br></p><p><span style="color: #169179;"><strong>Manipulating Bits</strong></span></p><p><span style="font-weight: 400;">In computer terms, each byte comprises 8 bits that can each contain a 1 or a 0 to store a binary number, representing decimal values from 0 to 255. It is possible to manipulate individual parts of a byte using the Python bitwise operators listed below:</span></p><ul><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">|</span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Or</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">&amp;</span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">And</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">~</span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Not</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">^</span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Xor</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">&lt;&lt;</span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Shift left</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">&gt;&gt;</span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Shift right</span></li></ul><p><span style="font-weight: 400;">Unless programming for a device with limited resources, there is seldom a need to utilize bitwise operators, but they can be useful.</span></p><p> </p><p><code><span style="font-weight: 400;">a=10</span></code><br><code><span style="font-weight: 400;">b=5</span></code><br><code><span style="font-weight: 400;">print('a=', a, '\tb=', b)</span></code><br><br><code><span style="font-weight: 400;"># 1010 ^ 0101 = 1111 (decimal 15)</span></code><br><code><span style="font-weight: 400;">a=a^b</span></code><br><br><code><span style="font-weight: 400;"># 1111 ^ 0101 = 1010 (decimal10)</span></code><br><code><span style="font-weight: 400;">b=a^b</span></code><br><br><code><span style="font-weight: 400;"># 1111 ^ 1010 = 0101 (decimal 5)</span></code><br><code><span style="font-weight: 400;">a=a^b</span></code><br><br><code><span style="font-weight: 400;">print('a=', a, '\tb=', b)</span></code></p><p><br><br></p><p><span style="font-weight: 400;">Arithmetic operators can form expressions with two operands for addition, subtraction, multiplication, division, floor division, modulo, and exponent.</span></p><p><span style="font-weight: 400;">The assignment operator (=) can be combined with an arithmetic operator to perform an arithmetic calculation then assign its result.</span></p><p><span style="font-weight: 400;">Comparison operators can form expressions comparing two operands for equality, inequality, greater, lesser, greater or equal, and lesser or equal values.</span></p><p><span style="font-weight: 400;">Logical (and) and (or) operators  form expressions evaluating two operands  to return a boolean value of true or false.</span></p><p><span style="font-weight: 400;">The logical not operator returns the inverse boolean value of a single operand.</span></p><p><span style="font-weight: 400;">A conditional if-else expression evaluates a given expression for a boolean True or False value, then returns one of two operands depending on the result.</span></p><p><span style="font-weight: 400;">Expressions containing multiple operators will execute their operations in accordance with the default precedence rules unless explicitly determined by the addition of parentheses.</span></p><p><span style="font-weight: 400;">The data type of a variable value can be converted to a different data type by the built-in Python functions int(), float(), and str() to return a new converted object.</span></p><p><span style="font-weight: 400;">Python’s built-in type() function determines to which data type class a specified variable belongs.</span></p><p><span style="font-weight: 400;">Bitwise operators OR, And, Not, and Xor each return a value after comparison of the values within two bits whereas the Shift left and Shift right operators move the bit values a specified number of bits in their direction. </span></p><h2 id="mcetoc_1hqanv5426" class="align-center"><br><br><br><span style="color: #236fa1;"><strong>Statements in Python</strong></span></h2><p> </p><p><span style="font-weight: 400;">In Python, a variable must be initialized before it can be used. This is usually done in the statement that uses it. </span></p><p><span style="font-weight: 400;">More than one variable can be initialized  with the same value using a single statement. </span></p><p><code><span style="font-weight: 400;">A = b = d = e = 10</span></code></p><p><span style="font-weight: 400;">More than one variable can also be initialized to different values using commas in a statement.</span></p><p><code><span style="font-weight: 400;">A, b, c, = 15, 25, 35</span></code></p><p><span style="font-weight: 400;">Unlike regular variables, which can only store a single item of data, Python can use a list which can store multiple items of data. The data is stored sequentially in list elements that are index numbered starting at zero. The first value is stored in element zero and goes up from there.</span></p><p><span style="font-weight: 400;">A list is created much like any other variable, but it is initialized by assigning values as a comma-separated list between square brackets.</span></p><p><code><span style="font-weight: 400;">num=[0,1,2,3,4,5]</span></code></p><p><span style="font-weight: 400;">An individual list element can be referenced using the list name followed by square brackets containing that element’s index number. This means that num[1] references the second element in the example above, since the first element starts at zero.</span></p><p><span style="font-weight: 400;">Lists can have more than one index to represent multiple dimensions, rather than the single dimension of a regular list. Multi-dimensional lists of three indices and more are uncommon but two-dimensional lists are useful to store grid-based information such as [x,y] coordinates.</span></p><p><span style="font-weight: 400;">A list of string values can even be considered to be a multi-dimensional list, as each is itself a list of characters. Each character can be referenced by its index number within its particular string.</span></p><p> </p><p><code><span style="font-weight: 400;">quarter=[‘January’, ‘February’, ‘March’]</span></code><br><br><code><span style="font-weight: 400;">print(‘First Month:’, quarter[0])</span></code><br><br><code><span style="font-weight: 400;">print(‘Second Month:’, quarter[1])</span></code><br><br><code><span style="font-weight: 400;">print(‘Third Month:’, quarter[2])</span></code><br><br><code><span style="font-weight: 400;">coordinates=[ [1,2,3] , [4,5,6] ]</span></code><br><br><code><span style="font-weight: 400;">print(‘\nTop Left 0,0:’, coordinates[0][0] )</span></code><br><br><code><span style="font-weight: 400;">print(‘Bottom Right 1,2:’, coordinates[1][2] )</span></code><br><br><code><span style="font-weight: 400;">print(‘\nSecond Month First Letter:’, quarter[1][0] )</span></code></p><p> </p><p><span style="font-weight: 400;">String indices may also be negative numbers. To start counting from the right where -1 references the last letter.</span></p><p> </p><p><span style="color: #169179;"><strong>Manipulating Lists</strong></span></p><p><span style="font-weight: 400;">List variables can contain multiple items of data. They are widely used in Python and have a number of methods and options.</span></p><p><br><br></p><table><tbody><tr><td><p><span style="font-weight: 400;">list.append(x)</span></p></td><td><p><span style="font-weight: 400;">Adds item x to the end of the list</span></p></td></tr><tr><td><p><span style="font-weight: 400;">list.extend(L)</span></p></td><td><p><span style="font-weight: 400;">Adds all items in list L to the end of the list</span></p></td></tr><tr><td><p><span style="font-weight: 400;">list.insert(i,x)</span></p></td><td><p><span style="font-weight: 400;">Inserts item x at index position i</span></p></td></tr><tr><td><p><span style="font-weight: 400;">list.remove(x)</span></p></td><td><p><span style="font-weight: 400;">Removes first item x from the list</span></p></td></tr><tr><td><p><span style="font-weight: 400;">list.pop(i)</span></p></td><td><p><span style="font-weight: 400;">Removes item at index i and returns it </span></p></td></tr><tr><td><p><span style="font-weight: 400;">list.index(x)</span></p></td><td><p><span style="font-weight: 400;">Returns the index in the list of first item x</span></p></td></tr><tr><td><p><span style="font-weight: 400;">list.count(x)</span></p></td><td><p><span style="font-weight: 400;">Returns the number of times x appears in list</span></p></td></tr><tr><td><p><span style="font-weight: 400;">list.sort()</span></p></td><td><p><span style="font-weight: 400;">Sort all list items, in place</span></p></td></tr><tr><td><p><span style="font-weight: 400;">list.reverse()</span></p></td><td><p><span style="font-weight: 400;">Reverse all list items, in place</span></p></td></tr></tbody></table><p> </p><p><span style="font-weight: 400;">Python also has a useful len(L) function that returns the length of the list L as the total number of elements it contains. Like the index() and count() methods, the returned value is numeric so cannot be directly concatenated to a text string for output.</span></p><p><span style="font-weight: 400;">String representation of numeric values can be produced by Python’s str(n) function for concatenation to other strings, which returns a string version of the numeric n value. A string representation of an entire list can be returned by the str(L) function for concatenation to other strings. Remember that the original version remains unchanged as the returned versions are merely copies of the original version.</span></p><p><span style="font-weight: 400;">Individual list elements can be deleted by specifying their index number to the Python del(i) function. This can remove a single element at a specified i index position, or a slice of elements can be removed using slice notation i1:i2 to specify the index number of the first and last element. In this case, i1 is the index number of the first element to be removed and all elements up to, but not including, the element at the i2 index number will be removed.</span></p><p> </p><p><code><span style="font-weight: 400;">basket=['Apple', 'Bun', 'Cola']</span></code><br><br><code><span style="font-weight: 400;">crate=['Egg', 'Fig', 'Grape']</span></code><br><br><code><span style="font-weight: 400;">print('Basket List:', basket)</span></code><br><br><code><span style="font-weight: 400;">print('Basket Elements:', len(basket))</span></code><br><br><code><span style="font-weight: 400;">basket.append('Damson')</span></code><br><br><code><span style="font-weight: 400;">print('Appended:', basket)</span></code><br><br><code><span style="font-weight: 400;">print('Last Item Removed:', basket.pop())</span></code><br><br><code><span style="font-weight: 400;">print('Basket List:', basket)</span></code><br><br><code><span style="font-weight: 400;">basket.extend(crate)</span></code><br><br><code><span style="font-weight: 400;">print('Extended:', basket)</span></code><br><br><code><span style="font-weight: 400;">del basket[1]</span></code><br><br><code><span style="font-weight: 400;">print('Item Removed:', basket)</span></code><br><br><code><span style="font-weight: 400;">del basket[1:3]</span></code><br><br><code><span style="font-weight: 400;">print('Slice Removed:', basket)</span></code></p><p> </p><p><span style="font-weight: 400;">The last index number in the slice denotes at what point to stop removing elements, but the element at that position does not get removed.</span></p><p> </p><p><span style="color: #169179;"><strong>Restricting Lists</strong></span></p><p><span style="font-weight: 400;">For a tuple, the values in a regular list can be changed as the program proceeds, but a list can be created with fixed immutable values that cannot be changed by the program. A restrictive immutable Python list is known as a tuple and is created by assigning values as a comma-separated list between parentheses in a process known as tuple packing.</span></p><p><code><span style="font-weight: 400;">colors-tuple=(‘Red’, ‘Green’, ‘Red’, ‘Blue’, ‘Red’)</span></code></p><p><span style="font-weight: 400;">An individual tuple element can be referenced using the tuple name followed by square brackets containing that element’s index number. Usefully, all values stored inside a tuple can be assigned to individual variables in a process known as sequence unpacking.</span></p><p><code><span style="font-weight: 400;">A,b,c,d,e = colors-tuple</span></code></p><p><span style="font-weight: 400;">For a set, the values in a regular list can be repeated in its elements, as in the tuple above, but a list of unique values can be created where duplication is not allowed. A restrictive Python list of unique values is known as a set and is created by assigning values as a comma-separated list between curly brackets.</span></p><p><code><span style="font-weight: 400;">phonetic-set={‘Alpha’, ‘Bravo’, ‘Charlie’)</span></code></p><p><span style="font-weight: 400;">Individual set elements cannot be referenced using the set name followed by square brackets containing an index number, but instead sets have methods that can be dot-suffixed to the set  name for manipulation and comparison. </span></p><p><br><br></p><table><tbody><tr><td><p><span style="font-weight: 400;">set.add(x)</span></p></td><td><p><span style="font-weight: 400;">Adds item x to the set</span></p></td></tr><tr><td><p><span style="font-weight: 400;">set.update(x,y,z)</span></p></td><td><p><span style="font-weight: 400;">Adds multiple items to the set</span></p></td></tr><tr><td><p><span style="font-weight: 400;">set.copy()</span></p></td><td><p><span style="font-weight: 400;">Returns a copy of the set</span></p></td></tr><tr><td><p><span style="font-weight: 400;">set.pop()</span></p></td><td><p><span style="font-weight: 400;">Removes one random item from the set</span></p></td></tr><tr><td><p><span style="font-weight: 400;">set.discard(x)</span></p></td><td><p><span style="font-weight: 400;">Removes item x if found in the set</span></p></td></tr><tr><td><p><span style="font-weight: 400;">set1.intersection(set2)</span></p></td><td><p><span style="font-weight: 400;">Returns items that appear in both sets</span></p></td></tr><tr><td><p><span style="font-weight: 400;">set1.difference(set2)</span></p></td><td><p><span style="font-weight: 400;">Returns items in set1 but not in set2</span></p></td></tr><tr><td> </td><td> </td></tr></tbody></table><p><br><br></p><p><code><span style="font-weight: 400;">zoo=('Kangaroo', 'Leopard', 'Moose',)</span></code><br><br><code><span style="font-weight: 400;">print('Tuple:', zoo, '\tLength:', len(zoo))</span></code><br><br><code><span style="font-weight: 400;">print(type(zoo))</span></code><br><br><code><span style="font-weight: 400;">bag={'Red', 'Green', 'Blue'}</span></code><br><br><code><span style="font-weight: 400;">bag.add('Yellow')</span></code><br><br><code><span style="font-weight: 400;">print('\nSet:', bag, '\tLength', len(bag))</span></code><br><br><code><span style="font-weight: 400;">print(type(bag))</span></code><br><br><code><span style="font-weight: 400;">print('\nIs Green in bag Set?:', 'Green' in bag)</span></code><br><br><code><span style="font-weight: 400;">print('Is Orange in bag Set?:', 'Orange' in bag)</span></code><br><br><code><span style="font-weight: 400;">box={'Red', 'Purple', 'Yellow'}</span></code><br><br><code><span style="font-weight: 400;">print('\nSet:', box, '\t\tLength', len(box))</span></code><br><br><code><span style="font-weight: 400;">print('Common to both Sets:', bag.intersection(box))</span></code></p><p><br><br></p><p><span style="font-weight: 400;">In Python programming a dictionary is a data container that can store multiple items of data as a list of key:value pairs. Unlike regular list container values, which are referenced by their index number, values stored in dictionaries are referenced by their associated key. The key must be unique within that dictionary, and is typically a string name although numbers may be used.</span></p><p><span style="font-weight: 400;">Creating a dictionary is simply a matter of assigning the key:value pairs as a comma-separated list between curly brackets to a name of your choice. Strings must be enclosed within quotes, as usual, and a : colon character must come between the key and its associated value.</span></p><p><span style="font-weight: 400;">A key:value pair can be deleted from a dictionary by specifying the dictionary name and the pair’s key to the del keyword. Conversely, a key:value pair can be added to a dictionary by assigning a value to the dictionary’s name and a new key.</span></p><p><span style="font-weight: 400;">Python dictionaries have a keys() method that can be dot-suffixed to the dictionary name to return a list, in random order, of all the keys in that dictionary. If you prefer the keys to be sorted into alphanumeric order, simply enclose the statement within the parentheses of the Python sorted() function.</span></p><p><span style="font-weight: 400;">A dictionary can be searched to see if it contains a particular key with the Python in operator, using the syntax key “in” dictionary. The search will return a boolean True value when the key is found in the specified dictionary, otherwise it will return false.</span></p><p><span style="font-weight: 400;">Two dictionaries can be merged into one single dictionary using the | merge operator, where dict3=dict1 | dict2. Alternatively, a dictionary can be merged with a second dictionary using the |= update operator, where dict1 |= dict2.</span></p><p><span style="font-weight: 400;">Dictionaries are the final type of data container available in Python. Here are the types again:</span></p><p><br><br></p><table><tbody><tr><td><p><span style="font-weight: 400;">Variable</span></p></td><td><p><span style="font-weight: 400;">A single value</span></p></td></tr><tr><td><p><span style="font-weight: 400;">List</span></p></td><td><p><span style="font-weight: 400;">Multiple values in an ordered index</span></p></td></tr><tr><td><p><span style="font-weight: 400;">Tuple</span></p></td><td><p><span style="font-weight: 400;">Multiple fixed values in a sequence</span></p></td></tr><tr><td><p><span style="font-weight: 400;">Set</span></p></td><td><p><span style="font-weight: 400;">Unique values in an unordered collection</span></p></td></tr><tr><td><p><span style="font-weight: 400;">Dictionary</span></p></td><td><p><span style="font-weight: 400;">Multiple unordered key:value pairs</span></p></td></tr></tbody></table><p> </p><p><code><span style="font-weight: 400;">user_sys={'name': 'Bob', 'sys': 'Win'}</span></code><br><br><code><span style="font-weight: 400;">user_lang={'name': 'Bob', 'lang': 'Python'}</span></code><br><br><code><span style="font-weight: 400;">dict=user_sys|user_lang</span></code><br><br><code><span style="font-weight: 400;">print('\nDictionary:', dict)</span></code><br><br><code><span style="font-weight: 400;">print('\nLanguage:', dict['lang'])</span></code><br><br><code><span style="font-weight: 400;">print('\nKeys:', dict.keys())</span></code><br><br><code><span style="font-weight: 400;">del dict['name']</span></code><br><br><code><span style="font-weight: 400;">dict['user']='Tom'</span></code><br><br><code><span style="font-weight: 400;">print('\nDictionary:', dict)</span></code><br><br><code><span style="font-weight: 400;">print('\nIs There A Name Key?:', 'name' in dict)</span></code></p><p> </p><p><span style="font-weight: 400;">Notice the quotes must be preceded by a backslash character within a string to prevent the string being prematurely terminated.</span></p><p> </p><h2 id="mcetoc_1ht30q8fd8" class="align-center"><span style="color: #236fa1;"><strong>Branching in Python</strong></span></h2><p> </p><p><span style="font-weight: 400;">The Python if keyword performs the basic conditional test that evaluates a given expression for a boolean value of True or False. This allows a program to proceed in different directions according to the result of a test and it is known as conditional branching.</span></p><p> </p><p><span style="font-weight: 400;">The tested expression must be followed by a :, then statements to be executed when the test succeeds should follow below on separate lines, and each line must be indented from the if test line. The size of the indentation is not important, but it must be the same for each line.</span></p><p> </p><p><code><span style="font-weight: 400;">If expression</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Do this</span></code></p><p> </p><p><span style="font-weight: 400;">An if test can offer alternative statements to execute when the test fails by appending an else keyword after the statements to be executed when the test succeeds.</span></p><p> </p><p><code><span style="font-weight: 400;">If expression</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Do this</span></code><br><br><code><span style="font-weight: 400;">Else:</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Alternative expression</span></code></p><p> </p><p><span style="font-weight: 400;">An if test block can also be followed by an alternative test using the elif keyword (else if) that offers statements to be executed when the alternative test succeeds.</span></p><p> </p><p><code><span style="font-weight: 400;">If expression</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Do this</span></code><br><br><code><span style="font-weight: 400;">Elif another expression</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Do this instead</span></code><br><br><code><span style="font-weight: 400;">Else:</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Do this when the above are false</span></code></p><p> </p><p><span style="font-weight: 400;">Conditional branching can also be performed using a match case block. A value to be evaluated is specified after the match keyword and this is compared to a pattern specified to one or more case statements. Only when the specified value matches a pattern will the statements inside that case block be executed, otherwise the program will simply proceed. A match case block has this syntax:</span></p><p> </p><p><span style="font-weight: 400;">Match value:</span></p><p><span style="font-weight: 400;"></span><span style="font-weight: 400;">Case 1:</span></p><p><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Do this</span></p><p><span style="font-weight: 400;"></span><span style="font-weight: 400;">Case 2:</span></p><p><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Do this</span></p><p><span style="font-weight: 400;"></span><span style="font-weight: 400;">Case 3:</span></p><p><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Do this</span></p><p> </p><p><span style="font-weight: 400;">Indentation of code is very important in Python as it identifies code blocks to the interpreter. The match case block in Python is similar to the switch case block found in other languages.</span></p><p> </p><p><code><span style="font-weight: 400;">num = int(input(' Please enter a number: '))</span></code><br><br><code><span style="font-weight: 400;">if num &gt; 5:</span></code><br><br><code><span style="font-weight: 400;">    print(' Number is greater than 5\n ')</span></code><br><br><code><span style="font-weight: 400;">elif num &lt; 5:</span></code><br><br><code><span style="font-weight: 400;">    print(' Number is less than 5\n ')</span></code><br><br><code><span style="font-weight: 400;">else:</span></code><br><br><code><span style="font-weight: 400;">    print(' Number is 5\n ')</span></code><br><br><code><span style="font-weight: 400;">   cmd = input(' Enter STOP or GO: ').upper()</span></code><br><br><code><span style="font-weight: 400;">   match cmd:</span></code><br><br><code><span style="font-weight: 400;">        case 'GO':</span></code><br><br><code><span style="font-weight: 400;">            print(' Started ')</span></code><br><br><code><span style="font-weight: 400;">        case 'STOP':</span></code><br><br><code><span style="font-weight: 400;">            print(' Stopped ')</span></code></p><p> </p><p><span style="font-weight: 400;">The user input is read as a string value by default, so must be cast as an int data type with int() for arithmetical comparison. The match comparison is case-sensitive so the user input is forced to uppercase by the upper() string method before comparison.</span></p><p><br><br></p><p><span style="color: #169179;"><strong>Looping</strong></span></p><p><span style="font-weight: 400;">A loop is a piece of code in a program that automatically repeats. One complete execution of all statements within a loop is called an iteration. The length of the loop is controlled by a conditional test made within the loop. While the tested expression is found to be true, the loop will continue. When the tested expression is found to be false the loop ends.</span></p><p> </p><p><span style="font-weight: 400;">In Python programming, the while keyword created a loop. It is followed by the test expression then a : character. Statements to be executed when the test succeeds should follow below on separate lines, and each line must be indented the same space from the while test line. This statement block must include a statement that will at some point change the result of the expression evaluation, otherwise an infinite loop is created. </span></p><p> </p><p><span style="font-weight: 400;">Indentation of code blocks must also be observed in Python’s interactive mode. Loops can be nested, one within another, to allow complete execution of all iterations of an inner nested loop on each iteration of the outer loop. A counter variable can be initialized with a starting value immediately before each loop definition, included in the test expression, and incremented on each iteration until the test fails, then the loop ends. </span></p><p> </p><p><span style="font-weight: 400;">Unlike other Python keywords, the keywords True and False begin with uppercase letters. Hit return to move to the next line and see the interpreter automatically indent the new line as it expects further statements. Hit return again to execute the entered code.</span></p><p> </p><p><code><span style="font-weight: 400;">i = 1</span></code><br><br><code><span style="font-weight: 400;">while i &lt;4:</span></code><br><br><code><span style="font-weight: 400;">    print( '\nOuter loop iteration: ', i)</span></code><br><br><code><span style="font-weight: 400;">    i+=1</span></code><br><br><code><span style="font-weight: 400;">    j = 1</span></code><br><br><code><span style="font-weight: 400;">    while j &lt;4:</span></code><br><br><code><span style="font-weight: 400;">        print( '\nInner loop iteration: ',j)</span></code><br><br><code><span style="font-weight: 400;">        j+=1</span></code></p><p> </p><p><span style="font-weight: 400;">The output printed from the inner loop is indented from that of the outer loop by the \t tab character. The += assignment statement i +=1 is simply a shorthand way to say i=i+1. </span></p><p> </p><p><span style="color: #169179;"><strong>Looping Over Items</strong></span></p><p> </p><p><span style="font-weight: 400;">In Python programming, the for keyword loops over all items in any list specified to the in keyword. This statement must end with a : colon character, and statements to be executed on each iteration of the loop must be indented.</span></p><p> </p><p><span style="font-weight: 400;">For each item inlist</span></p><p><span style="font-weight: 400;"></span><span style="font-weight: 400;">Statements to be executed on each iteration</span></p><p><span style="font-weight: 400;"></span><span style="font-weight: 400;">Statements to be executed on each iteration</span></p><p> </p><p><span style="font-weight: 400;">As a string is simply a list of characters, the for in statement can loop over each character. Similarly, a for in statement can loop over each element in a list, each item in a tuple, each member of a set, or each key in a dictionary.</span></p><p> </p><p><span style="font-weight: 400;">A for in loop iterates over the items of any list or string in the order that they appear in the sequence, but you cannot directly specify the number of iterations to make, a halting condition, or the size of iteration step. You can, however, use the Python range() function to iterate over a sequence of numbers by specifying a numeric end value within its parameters. This will generate a sequence that starts at zero and continues up to, but not including, the specified end value. For example, range(5) generates 0,1,2,3,4. </span></p><p> </p><p><span style="font-weight: 400;">Optionally, you can specify both a start and end value within the parentheses of the range() function, separated by a comma. For example, range(1,5) generates 1,2,3,4. Also, you can specify a start value, end value, and a step value to the range() function as a comma-separated list within its parentheses. For example, range(1,14,4) generates 1,5,9,13. </span></p><p> </p><p><span style="font-weight: 400;">You can specify the list’s name within the parentheses of Python’s enumerate() function to display each element’s index number and its associated value. </span></p><p> </p><p><span style="font-weight: 400;">When looping through multiple lists simultaneously, the element values of the same index number in each list can be displayed together by specifying the list names as a comma-separated list within the parentheses of Python’s zip() function. To ensure lists are of equal length, this can include a final strict=true argument. </span></p><p> </p><p><span style="font-weight: 400;">When looping through a dictionary you can display each key and its associated value using the dictionary items() method and specify two comma-separated variable names to the for keyword, one for the key name and the other for its value. </span></p><p> </p><p><span style="font-weight: 400;">The range() function can generate  a sequence that decreases, counting down, as well as those that count upward. The for loop in Python is unlike that in other languages, as it does not allow step size and end value to be specified. </span></p><p> </p><p><code><span style="font-weight: 400;">chars=[ 'A', 'B', 'C' ]</span></code><br><br><code><span style="font-weight: 400;">fruit=( 'Apple', 'Banana', 'Cherry' )</span></code><br><br><code><span style="font-weight: 400;">dict={ 'name': 'Mike', 'ref': 'Python', 'sys': 'Win' }</span></code><br><br><code><span style="font-weight: 400;">print( '\nElements:\t', end='')</span></code><br><br><code><span style="font-weight: 400;">for item in chars:</span></code><br><br><code><span style="font-weight: 400;">    print( item, end='')</span></code><br><br><code><span style="font-weight: 400;">print( '\nEnumerated:\t', end='')</span></code><br><br><code><span style="font-weight: 400;">for item in enumerate( chars ):</span></code><br><br><code><span style="font-weight: 400;">    print( item, end='' )</span></code><br><br><code><span style="font-weight: 400;">print( '\nZipped:\t', end='' )</span></code><br><br><code><span style="font-weight: 400;">for item in zip( chars, fruit, strict=True ):</span></code><br><br><code><span style="font-weight: 400;">       print( item, end='' )</span></code><br><br><code><span style="font-weight: 400;">print( '\nPaired:' )</span></code><br><br><code><span style="font-weight: 400;">for key, value in dict.items():</span></code><br><br><code><span style="font-weight: 400;">       print( key, '=', value )</span></code></p><p> </p><p><span style="font-weight: 400;">In Python programming, anything that contains multiple items that can be looped over is called iterable.</span></p><p> </p><p><span style="color: #169179;"><strong>Breaking Out of Loops</strong></span></p><p><span style="font-weight: 400;">The Python break keyword can be used to prematurely terminate a loop when a specified condition is met. The break statement is situated inside the loop statement block and is preceded by a test expression. When the test returns True, the loop ends immediately and the program proceeds on to the next task. For example, in a nested inner loop it proceeds to the next iteration of the outer loop.</span></p><p> </p><p><code><span style="font-weight: 400;">for i in range(1,4):</span></code><br><br><code><span style="font-weight: 400;">    for j in range(1,4):</span></code><br><br><code><span style="font-weight: 400;">        print( 'Running i=' , i , 'j=' , j )</span></code></p><p> </p><p><span style="font-weight: 400;">Now, once you see how that runs, we will add a break statement to see how it will affect the previous code.</span></p><p> </p><p><code><span style="font-weight: 400;">for i in range(1,4):</span></code><br><br><code><span style="font-weight: 400;">    for j in range(1,4):</span></code><br><br><code><span style="font-weight: 400;">        print( 'Running i=' , i , 'j=' , j )</span></code><br><br><code><span style="font-weight: 400;">        if i == 2 and j == 1:</span></code><br><br><code><span style="font-weight: 400;">                 print( 'Breaks inner loop at i=2 j=1' )</span></code><br><br><code><span style="font-weight: 400;">                 break </span></code></p><p> </p><p><span style="font-weight: 400;">The Python continue keyword can be used to skip a single iteration of a loop when a specified condition is met. The continue statement is situated inside the loop statement block and is preceded by a test expression. When the test returns true, that one iteration ends and the program proceeds to the next iteration. </span></p><p> </p><p><code><span style="font-weight: 400;">for i in range(1,4):</span></code><br><br><code><span style="font-weight: 400;">    for j in range(1,4):</span></code><br><br><code><span style="font-weight: 400;">        print( 'Running i=' , i , 'j=' , j )</span></code><br><br><code><span style="font-weight: 400;">        if i==1 and j==1:</span></code><br><br><code><span style="font-weight: 400;">                    print( 'Continue inner loop at i=1 and j=1' )</span></code><br><br><code><span style="font-weight: 400;">                    continue</span></code><br><br><code><span style="font-weight: 400;">        if i == 2 and j == 1:</span></code><br><br><code><span style="font-weight: 400;">                 print( 'Breaks inner loop at i=2 j=1' )</span></code><br><br><code><span style="font-weight: 400;">                 break</span></code></p><p> </p><p><span style="font-weight: 400;">Here, the break statement halts all three iterations of the inner loop when the outer loop tries to run it the second time. The continue statement just skips the first iteration of the inner loop when the outer loop tries to run it for the first time. </span></p><h2 id="mcetoc_1i113u50u24" class="align-center"><span style="color: #236fa1;"><strong>Scope Of Functions in Python</strong></span></h2><p><span style="font-weight: 400;">Most Python programs contain a number of functions that can be called when they are needed. These are custom functions. A custom function is created using the “def” keyword. It stands for definition. You follow it with a function name of your choice and parentheses. You can choose any name for your function except Python keywords. This line must end with a colon character. The statements to be executed whenever the function gets called must appear on lines below and be indented.</span></p><p> </p><p><code><span style="font-weight: 400;">Def base_steals();</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Statement1</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Statement2</span></code></p><p> </p><p><span style="font-weight: 400;">Function statements must be indented from the definition line by the same amount so the Python interpreter can recognize the block.</span></p><p> </p><p><span style="font-weight: 400;">Once the function statements have been executed, program flow resumes at the point directly following the function call. This modularity is very useful in Python programming to isolate  set routines so they can be called upon repeatedly.</span></p><p> </p><p><span style="font-weight: 400;">To create custom functions it is necessary to understand the accessibility scope of variables in a program. Variables created outside functions can be referenced by statements inside functions, so they have global scope. Variables created inside functions cannot be referenced from outside the function in which they have been created, so these have local scope. </span></p><p> </p><p><span style="font-weight: 400;">The limited accessibility of local variables means that variables of the same name can appear in different functions without conflict. If you want to coerce a local variable to make it accessible elsewhere, it must first be declared with the Python global keyword followed by its name only. </span></p><p> </p><p><span style="font-weight: 400;">It may subsequently be assigned a value that can be referenced from anywhere in the program. Where a global variable and a local variable have the same name, the function will use the local version. </span></p><p> </p><p><span style="font-weight: 400;">Avoid using global variables in order to prevent accidental conflict, use only local variables where possible. </span></p><p> </p><p><code><span style="font-weight: 400;">global_var=1</span></code><br><br><code><span style="font-weight: 400;">def my_vars():</span></code><br><br><code><span style="font-weight: 400;">    print('Global Variable:', global_var)</span></code><br><br><code><span style="font-weight: 400;">    local_var=2</span></code><br><br><code><span style="font-weight: 400;">    print('Local Variable:', local_var)</span></code><br><br><code><span style="font-weight: 400;">    global inner_var</span></code><br><br><code><span style="font-weight: 400;">    inner_var=3</span></code><br><br><code><span style="font-weight: 400;">my_vars()</span></code><br><br><code><span style="font-weight: 400;">print('Coerced Global:', inner_var)</span></code></p><p> </p><p><span style="color: #169179;"><strong>Arguments To Your Functions</strong></span></p><p><span style="font-weight: 400;">When defining a custom function in Python programming, you can specify an argument name between the function’s parentheses. A value can then be passed to that argument by specifying the value in the parentheses of the call to the function. The function can now use that passed in value during its execution by referencing it via the argument name. For example, defining a function to accept an argument to print out, like this…</span></p><p> </p><p><code><span style="font-weight: 400;">Def echo(user):</span></code><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">print(‘User:’, user)</span></code></p><p> </p><p><span style="font-weight: 400;">A call to this function must specify a value to be passed to the argument within its parentheses so it can be printed out:</span></p><p> </p><p><code><span style="font-weight: 400;">echo(‘YourName’)</span></code></p><p> </p><p><span style="font-weight: 400;">Multiple arguments can be specified in the function definition by including a comma-separated list of argument names within the function parentheses:</span></p><p> </p><p><code><span style="font-weight: 400;">Def echo(user, lang, sys):</span></code><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">print(‘User:’, user, ‘Language:’, lang, ‘Platform:’, sys)</span></code></p><p> </p><p><span style="font-weight: 400;">When calling a function whose definition specifies arguments, the call must include the same number of data values as arguments. For example, to call this example with multiple arguments:</span></p><p> </p><p><code><span style="font-weight: 400;">echo(‘YourName’, ‘Python’, ‘Windows’)</span></code></p><p> </p><p><span style="font-weight: 400;">The passed values must appear in the same order as the arguments list unless the caller also specifies the argument names, like this:</span></p><p> </p><p><code><span style="font-weight: 400;">echo(lang=’Python’, user=’YourName’, sys=’Windows’)</span></code></p><p> </p><p><span style="font-weight: 400;">Optionally, a default value may be specified in the argument list when defining a function. This will be overridden when the caller specifies a value for that argument, but will be used by the function when no value gets passed by the caller:</span></p><p> </p><p><code><span style="font-weight: 400;">Def echo(user, lang, sys=’Linux’):</span></code><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">print((‘User:’, user, ‘Language:’, lang, ‘Platform:’, sys)</span></code></p><p> </p><p><span style="font-weight: 400;">This means you may call the function passing fewer values than the number of arguments specified in the function definition, to use the default argument value, or pass the same number of values as specified arguments to override the default value.</span></p><p> </p><p><span style="font-weight: 400;">Argument naming follows the same conventions as variables and functions. Name arguments the same as variables passed to them to make the data movement obvious.</span></p><p> </p><p><code><span style="font-weight: 400;">def echo(user, lang, sys):</span></code><br><code><span style="font-weight: 400;">   print('User:', user, 'Language:', lang, 'Platform:', sys)</span></code><br><br><code><span style="font-weight: 400;">echo('YourName', 'Python', 'Windows')</span></code><br><br><code><span style="font-weight: 400;">echo(lang='Python', sys='Mac OS', user='Anne')</span></code><br><br><code><span style="font-weight: 400;">def mirror(user='Carole', lang='Python'):</span></code><br><code><span style="font-weight: 400;">   print('\nUser:', user, 'Language:', lang)</span></code><br><br><code><span style="font-weight: 400;">mirror()</span></code><br><code><span style="font-weight: 400;">mirror(lang='Java')</span></code><br><code><span style="font-weight: 400;">mirror(user='Tony')</span></code><br><code><span style="font-weight: 400;">mirror('Susan', 'C++')</span></code></p><p> </p><p><span style="color: #169179;"><strong>Returning Values</strong></span></p><p><span style="font-weight: 400;">Like Python’s built in str() function, which returns a string representation of the value specified as its argument by the caller, custom functions can also return a value to their caller by using the Python “return” keyword to specify a value to be returned. For example, to return to the caller the total of adding two specified argument values, like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Def sum(a,b):</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Return a+b</span></code></p><p> </p><p><span style="font-weight: 400;">The returned result may be assigned to a variable by the caller for subsequent use by the program, like this:</span></p><p> </p><p><code><span style="font-weight: 400;">total=sum(8,4)</span></code><br><br><code><span style="font-weight: 400;">print(‘Eight plus four is:’, total)</span></code></p><p> </p><p><span style="font-weight: 400;">Or the returned result may be used directly in line like this:</span></p><p> </p><p><code><span style="font-weight: 400;">print(‘Eight plus four is:’, sum(8,4))</span></code></p><p> </p><p><span style="font-weight: 400;">Typically, a return statement will appear at the very end of a function block to return the final result of executing all statements contained in that function.</span></p><p> </p><p><span style="font-weight: 400;">A return statement may appear earlier in the function block to halt execution of all subsequent statements in that block. This immediately resumes execution of the program at the caller. The return statement may specify a value to be returned to the caller or the value may be omitted. Where no value is specified, a default value of “none” is assumed. Typically, this is used to halt execution of the function statements after a conditional test is found to be “false”. For example, where a passed argument value is below a specified number:</span></p><p> </p><p><code><span style="font-weight: 400;">Def sum(a,b):</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">If a&lt;b:</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">Return</span></code><br><br><code><span style="font-weight: 400;"></span><span style="font-weight: 400;">Return a+b</span></code></p><p> </p><p><span style="font-weight: 400;">In this case, the function will return the default value “none” when the first passed argument value is below five and the final statement will not be executed. Where the function is to perform arithmetic, user input can be validated for integer values with the built-in “isdigit()” function. You can specify a default value for an argument in the function definition.</span></p><p> </p><p><code><span style="font-weight: 400;">num=input('Enter an integer:')</span></code><br><br><code><span style="font-weight: 400;">def square(num):</span></code><br><br><code><span style="font-weight: 400;">    if not num.isdigit():</span></code><br><br><code><span style="font-weight: 400;">        return 'invalid entry'</span></code><br><br><code><span style="font-weight: 400;">    num=int(num)</span></code><br><br><code><span style="font-weight: 400;">    return num*num</span></code><br><br><code><span style="font-weight: 400;">print(num, 'Squared is:', square(num))</span></code></p><p> </p><p><span style="font-weight: 400;">Remember that user input is read as a “str” data type so ust be cast into an “int” or a “float” data type for arithmetic.</span></p><h2 id="mcetoc_1i54q2ag2a6" class="align-center"><span style="color: #236fa1;"><strong>Callbacks In Python</strong></span></h2><p><span style="color: #169179;"><strong>Callbacks In Python</strong></span><br><br>In Python, a named function is created using the "def" keyword to specify a function name, which can be used to call that function at <br>any time in the program to execute the statements it contains. Optionally, the named function can return a value to the caller.<br><br>Python also allows an anonymous function to be created using the lambda keyword. <br>An anonymous function may only contain a single expression that must always return a value. <br><br>Unlike the usual creation of a function with the "def" keyword, the creation of a function with a lambda keyword returns a function object.<br>This can be assigned a variable, which can then be used to reference the function at any time in the program to execute the expression it<br>contains.<br><br>The lambda keyword offers the programmer an alternative syntax for the creation of a function. For example:</p><p><br><code>def square(x):</code><br><code> return x**2</code></p><p><br>can alternatively be written as:</p><p><br><code>square = lambda x:x**2</code></p><p><br>In either case, the call square(5) returns the result 25 by passing in an integer argument to the function. <br>Note that the lambda keyword is followed by an argument without parentheses, and the specified expression does not require the return <br>keyword as all functions created with lambda must implicitly return a value.<br><br>While the lambda keyword offers an alternative way to create a function, it is mostly used to embed a function within the code.<br>For instance, callbacks are frequently coded as inline lambda expressions embedded directly in a caller's arguments list.<br>Instead of being defined with the "def" keyword elsewhere in the program and referenced by name.<br>For example:</p><p><br><code>def function_1: statements</code><br><code>def function_2: statements</code><br><code>callbacks = [ function_1, function_2 ]</code></p><p><br>This can be written as:</p><p><code>callbacks = [ lambda: expression, lambda: expression ]</code><br><br><code>def function_1(x): return x**2</code><br><code>def function_2(x): return x**3</code><br><code>def function_3(x): return x**4</code><br><br><code>callbacks = [function_1, function_2, function_3]</code><br><br><code>print('\nNamed Functions:')</code><br><code>for function in callbacks:print('Result:', function(3))</code><br><br><code>callbacks = \</code><br><code>[lambda x:x**2, lambda x:x**3, lambda x:x**4]</code><br><br><code>print('\nAnonymous Functions:')</code><br><code>for function in callbacks:print('Result:', function(3))</code></p><p><br>Function definitions that contain just one statement can be written on just one line.<br>The \ backslash character can be used to allow code to continue on the nect line.<br><br></p><p><span style="color: #169179;"><strong>Placeholders</strong></span><br><br>The Python "pass" keyword is useful when writing program code as a temporary placeholder that can be inserted into the code at places where further code needs to be<br>added later. The "pass" keyword is inserted where a statement is required syntactically, but it merely performs a null operation. When it is executed nothing happens and no<br>code needs to be executed. This allows an incomplete program to be executed for testing by simulating correct syntax so the interpreter does not report errors.</p><p><br><code>bool = True</code><br><code>if bool:</code><br><code>    print('Python is better than R')</code><br><code>else:</code><br><code>    pass</code></p><p><br>In loop structures it is important not to confuse the "pass" keyword, which allows the interpreter to process all subsequent statements <br>on that iteration, with the "continue" keyword, which skips subsequent statements on that iteration of the loop only.</p><p><br><code>title = '\nPython is better than R\n'</code><br><br><code>for char in title:print(char, end = '')</code><br><br><code>for char in title:</code><br><code>    if char == 'y':</code><br><code>        print('*', end = '')</code><br><code>        continue</code><br><code>    print(char, end = '')</code><br><br><code>for char in title:</code><br><code>    if char == 'y':</code><br><code>        print('*', end = '')</code><br><code>        pass</code><br><code>    print(char, end = '')</code></p><p><br><span style="color: #169179;"><strong>Producing Generators</strong></span><br><br>When a Python function is called, it executes the statements it contains and may return a value specified to the return keyword. After the function ends, control returns<br>to the caller and the state of the function is not retained. When the function is next called, it will process its statements from start to finish once more.<br><br>A Python generator is a special function that returns a generator object to the caller rather than a data value. This retains the state of the function when it was last <br>called, so it will continue from that point when next called.<br><br>Generator functions are produced by definition just like regular functions, but contain a yield statement. This begins with the Python yield keyword and specifies the<br>generator object to be returned to the caller. When the yield statement gets executed, the state of the generator object is frozen, and the current value in its expression <br>list is retained. The generator object returned by the yield statement can be conveniently assigned to a variable. Python's built-in "next()" function can then specify that<br>variable name within its parentheses to continue execution of the function from the point at which it was frozen, exactly as if the yield statement were just another external call.<br><br>Repeatedly calling the generator object with the "next()" function continues execution of the function until it raises an exception. This can be avoided by enclosing the<br>yield statement within an infinite loop so it will return successive values on each iteration.</p><p><br><code>def fibonacci_generator():</code><br><code>    a=b=1</code><br><br><code>    while True:</code><br><code>        yield a</code><br><code>        a,b=b,a+b</code><br><br><code>fib=fibonacci_generator()</code><br><br><code>for i in fib:</code><br><code>    if i &gt; 100:</code><br><code>        break</code><br><code>    else:</code><br><code>        print('Generated:',i)</code></p><p><br>In the above script, the variables are initialized with a common value in a single statement.<br>You can use the inbuilt "type()" function to confirm the object type. here, the type(fib) is confirmed as a generator class object. </p><h2 id="mcetoc_1i54q2ag2a7" class="align-center"><span style="color: #236fa1;"><strong>Exceptions in Python</strong></span></h2><p><span style="color: #169179;"><strong>Exceptions</strong></span><br>Sections of a python script in which it is possible to anticipate errors, such<br>as those handling user input, can be enclosed in a "try except" block to handle<br>exception errors. The statements to be executed are grouped in a try : block,<br>and exceptions are passed to the ensuing except : block for handling.<br>Optionally, this may be followed by a finally : block containing statements to<br>be executed after exceptions have been handled.<br><br>Python recognizes many built in exceptions such as the nameError, which occurs<br>when a variable name is not found, the indexError, which occurs when trying to<br>address a non-existent list index, and the ValueError, which occurs when a<br>built-in operation or function receives an argument that has an inappropriate<br>value.<br><br>Each exception returns a descriptive message that can be assigned to a variable<br>with the "as" keyword. This can be used to display the nature of the exception<br>when it occurs.</p><p><br><code>title='Princeton Companion To Mathematics'</code><br><br><code>try:</code><br><code>    print(titel)</code><br><br><code>except NameError as msg:</code><br><code>    print(msg)</code></p><p> </p><p>Run that and you can see how the error will get handled.<br><br>Multiple exceptions can be handled by specifying their type as a comma-separated<br>list in parentheses within the except block.<br><br>You can also make the interpreter report an exception by using the raise keyword<br>to specify the type of exception to be recognized and a custom descriptive<br>message in parentheses.</p><p><br><br><code>day=32</code><br><code>try:</code><br><code>    if day &gt; 31 :</code><br><code>        raise ValueError('invalid day number')</code><br><br><code>except ValueError as msg:</code><br><code>    print('the program found AN', msg)</code><br><br><code>finally :</code><br><code>    print('but today is beautiful anyway')</code><br><br></p><p>Statements in the try block are all executed unless or until an exception<br>occurs.<br><br><span style="color: #169179;"><strong>Assertions</strong></span><br>When tracking down errors in your code it is often useful to comment out one or<br>more lines of code by prefixing each line with the hash character. The Python<br>interpreter will then omit execution of those lines to help localize where a<br>problem lies. <br><br>Another useful debugging technique employs the Python assert keyword to add<br>error-checking code to your script. This examines a specified test expression<br>for a boolean True or False result, and reports an AssertionError when the test<br>fails. Optionally, an assert statement can include a descriptive message to<br>supply when reporting an AssertionError.<br><br>When the test expression fails, the interpreter reports the AssertionError and<br>halts execution of the script, but when the test succeeds, the assert statement<br>does nothing, and execution of the script continues.<br><br>Employing assert statements is an effective way to document your script, as<br>their descriptive messages provide commentary and their tests alert you when<br>your code is erroneous.<br><br><span style="color: #169179;"><strong>Assert versus Exception</strong></span><br>At first glance, an AssertionError can appear confusingly similar to an<br>exception, but it is important to recognize their distinctions:<br>1. Expections provide a way to handle errors that may legitimately occur at<br>   runtime.<br>2. AssertionErrors provide a way to alert the programmer to mistakes during<br>   development.<br><br>Typically, assert statements will be removed from release versions of a program<br>after debugging is complete, whereas except statements will remain to handle<br>runtime errors. You can have the interpreter ig nore all assert statements using<br>a -o switch in the run command, for example, python -O assert.py</p><p><br><br><code>chars=['alpha', 'beta', 'gamma', 'delta', 'epsilon']</code><br><br><code>def display(elem):</code><br><code>    assert type(elem) is int, 'argument must be integer'</code><br><code>    print('list element', elem, '=', chars[elem])</code><br><br><code>elem=4</code><br><code>display(elem)</code><br><br><code>elem=elem/2</code><br><code>display(elem)</code><br><br></p><p>This AssertionError occurs because the division operation returns a float value,<br>not an integer value.<br><br>Functions are defined using the def keyword, and contain indented statements to<br>execute when the function gets called.<br>Variables with global scope can be referenced from anywhere, but variables with<br>local scope can only be referenced from within the function in which they are<br>declared.<br>Arguments are declared as a comma-separated list within the parentheses of a<br>function definition.<br>Function calls must supply data for each function argument unless a default<br>value is specified in their declarations.<br>Optionally, a function can include a return statement to return a value to the<br>caller.<br>An anonymous function containing a single expression is created with the lambda<br>keytword, and returns a function object. <br>Callbacks are frequently coded as inline lambda expressions embeded directly in<br>a caller's argument list.<br><br>Placeholders can be created by inserting the pass keyword where a statement is<br>required syntactically.<br>A generator function is created when a statement using the yield keyword appears<br>in its function block.<br>Generator functions retain the state of the function when last called, and<br>return a generator object to the caller.<br>The built in next() function can be used to continue execution of a generator<br>function from the point where it was frozen.<br>Anticipated runtime exception errors can be handled by enclosing statements in a<br>try except block.<br>Optionally, a finally statement can be used to specify statements to be executed<br>after exceptions have been handled.<br>Error-checking code can be added to scripts using the assert keyword to report<br>development errors.</p><h2 id="mcetoc_1i7hkg2qe1o" class="align-center"><span style="color: #236fa1;"><strong>Using Modules in Python</strong></span></h2><p> </p><p><span style="color: #169179;"><strong>Storing Functions</strong></span><br>Python function definitions can be stored in one or more separate files for<br>easier maintenance and to allow them to be used in several programs without<br>copying the definitions into each one. Each file storing function definitions is<br>called a module and the module name is the file name without the .py extension.<br><br>Functions stored in the module are made available to a program using the python<br>import keyword followed by the module name. Although not essential, it is<br>customary to put any import statements at the beginning of the program.<br><br>Imported functions can be called using their name dot-suffixed after the module<br>name. Where functions stored in a module include arguments, it is often useful<br>to assign a default value to the argument in the definition. This makes the<br>function more versatile, as it becomes optional for the call to specify an<br>argument value.<br><br>You can create an alias when importing a module using "import as" keywords. For<br>example, import pokemon as darkrai allows you to use darkrai as the function<br>prefix in function calls. <br><br><span style="color: #169179;"><strong>Function Names</strong></span><br>Internally, each python module and program has its own symbol table that is used<br>by all functions defined in that context only. This avoids possible conflicts<br>with functions of the same name in another module if both modules were imported<br>into one program. Where you import individual function names, the module name<br>does not get imported, so it cannot be used as a prefix.<br><br>When you import a module with an import statement, that module's symbol table<br>does not get added to the program's table, only the module's name gets added.<br>That is why you need to call the module's functions using their module name<br>prefix.<br><br>Generally, it is prefarable to avoid conflicts by importing the module name and<br>calling its functions with the module name prefix, but you can import individual<br>function names instead with a from import statement. the module name is<br>specified after the from keyword, and functions to import are specified as a<br>comma-separated list after the import keyword. Alternatively, the * wildcard<br>character can be specified after import to import all function names into the<br>program's own symbol table. This means the functions can be called without a<br>module name prefix. <br><br>For larger programs, you can import modules into other modules to build a module<br>hierarchy.<br><br><span style="color: #169179;"><strong>System Queries</strong></span><br>Python includes "sys" and "keyword" modules that are useful for querrying the<br>python system itself. The keyword module contains a list of all python leywords<br>in its "kwlist" attribute, and provides an "iskeyword()" mothod if you want to<br>test a word.<br><br>You can explore the many features of the "sys" module, and indeed any feature of<br>python, using the interactive mode help system. Just type "help()" at the "&gt;&gt;&gt;"<br>prompt to start the help system, then type "sys" at the "help&gt;" prompt that<br>appears.<br><br>Perhaps most usefully, the "sys" module has attributes that contain the python<br>version number, interpreter location on your system, and a list of all<br>directories where the interpreter seeks module files, so if you save module<br>files in any of these directories you can be sure the interpreter will find<br>them.</p><p><br><br><code>import sys, keyword</code><br><code>print("Python Version: ", sys.version)</code><br><code>print("Python interpreter location:", sys.executable)</code><br><code>print("Python module Search path:")</code><br><code>for dir in sys.path:</code><br><code>    print(dir)</code><br><code>print("Python Keywords:")</code><br><code>for word in keyword.kwlist:</code><br><code>    print(word)</code><br><br></p><p>The first item on the python search path is your current directory, so any file<br>within there, or within any subdirectories you make there, will be found by the<br>python interpreter. <br><br><span style="color: #169179;"><strong>Mathematical Operations</strong></span><br>Python includes a math module that provides lots of methods you can use to<br>perform mathematical procedures once imported.<br><br>The "math.ceil()" and "math.floor()" methods enable a program to perform<br>rounding of a floating point value specified between their parentheses to the<br>closest integer. "Math.ceil()" rounds up and "math.floor()" rounds down but the<br>value returned, although an integer, is a float data type rather than an int data<br>type.<br><br>The "math.pow()" method requires two arguments to raise a specified value by a<br>specified power. The "math.sqrt()" method simply requires a single argument and<br>returns a square root of that specified value. Both method results are returned<br>as a numeric value of the float data type.<br><br>Typical trigonometry can be performed using methods from the math module too,<br>such as "math.sin()", "math.cosin()", and "math.tan()". Python also includes a<br>random module that can be used to produce pseudo random numbers once imported<br>into a program. <br><br>The random.random() method produces a single floating point number between zero<br>and 1.0. The random.sample() method produces a list of elements selected at<br>random from a sequence. This method requires two arguments to specify the<br>sequence to select from, and the length of the list to be produced. As the<br>range() function returns a sequence of numbers, this can be used to specify a<br>sequence as the first argument to the random.sample() method, so it will<br>randomly select numbers from that sequence to produce a list in which no numbers<br>repeat. <br><br>Integers can be cast from the int data type to the float data type using the<br>float() function and to the string data type using the str() function.</p><p><br><br><code>import math, random</code><br><code>print("Rounding up 6.6:", math.ceil(6.6))</code><br><code>print("Rounding down 3.3:", math.floor(3.3))</code><br><code>num=9</code><br><code>print(num, "Squared:", math.pow(num,2))</code><br><code>print(num, "Square Root:", math.sqrt(num))</code><br><code>numbers=random.sample(range(1,69),6)</code><br><code>print("The random numbers selected are:", numbers)</code><br><br></p><p>All the math methods here return floating point numbers of the float data type.<br>The list produced by random.sample() does not actually replace elements of the<br>sequence but merely copies a sample, as its name says.</p><p><span style="color: #169179;"><strong>Calculating Decimals</strong></span><br>Python programs that attempt floating-point arithmetic can produce unexpected<br>and inaccurate results because the floating-point numbers cannot accurately<br>represent all decimal numbers.</p><p><br><br><code>book=14.99</code><br><code>rate=1.35</code><br><code>tax=book*rate</code><br><code>total=book+tax</code><br><code>print("item:\t", "%.2f" % book)</code><br><code>print("Tax:\t", "%.2f" % tax)</code><br><code>print("Total:\t", "%.2f" % total)</code><br><br></p><p>Here, the variable values are formatted using a string substitution technique to<br>show two decimal places.<br><br>To help understand this problem, edit all three print statements to display the<br>variable values expanded to 20 decimal places, then run the program again.</p><p><br><br><code>book=14.99</code><br><code>rate=1.35</code><br><code>tax=book*rate</code><br><code>total=book+tax</code><br><code>print("item:\t", "%.20f" % book)</code><br><code>print("Tax:\t", "%.20f" % tax)</code><br><code>print("Total:\t", "%.20f" % total)</code><br><br></p><p>It is now clear that the tax value is represented numerically slightly below<br>0.735, so gets rounded down to 0.73. Conversely, the total value is represented<br>numerically slightly above 1.435, so gets rounded up to 1.44, creating the<br>apparent addition error.<br><br>Erros in floating-point arithmetic can be avoided by using python's decimal<br>module. This provides a decimal() object with which floating-point numbers can<br>be more accurately represented.<br><br>Add a statement at the beginning of the program to import the decimal module to<br>make all features available from decimal import *. Then, edit the first two<br>variable assignments to objects:<br>book=Decimal(14.99)<br>rate=Decimal(1.35)<br>Now run the program again to see the difference.</p><p><br><br><code>from decimal import *</code><br><code>book=Decimal(14.99)</code><br><code>rate=Decimal(1.35)</code><br><code>tax=book*rate</code><br><code>total=book+tax</code><br><code>print("item:\t", "%.2f" % book)</code><br><code>print("Tax:\t", "%.2f" % tax)</code><br><code>print("Total:\t", "%.2f" % total)</code><br><br></p><p>Always use the decimal() object to calculate monetary values or anywhere that<br>accuracy is essential.</p><p><span style="color: #169179;"><strong>Working with Time</strong></span><br>The python datetime module can be imported into a program to make use of times<br>and dates. It provides a datetime object with attributes of year, month, day,<br>hour, minute, second, and microsecond.<br><br>A datetime object has a today() method that assigns the current date and time<br>values to its attributes and returns them in a tuple. It also has a getattr()<br>method that requires two arguments specifying the datetime object name and<br>attribute to retrieve. Alternatively, the attributes can be referenced using dor<br>notation such as datetime.year.<br><br>All values in a datetime object are stored as numeric values but can be<br>transformed into text equivalents using its strftime() method. This requires a<br>single string argument that is a directive specifying which part of the tuple to<br>return and in what format. The possible directives are listed below.<br><br>%A    Full weekday name<br>%B    Full month name<br>%c    Date and time appropriate for locale<br>%d    Day of the month<br>%f    Microsecond number 0-999999<br>%H    Hour number 0-23<br>%I    Hour number 1-12<br>%j    Day of the year number 0-366<br>%m    Month number 1-12<br>%M    Minute number 0-59<br>%p    AM or PM equivalent for locale<br>%S    Second number 0-59<br>%w    Week day number 0-6<br>%W    Week of the year number 0-53<br>%X    Time appropriate for locale<br>%Y    Year 0001-9999<br>%z    timezone offset from UTC<br>%Z    Timezone name<br><br>Make a new script and run this code to see how date objects are handled.<br>from datetime import *<br><br><code>today=datetime.today()</code><br><code>print("Today is : ", today)</code><br><br><code>for attr in ["year","month","day","minute","second","microsecond"]:</code><br><code>    print(attr, ":\t", getattr(today,attr))</code><br><br><code>print("Time :", today.hour, ":", today.minute, sep='')</code><br><br><code>day=today.strftime("%A")</code><br><code>month=today.strftime("%B")</code><br><br>As the datetime object is in a module of the same name, simply importing the<br>module means it would be referenced as datetime.datetime. Use from datetime<br>import * so it can be referenced just as datetime.<br><br>As the strftime() method requires a string argument, the directive must be<br>enclosed between quote marks.<br><br>You can assign new values to attributes of a datetime object using its replace()<br>method, such as today=today.repalce(year=2023).<br><br><span style="color: #169179;"><strong>Using Timers</strong></span><br>Getting the current time both before and after an event means that the duration<br>of the event can be calculated by their difference. The python time module can<br>be imported into a program to provide various time-related functions.<br><br>Current system time is usually counted as the number of seconds elapsed since<br>the Epoch at 00:00:00 GMT on January 1, 1970. The time module's time() method<br>returns the current time in seconds since the Epoch as a floating point number<br>when called.<br><br>The figure returned by the time() method can be converted into a struct_time<br>object using gmtime() or localtime() methods. This object has attributes of<br>tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec, tm_wday, tm_yday, and<br>tm_isdst that can be referenced using dot notation. For example, struct.tm_wday.<br><br>All values in a struct_time object are stored as numeric values but can be<br>transformed into text equivalents using the strftime() method. This requires an<br>argument that is a format directive followed by the name of the struct_time<br>object. The possible directives include those listed in the table. For example,<br>strftime("%A",struct) for weekday.<br><br>The time module also provides a sleep() method that can be used to pause<br>execution of a program. Its argument specifies the amount of time in seconds by<br>which to delay execution.<br><br>The gmtime() method converts elapsed time from the Epoch to a struct_time object<br>at UTC with daylight savings time always set to zero, whereas localtime()<br>converts to a struct_time object at your local system time.<br><br>Here is an example script you can try:<br>from time import *<br><br><code>start_timer = time()</code><br><code>struct = localtime(start_timer)</code><br><br><code>print("\nStarting Countdown At:", strftime("%X",struct))</code></p><p><br><code>i=10</code><br><code>while i &gt; -1:</code><br><code>    print(i)</code><br><code>    i =i-1</code><br><code>    sleep(1)</code><br><br><code>end_timer = time()</code><br><code>difference = round(end_timer - start_timer)</code><br><br><code>print("\nRuntime:", difference, "Seconds")</code></p><p><br><br>The argument to the sleep() method may be a floating point number to indicate a<br>more precise sleep pause time. Do not confuse the time.strftime() method used<br>here with the datetime.strftime() method used earlier.</p><p><span style="color: #169179;">Patterns</span><br>The python "re" module can be imported into a program to make use of regular<br>expression patterns that describe a particular string of characters. Regular<br>expressions are useful for text validation and for search and replace operations<br>within text by matching their specified pattern to a section of the text. <br><br>A regular expression pattern may consist entirely of literal characters<br>describing a character string to match within some text. For example, the<br>regular expression wind finds a match in windows, the pattern literally matches<br>the string in the text. More typically, a regular expression pattern consists of<br>a combination of literal characters and these metacharacters. <br><br>.        any characters                py..on<br>^        first characters            ^py<br>*        zero or more repetitions    py*<br>+        one or more repetitions        py+<br>?        zero or one repetition        py?<br>{}        multiple repetitions        a{3}<br>[]        character class                [a-z]<br>\        special sequence            \s<br>|        either optional character    a|b<br>()        expression group            (...)<br><br>A combination of literals and metacharacters defining a pattern to be matched<br>can be specified to the re.comile() method to return a pattern object. This<br>object has a match() method to specify a string within its parentheses to<br>compare against the pattern.<br><br>When a match() comparison succeeds, a match object is returned containing<br>information about the match, otherwise a None value is returned when the<br>comparison fails.<br><br>A match object has start() and end() methods, which return the position of the<br>match, and a group() method that returns the string matched by the comparison.<br><br>Run this script to see examples of regular expresisons.<br><br><code>from re import *</code><br><code>pattern=compile('(^|\s)[-a-z0-9_.]+@([-a-z0-9]+\.)+[a-z]{2,6}(\s|$)')</code><br><code>def get_address():</code><br><code>    address=input('Enter Email Address:')</code><br><code>    is_valid=pattern.match(address)</code><br><code>    if is_valid:</code><br><code>        print('Valid Address:', is_valid.group())</code><br><code>    else:</code><br><code>        print('Invalid address \n')</code><br><code>get_address()</code><br><br><span style="color: #169179;"><strong>Summary</strong></span><br>Functions can be stored in modules that are named as the file name without the<br>.py file extension.<br><br>An import statement makes module functions available in a program by<br>dot-suffixing their name after the module name.<br><br>A from import statement makes module functions available in a program without<br>the need to dot-suffix their name.<br><br>The sys module has attributes that contain the python version number,<br>interpreter location, and path to search for modules.<br><br>The keyword module has a kwlist attribute that contains a list of all current<br>python keywords.<br><br>The math module provides methods to perform mathematical procedures such as<br>math.ceil() and math.floor().<br><br>The random module provides a random() method that produces pseudo random<br>numbers and a sample() method that produces a list of elements selected at<br>random from a sequence.<br><br>The decimal module provides a datetime object with year, month, day, hour,<br>minute, second, and microsecond attributes that can be referenced by<br>dot-suffixing or with the getattr() method.<br><br>A datetime object has a strftime() method that can specify a directive to<br>return a formatted part of the object.<br><br>The time module provides a time() method that returns the current elapsed time<br>in seconds since the Epoch.<br><br>The gmtime() and localtime() methods return a struct_time object that has<br>attributes containing date and time components.<br><br>The re module provides a compile() method to create a regular expression<br>pattern and a match() method to compare a pattern to a specified string.</p><h2 id="mcetoc_1i7rlg38q20" class="align-center"><span style="color: #236fa1;"><strong>Using Strings in Python</strong></span></h2><p><span style="color: #169179;"><strong>Manipulating Strings</strong></span><br>Strings can be manipulated in a program using the various operators that are<br>available in python.<br><br>+        concatenate - join strings together<br>*        repeat - multiply the string<br>[]        slice - select a character at a specified index position<br>[:]        range slice - select characters in a specified index range<br>in        membership exclusive - return True if character exists in the string<br>not in    membership exclusive - return True if character doesn't exist in string<br>r/R        raw string - suppress meaning of escape characters<br>''' '''    docstring - describe a module, function, class, or method<br><br>The [] slice operator and [:] range slice operator recognize that a string is<br>simply a list containing an individual character within each element, which can<br>be referenced by their index number.<br><br>Similarly, the in and not in membership operators iterate through each element<br>seeking to match the specified character.<br><br>The raw string operator, r, must be placed immediately before the opening quote<br>mark to suppress escape characters in the string, and is useful when the string<br>contains the backslash character.<br><br>A docstring is a descriptive string literal that occurs as the first statement<br>in a module, a function, a class, or a method definition. This should be<br>enclosed within triple single quote marks. Uniquely, the docstring becomes the<br>_doc_ special attribute of that object, so can be referenced using its name and<br>dot-suffixing. All modules should normally have docstrings, and all functions<br>and classes exported by a module should also have docstrings.<br><br>The membership operators performa case-sensitive match, so A in abc will fail.<br>The range slice returns the string up to, but not including, the final specified<br>index position.<br><br><code>def display(s):</code><br><code>    '''Display an argument value.'''</code><br><code>    print(s)</code><br><code>display(display.__doc__)</code><br><code>display(r'home\jason')</code><br><code>display('\nHello' + ' Andromeda')</code><br><code>display('C++ is cool, too!\n'[0:11])</code><br><code>display('C' in 'C++')</code><br><code>display('r' in 'Andromeda')</code><br><br>The doc keyword is preceded by 2 underscores and followed by 2 underscores.<br>Remember that strings must be enclosed within either single quote marks or<br>double quote marks. With range slice, if the start index number is omitted, zero<br>is assumed, and if the end index number is omitted, the string length is<br>assumed.<br><br><span style="color: #169179;"><strong>Formatting Strings</strong></span><br>The python built-in dir() function can be useful to examine the names of<br>functions and variables defined in a module by specifying the module name within<br>its parentheses. Interactive mode can easily be used for this purpose by<br>importing the module name then calling the dir() function. <br><br>Any defined names that begin and end with a double underscore are python<br>objects, whereas the others are programmer-defined. The __builtins__ module can<br>also be examined using the dir() function, to examine the names of functions and<br>variables defined by default, such as the print() function and a str object.<br><br>The str object defines several useful methods for string formatting, including<br>an actual format() method that performs replacements. A string to be formatted<br>by the format() method can contain both text and replacement fields marking<br>places where text is to be inserted from an ordered comma-separated list of<br>values. Each replacement field is denoted by {} braces, which may, optionally,<br>contain the index number position of the replacement in the list.<br><br>Strings may also be formatted using the C-style %s substitution operator to mark<br>places in a string where text is to be inserted from a comma-separated ordered<br>list of values.<br><br><code>book='{} and {}'.format('Chemistry', 'Electronics')</code><br><code>print('\nReplaced:', book)</code><br><code>book='{1} and {0}'.format('Chemistry', 'Electronics')</code><br><code>print('Replaced:', book)</code><br><code>book='%s and %s' %('Calculus', 'Proofs')</code><br><code>print('\nSubstituted:', book)</code><br><br>You cannot leave spaces around the index number in the replacement field. Other<br>data types can be substituted using %d for a decimal integer, and %f for a<br>floating-point number.</p><h2 id="mcetoc_1i8qq0dnn8" class="align-center"><span style="color: #236fa1;"><strong>Modifying Strings in Python</strong></span></h2><p><br>The python "str" object has many useful methods that can be dot-suffixed to its<br>name for modification of the string and to examine its contents. The most<br>commonly used string modification methods are listed below.<br><br>capitalize()        change string's first letter to uppercase<br>title()             change all first letters to uppercase<br>upper()             change the case of all letters to uppercase<br>lower()             change the case of all letters to lowercase<br>swapcase()          change to the inverse of the current case<br>removeprefix(sub)   remove substring from start of string<br>removesuffix(sub)   remove substring from end of string<br>join (seq)          merge into string into separator sequence<br>lstrip()            remove leading whitespace, trailing<br>rstrip()            remove trailing whitespace<br>strip(0)            remove leading and trailing whitespace<br>replace(old,new)    replace all occurrencies of old with new<br>ljust(w,c)          pad string to left to total column width by c<br>rjust(w,c)          pad string to right to total column width by c<br>center(w,c)         pad string each side to total column width by c<br>count(sub)          return the number of occurrences by sub<br>find(sub)           return the index number of the first occurrence of<br>                    sub<br>startswith(sub)     return true if sub is found at start<br>endswith(sub)       return true if sub is found at end<br>isalpha()           return true if all characters are letters only<br>isnumeric()         return true if all characters are numeric only<br>isalnum()           return true if letters or numbers only<br>islower()           return true if string characters are lowercase<br>isupper()           return true if string characters are uppercase<br>istitle()           return true if all first letters are uppercase<br>isspace()           return true if string contains only whitespace <br>isdigit()           return true if string contains only digits<br>isdecimal()         return true if string contains only decimals<br><br>A space character is not alphanumeric so isalnum() returns false when examining<br>strings that contains spaces.<br><br><code>string = "age of mythology is a great game"</code><br><code>print("\nCapitalized:\t", string.capitalize())</code><br><code>print("\nTitled:\t\t", string.title())</code><br><code>print("\nCentered:\t", string.center(30,'*'))</code><br><code>print("\nUppercase:\t", string.upper())</code><br><code>print("\nJoined:\t\t", string.join('**'))</code><br><code>print("\njustified:\t", string.rjust(30,'*'))</code><br><code>print("\nReplaced:\t", string.replace('s', '*'))</code><br> <br>With the rjust() method a right justified string gets padding added to<br>its left, and with the ljust() method a left justified string gets<br>padding added to its right.<br><br><span style="color: #169179;"><strong>Converting Strings</strong></span><br>Before python 3.0, string characters were stored by their ascii numeric<br>code values in the range 0-127, representing only unaccented latin<br>characters. For example, the lowercase letter 'a' is assigned 97 as its<br>ascii code value. Each byte of computer memory can store values in the<br>range 0-255 but this is still too limited to represent all accented<br>characters and non-Latin characters. <br><br>For example, accented characters used in Western Europe and the<br>cyrillic alphabet used for Russian cannot be represented in the range<br>128-255 because there are more than 127 such characters. Recent<br>versions of python overcome this limitation by storing string<br>characters as their unicode code point value to represent all<br>characters and alphabets in the numeric range 0-1,114,112. Characters<br>that are above the ascii range may require two bytes for their code<br>point value. <br><br>The str object's encode() method can be used to convert from the<br>default unicode encoding, and its decode() method can be used to<br>convert back to the unicode default encoding. Python's unicodedata<br>module provides a name() method that reveals the unicode name of each<br>character. Accented and non-Latin characters can be referenced by<br>their unicode name or by decoding their unicode hexidecimal point<br>value.<br><br>The term ascii is an acronym for american standard code for<br>information interchange. You can use the character map app in Windows<br>accessories to select non-ascii characters. A string containing byte<br>addresses must be immediately prefixed by a 'b' to denote that string<br>as a byte literal. unicode names are uppercase and referenced by<br>inclusion between {} braces prefixed by a \N in this notation format.</p><h2 id="mcetoc_1i935g7tg18" class="align-center"><span style="color: #236fa1;"><strong>Accessing Files in Python</strong></span></h2><p><span style="color: #169179;"><strong>Accessing Files</strong></span><br>The _builtins_ module can be examined using the "dir()" function to reveal that<br>it contains a file object that defines several methods for working with files,<br>including "open()", "read()", "write()", and "close()".<br><br>Before a file can be read or written, it must always be opened using the<br>"open()" method. This requires two string arguments to specify the name and<br>location of the file, and one of the following "mode" specifiers in which to<br>open the file:<br><br>r       open an existing file to read<br>w       open an existing file to write<br>a       Append text and opens/creates a text file for writing at the end of the<br>        file<br>r+      open a text file to read from or write to<br>w+      open a text file to write to or read from<br>a+      open or creates a text file to read from or write to at the end of the<br>        file<br><br>Where the mode includes  "b" after any of the file modes listed above, the<br>operation relates to a binary file rather than a text file: rb or w+b<br><br>Once a file is opened and you have a file object, you can get various details<br>related to that file from its properties.<br><br>name        name of the opened file<br>mode        mode in which the file was opened<br>closed      status boolean value of True or False<br>writeable() write permission boolean value of True or False<br><br>File mode arguments are string values so must be surrounded by quotes. You can<br>also use a "readlines()" method that returns a list of all lines.<br><br><code>file = open('document.txt', 'w')</code><br><br><code>print('File Name:', file.name)</code><br><code>print('File Open mode:', file.mode)</code><br><br><code>print('Readable:', file.readable())</code><br><code>print('Writable:', file.writable())</code><br><br><code>def get_status(f):</code><br><code>    if (f.closed != False):</code><br><code>        return 'Closed'</code><br><code>    else:</code><br><code>        return 'Open'</code><br><code>        </code><br><code>print('File Status:', get_status(file))</code><br><code>file.close()</code><br><code>print('\nfile Status:', get_status(file))</code><br><br>If your program tries to open a non-existant file in "r" mode, the interpreter<br>will report an error.<br><br><span style="color: #169179;"><strong>Reading and Writing Files</strong></span><br>Once a file has been successfully opened it can be read or added to, or new text<br>can be written in the file, depending on the mode, specified in the call to the<br>open() method. Following this, the open file must then always be closed by<br>calling the close() method.<br><br>As you might expect, the read() method returns the entire content of the file,<br>and the write() method adds content to the file. You can quickly read the entire<br>contents in a loop, iterating line by line. Writing to an existing file will<br>automatically overwrite its contents. <br><br><code>LaTeX =  "LaTeX is used to add math to the web\n"</code><br><code>LaTeX += "Fractions are made using this notation: \\frac[4}{5}\n"</code><br><code>LaTeX += "Exponents are made by: a^{4n}\n"</code><br><code>LaTeX += "Subscripts are made by: a_{4n}\n"</code><br><br><code>file = open('LaTeX.txt', 'w')</code><br><code>file.write(LaTeX)</code><br><code>file.close()</code><br><code>file = open('LaTeX.txt', 'r')</code><br><br><code>for line in file:</code><br><code>    print(line, end = '')</code><br><code>file.close()</code><br><br>Suppress the default newline provided by the print() function where the strings<br>themselves contain newlines. You can also use the obkect's readlines() method<br>that returns a list of all lines in a file - one line per element.<br><br><span style="color: #169179;"><strong>Updating File Strings</strong></span><br>A file object's read() method will, by default, read the entire contents of the<br>file from the very beginning, at index position zero, to the very end - at the<br>index position of the final character. Optionally, the read() method can accept<br>an integer argument to specify how many characters it should read.<br><br>The position within the file, from which to read or at which to write, can be<br>finely controlled using the file object's seek() method. This accepts an integer<br>argument specifying how many characters to move position as an offset from the<br>start of the file.<br><br>The current position within the file can be discovered at any time by calling<br>the file object's tell() method to return an integer location.<br><br>When working with file objects it is good practice to use the Python "with"<br>keyword to group the file operational statements within a block. This technique<br>ensures that the file is properly closed after operations end, even if an<br>exception is raised on the way, and is much shorter than writing equivalent "try<br>except" blocks.<br><br><span style="color: #169179;"><strong>Storing Data</strong></span><br>In Python, string data can easily be stored in text files using the<br>techniques demonstrated in the previous examples. Other data types, such as<br>numbers, lists, or dictionaries, could also be stored in text file but would<br>require conversion to strings first. Restoring that stored data to their<br>original data type on retrieval would require another conversion. An easier<br>way to achieve data persistence of any data object is provided by the pickle<br>method.<br><br>The process of pickling objects stores a string representation of an object that<br>can later be unpickled to its former state, and is a very common Python<br>programming procedure.<br><br>An object can be converted for storage in a file by specifying the object and<br>file as arguments to the pickle object's dump() method. It can later be restored<br>from that file by specifying the file name as the sole argument to the pickle<br>obkect's load() method.<br><br>Unless the storage file needs to be human readable for some reason, it is more<br>efficient to use a machine readable binary file.<br><br>Where the program needs to check for the existence of a storage file, the "os"<br>module provides a path object with an isfile() method that returns True if a<br>file is specified within its parentheses is found.</p><p><code>import pickle, os</code><br><code>if not os.path.isfile('pickle.dat'):</code><br><code>    data = [0,1]</code><br><code>    data[0] = input('Enter Topic:')</code><br><code>    data[1] = input('Enter Series:')</code><br><code>    file = open('pickle.dat', 'wb')</code><br><code>    pickle.dump(data,file)</code><br><code>    file.close()</code><br><code>else:</code><br><code>    file = open('pickle.dat', 'rb')</code><br><code>    data = pickle.load(file)</code><br><code>    file.close()</code><br><code>    print('\nWelcome Back To:', data[0], data[1])</code></p><h2 id="mcetoc_1i9fdkn49kv" class="align-center"><span style="color: #236fa1;"><strong>Encapsulating Data in Python</strong></span></h2><div>A class is a specified prototype describing a set of properties that</div><div>characterize an object. Each class has a data structure that can contain both</div><div>functions and variables to characterize the object.</div><div> </div><div>The properties of a class are referred to as its data members. Class function</div><div>members are known as its methods, and class variable members are known as its</div><div>attributes.</div><div> </div><div>Class members can be referenced throughout a program using dot notation,</div><div>suffixing the member name after the class name, with syntax of</div><div>class-name.method-() or class-name.attribute-name.</div><div> </div><div>A class declaration begins with the class keyword, followed by a</div><div>programmer-specified name then a colon. Next, indented statements optionally</div><div>specifying a class document string, class variable attribute declarations, and</div><div>class method definitions, so the class block syntax looks like this:</div><div> </div><div><code>class ClassName:</code></div><div><code>'''class-documentation-string'''</code></div><div><code>class-variable-declarations</code></div><div><code>class-method-definitions</code></div><div> </div><div>The class declaration, which specifies its attributes and methods, is a</div><div>blueprint from which working copies can be made.</div><div> </div><div>All variables declared within method definitions are known as instance variables</div><div>and are only available locally within the method in which they are declared.</div><div>They cannot be directly referenced outside the class structure.</div><div> </div><div>Typically, instance variables contain data passed by the caller when an instance</div><div>copy of the class is created. As this data is only available locally for</div><div>internal use, it is effectively hidden from the rest of the program. This</div><div>technique of data encapsulation ensures that data is securely stored within the</div><div>class structure and is the first principle of object oriented programming.</div><div> </div><div>All properties of a class are referenced internally by the dot notation prefix</div><div>self-so an attribute named sound is self.sound. Additionally, all method</div><div>definitions in a class must have self as their first argument, so a method named</div><div>talk is talk(self).</div><div> </div><div>When a class instance is created, a special _init_(self) method is automatically</div><div>called. Subsequent arguments can be added in its parentheses if values are to be</div><div>passed to initialize its attributes.</div><div> </div><div>It is conventional to begin class names with an uppercase character, and object</div><div>names with lowercase. The class documentation string can be accessed via the</div><div>special__doc__ docstring attribute with Classname__doc__. While a program class</div><div>cannot perfectly emulate a real-world object, the aim is to encapsulate all</div><div>relevant attributes and actions.</div><div> </div><div><span style="color: #169179;"><strong>Objects</strong></span></div><div>An instance of a class object is simply a copy of the prototype created by</div><div>calling that class name's constructor and specifying the required number of</div><div>arguments within its parentheses. The call's arguments must match those</div><div>specified by the __init__() method definition, other than a value for the</div><div>internal self argument.</div><div> </div><div>The class instance object returned by the constructor is assigned to a variable</div><div>using the syntax instance-name=ClassName(args).</div><div> </div><div>Dot notation can be used to reference the methods and class variable attributes</div><div>of an instance object by suffixing their name as instance-name.method-name() or</div><div>instance-name.attribute.name.</div><div> </div><div>Typically, a base class can be defined as a python module file so it can be</div><div>imported into other scripts where instance objects can be easily created from</div><div>the master class prototype.</div><div> </div><div>A constructor creates an instance of a class and is simply the class name</div><div>followed by parentheses containing any required argument values. You must not</div><div>pass an argument value for the self argument, as this is automatically</div><div>incorporated by python.</div><div> </div><div><span style="color: #169179;"><strong>Class Attributes</strong></span></div><div>An attribute of a class can be added, modified, or removed at any time using dot</div><div>notation to address the attribute. Making a statement that assigns a value to an</div><div>attribute will update the value contained within an existing attribute or create</div><div>a new attribute of the specified name containing the assigned value:</div><div>instance-name.attribute-name=value</div><div>del instance-name.attribute-name</div><div> </div><div>Alternatively, you can use the following built in function to add, modify, or</div><div>remove an instance variable:</div><div>getattr(instance-name, 'attribute-name') - return the attribute value of the</div><div>class instance.</div><div> </div><ul><li>hasattr(instance-name, 'attribute-name') - return True if the attribute value</li><li>exists in the instance, otherwise return False.</li><li>setattr(instance-name, 'attribute-name', value) - update the existing attribute</li><li>value or create a new attribute in the instance.</li><li>delattr(instance-name, 'attribute-name') - remove the attribute from the</li><li>instance.</li></ul><div> </div><div>The name of attributes autmatically supplied by python always begin with an</div><div>underscore character to notationally indicate privacy so these should not be</div><div>modified or removed. You can add your own attributes named in this way to</div><div>indicate privacy if you wish, but in reality these can be modified like any</div><div>other attribute.</div><div> </div><div>The attribute name specified to these built in functions must be enclosed within</div><div>quotes. </div><div> </div><div><span style="color: #169179;"><strong>Built-In Attributes</strong></span></div><div>Each python class is automatically created with a number of built-in private</div><div>attributes whose values can be referenced using dot notation. For example, with</div><div>class-name.__doc__ to see the document string value of a specified class name.</div><div> </div><div>The built-in dir() function can be used to display a list of all the built-in</div><div>attributes in a class specified within its parentheses by testing whether each</div><div>attribute name begins with an underscore.</div><div> </div><div>The built-in __dict__ attribute contains a namespace dictionary of class</div><div>component keys and their associated values. The dictionary of a base class</div><div>includes its default __init__() method, and all class methods and attributes.</div><div>The dictionary of a class instance includes its instance attributes.</div><div> </div><div>The function values stored in the dictionary are the machine addresses where the</div><div>functions are stored.</div><div> </div><div>A class instance is first created so the __init__() method has been called to</div><div>increment the count value before the dictionary gets listed. The __weakref()__</div><div>attribute is simply used internally for automatic garbage collection of weak</div><div>references in the program for efficiency.</div><div> </div><h2 id="mcetoc_1i9ukn71s7" class="align-center"><span style="color: #236fa1;"><strong>Inheritance in Python</strong></span></h2><p>When a class instance object is created it is allocated a unique memory address<br>that can be seen using the built in id() function. Python automatically performs<br>garbage collection to free up memory space by periodically deleting un-neded<br>objects such as class instances, so their memory address becomes vacat. <br><br>Whenever an object gets assigned a new name or gets placed in a container, such<br>as a list, its reference count increases. Conversely, whenever these are removed<br>or go out of scope its count decreases. The object becomes elegible for<br>collection when the count is zero. <br><br>Destorying an instance of a class may call upon a destructor to execute a _del_<br>method, explicitly reclaiming occupied memory space and executing any specified<br>statements.<br><br>The second instance created here is allocated the memory address vacated when<br>the first instance was deleted. <br><br><span style="color: #169179;"><strong>Inheriting Features</strong></span><br>A python class can be created as a brand new class, like those in previous<br>examples, or can be derived from an existing class. Importantly, a derived class<br>inherits members of the parent class from which it is derived, in addition to<br>its own members.<br><br>The ability to inherit members from a base class allows derived classes to be<br>created that share certain common properties, which have been defined in the<br>base class. For example, a 'polygon' base class may define width and height<br>properties that are common to all polygons. Classes of 'rectangle' and<br>'triangle' could be derived from the polygon class, inheriting width and height<br>properties, in addition to their own members defining their unique features. <br><br>The virtue of inheritance is extremely powerful , and is the second principle of<br>object oriented programming.<br><br>A derived class declaration adds () parentheses after its class name specifying<br>the name of its parent class. <br><br><code>class polygon:</code><br><code>    width=0</code><br><code>    height=0</code><br><code>    def set_values(self, width, height):</code><br><code>        polygon.width=width</code><br><code>        polygon.height=height</code><br><br>Now, create a new file that declares a derived class with a method to return<br>manipulated class variable values.<br><br><code>from polygon import *</code><br><code>class rectangle(polygon):</code><br><code>    def area(self):</code><br><code>        return self.width * self.height</code><br><br>Create another new file that declares a derived class with a method to return<br>manipulated class variable values.<br><br><code>from polygon import *</code><br><code>class triangle(polygon):</code><br><code>    def area(self):</code><br><code>        return(self.width * self.height) / 2</code><br><br>Now, start a new file making features of both derived classes available. <br><br><code>from rectangle import *</code><br><code>from triangle import *</code><br><code>rect=rectangle()</code><br><code>trey=triangle()</code><br><code>rect.set_values(4,5)</code><br><code>trey.set_values(4,5)</code><br><code>print("Rectangle Area:", rect.area())</code><br><code>print("Triangle Area:", trey.area())</code><br><br>A class declaration can derive from more than one class by listing multiple base<br>classes in the parentheses after its name in the declaration. Don't confuse<br>class instances and derived instances. An instance is a copy of a class,<br>whjereas a derived class is a new class that inherits properties of the base<br>class from which it is derived.<br><br><span style="color: #169179;"><strong>Overriding Base Methods</strong></span><br>A method can be declared in a derived class to override a matching method in the<br>base class-if both method declarations have the same name and the same number of<br>listed arguments. This effectively hides the base class method as it becomes<br>inaccessible unless it is called explicitly, using the base class name for<br>identification. <br><br>Where a method in a base class supplies a default argument value this can be<br>used in an explcit call to the base methods, or alternative values can be<br>supplied by overriding methods.<br><br>The method declaration in the derived class must exactly match that in the base<br>class to override it. <br><br><span style="color: #169179;"><strong>Polymorphism</strong></span><br>The three cornerstones of object oriented programming are encapsulation,<br>inheritance, and polymorphism. Examples earlier have demonstrated how data can<br>be encapsulated within a python class, and how derived classes inherit the<br>properties of their base class. This example introduces the final cornerstone<br>principle of polymorphism.<br><br>The term polymorphism describes the ability to assign a different meaning or<br>purpose to an entity according to its context.<br><br>In python, the + character entity can be described as polymorphic because it<br>represents either the arithmetical addition operator or the string concatenation<br>operator, in the context of character operands.<br><br>Perhaps more importantly, python class methods can also be polymorphic because<br>the python language uses duck typing.<br><br>In a duck typing language you can create a function to take an object of any<br>type and call that object's methods. If the object does indeed have the call<br>methods they are executed, otherwise the function signals a run-time error.<br><br>Like-named methods of multiple classes can be created and instances of those<br>same classes will execute the associated version.<br><br>Object-oriented programming with python allows data encapsulation, inheritance,<br>and polymorphism. Base class methods can be overridden by like-named emthods in<br>derived classes. Python does not support the technique of overloading found in<br>other languages-in which methods of the same name can be created with different<br>argument lists in a single class. <br><br>A class can have only one method-method overloading is not supported in python.<br><br>A class is a data structure prototype describing object properties with its<br>methods and attribute members. Each class declaration begins with the class<br>keyword, and is followed by an indented code block that may contain a class<br>document string, class variables, and class methods.<br><br>Class variables have global scope, but instance variables have only local scope.<br>instance variables encapsulate data securely in a class structure, and are<br>initialized when a class instance is created.<br><br>Properties of a class are referenced by dot notation, and are addressed<br>internally using the self prefix. A class instance is a copy of the prototype<br>that automatically calls its __init__() method when the instance is first<br>created.<br><br>An attribute of a class can be added, modified, or removed using dot notation or<br>manipulated using the built-in functions getattr(), hasattr(), and delattr().<br>The name of attributes automatically supplied by python begins with an<br>underscore character to notionally indicate privacy.<br><br>The built-in __dict__ attribute contains a namespace dictionary of class<br>component keys and values. Python automatically performs garbage collection, but<br>the del keyword can remove objects and call the class destructor. A derived<br>class inherits the method and attribute members of the parent base class from<br>which it is derived.<br><br>A method of a derived class can override a matching method of the same name in<br>its parent class. Python is a duck-typed language that supports polymorphism for<br>like-named methods of multiple classes.</p><h2 id="mcetoc_1ib2b31p75" class="align-center"><span style="color: #236fa1;"><strong>Sending Web Responses in Python</strong></span></h2><p><span style="color: #169179;"><strong>Sending Web Responses</strong></span><br>Whenever a user asks to view an online web page in their browser it requests the<br>page from the web server, and receives the page in response, via the http<br>protocol.<br><br>Where a requested web page address is an html document, with an .html file<br>extension, the web server response will return that file to the browser so its<br>contents can be displayed.<br><br>Where python is installed on the computer hosting the web server, the web server<br>can be configured to recognize python scripts and call upon the python<br>interpreter to process script code before sending an html response to the web<br>server, for return to the browser client.<br><br>A python script requested by a web server can generate a complete html document<br>response by describing the content type on the first line as<br>"content-type:text/html/r/n/r/n" so the web browser will parse the markup<br>content for display on the screen.<br><br>The content-type output description gets sent as an http header to the browser,<br>and must appear on the first line.<br><br>Enclose html attribute values within double quote marks so they do not get<br>confused with the single quote marks enclosing the strings.<br><br><span style="color: #169179;"><strong>Handling Values</strong></span><br>Values can be passes to a python script on the web server when the browser makes<br>an http request. Those values can be used in the script and echoed in a response<br>returned to the browser.<br><br>Python's cgi module can be used to easily handle data passes from the web<br>browser by an http request. This provides a "fieldstorage()" constructor that<br>creates an object storing the passed data as a dictionary of key:value pairs.<br>Any individual value  can then be retrieved by specifying its associated key<br>name within the parentheses of the "fieldstorage" object's "getvalue()" method. <br><br>The browser can submit data to the script using a "get" method that simply<br>appends key:value pairs to the script's url address. These follow a ? question<br>mark character after the file name and multiple pairs must be separated by an &amp;<br>ampersand character. <br><br>The request string in the get method is lmited to 1024 characters so is<br>unsuitable for passing lots of key:value pairs. The values appended to the url<br>are visible in the browser address field of the response, so the get method<br>should not be used to send passwords or other sensitive data values to the web<br>server.<br><br><span style="color: #169179;"><strong>Submitting Forms</strong></span><br>Passing data from a web page to a web server using the get method to append<br>key:value pairs to a url is simple, but has some limitations - the request<br>string length cannot exceed 1024 characters, and the values appear in the<br>browser address field.<br><br>As a more reliable alternative, the browser can submit data to the data script<br>using a post method that sends the information to the web server as a separate<br>message not appended to the url.<br><br>Python's cgi module can be used to handle form data sent from the browser with<br>the post method in exactly the same way as data passed from the browser with the<br>get method. This module's fieldstorage() constructor can create an object to<br>store the posted data as a dictionary of key:value pairs for each form field.<br>Any individual value can be retrieved by specifying its associated key name to<br>the object's getvalue() method.<br><br><span style="color: #169179;"><strong>Providing Text Areas</strong></span><br>Large amounts of user-input text data can be passed from a web page to a web<br>server using the html &lt;textarea&gt; tags and the form post method. This tag has no<br>value attribute so a default value may not be provided. It is useful to have the<br>python script test whether the text area has been left blank and provide a<br>default value when the user has entered no text.<br><br>The average character width may vary between browsers - so the physical size of<br>the text area field may vary too. You can use the F12 developer tools in your<br>web browser to examine the http request and response components.<br><br><span style="color: #169179;"><strong>Checking Boxes</strong></span><br>An html form can provide a visual checkbox on/off switch that the user can<br>toggle to include its associated data for submission to the web server. The<br>python script nominated to handle the form data can test whether each checkbox<br>has been checked, simply by testing if a value has been received from the<br>checkbox of that name.<br><br>The "checked" keyword can be added in any checkbox &lt;input&gt; element to make it<br>checked by default.<br><br><span style="color: #169179;"><strong>Choosing Radio Buttons</strong></span><br>An html form can provide a 'radio button" group from which the user can select<br>just one button to submit its associated data to the web server. Unlike<br>checkboxes, radio buttons that share a common name are mutually exclusive, so<br>when one button in the group is selected, all other buttons in that group are<br>switched off. The python script nominated to handle the form data can test the<br>value submitted for the radio button group name and supply an appropriate<br>response. <br><br>Always include a "checked" attribute to automatically select one button in each<br>radio button group - to include a default choice. Radio button elements resemble<br>the buttons on old radios where each button selected a particular radio station.<br><br><span style="color: #169179;"><strong>Selecting Options</strong></span><br>An html form can provide a drop-down list of possible options from which the<br>user can select a single option to include its associated data for submission to<br>the web server. The submitted value can then be retrieved by specifying its<br>associated list key name within the parentheses of the "fieldstorage" object's<br>"getvalue()" method. <br><br>Typically, the first list option will be selected for submission by default,<br>unless you click open the drop-down list and select an alternative. You can<br>include the selected attribute in an &lt;option&gt; tag to automatically select one<br>option in each list - to include a default choice. <br><br><span style="color: #169179;"><strong>Updating Files</strong></span><br>An html form can provide a file selection facility, which calls opon the<br>operating system's "choose file" dialog, to allow the user to browse their local<br>file system and select a file. To enable this facility the html &lt;form&gt; tag must<br>include an 'enctype" attribute specifying the encoding type as<br>multiple/form-data.<br><br>The full path address of the file selected for upload is a value stored in the<br>fieldstorage object list that can be accessed using its associated key name.<br>Usefully, the file name can be stripped from the path address by the "os"<br>module's "path.basename()" method.<br><br>Notice that binary file mode is used here to copy the uploaded file.<br><br><span style="color: #169179;"><strong>Summary</strong></span><br>Python can be installed on a web server host to process script code before<br>sending a response to a web browser client. A server-side python script can<br>generate an html document by describing the content type as<br>"content-type:text/html/r/n/r/n".<br><br>The cgi module provides a fieldstorage() constructor to create an object for<br>storing submitted data as key:value pairs. Any value stored in a fieldstorage<br>object can be retrieved by specifying its key name to the object's getvalue()<br>method.<br><br>The browser can send data to a script using the get method that appends<br>key=value pairs to its url address after a ? question mark. Multiple key=value<br>pairs of data can be submitted using the get method if each pair is separated by<br>an &amp; ampersand character. <br><br>The get method request string length cannot exceed 1024 characters and will be<br>visible in the browser address field. The browser can send data to a script<br>using the post method that submits key:value pairs as a separate message.<br><br>Data submitted from an html form can be stroed in a fieldstorage object as<br>key:value pairs for each form field. A server-side python script can provide<br>default values for submitted html form fields that the user has left blank.<br><br>Checkbox fields of an html form that are unchecked do not get submitted to the<br>web server. A selected radio button in a group provides the value to be<br>associated with the group name when the form gets submitted.<br><br>A selected item in a drop-down list provides the value to be associated with the<br>list name when the form gets submitted. An html form can allow file uploads only<br>if its "enctype" attribute specifies its encoding type as "multiple/form-data". </p><h2 id="mcetoc_1im5afsoat" class="align-center"><span style="color: #236fa1;"><strong>Launching a Window in Python</strong></span></h2><p>The standard python module that you can use to create graphical applications is<br>called "tkinter", a toolkit to interface with the system gui.<br><br>The tkinter module can be imported into a program like any other module to<br>provide attributes and methods for windowed apps. Every tkinter program must<br>begin by calling the tk() constructor to create a window object. The window's<br>size can be specified as a "widthxheight" string argument to the window object's<br>geometry() method. Similarly, the window's title can be specified as a title<br>string argument to the window object's title() method. If not specified, default<br>size and title values will be used.<br><br>Every tkinter program must also call the window object's mainloop() method to<br>capture events, such as when the user closes the window to quit the program.<br>This loop should appear at the end of the program as it also handles window<br>updates that may be implemented during execution.<br><br>With tkinter, all the graphical controls that can be included in the application<br>window, such as buttons or checkboxes, are referred to as widgets. Perhaps the<br>simplest widget is a non-interactive label object that merely displays text or an<br>image in the app interface. A label object can be created by specifying the<br>window object's name and text='string' as arguments to a Label() constructor. <br><br>Once created, each widget, such as a label, must then be added to the window<br>using one of these geometry manager methods.</p><p><br>pack()-places the widget against a specified side of the window using Top,<br>Bottom, left, or Right constant values specified to its side=argument.<br><br>place()-places the widget at XY coordinates in the window using numerical values<br>specified to its x= and y= arguments.<br><br>grid()-places the widget in a cell within the window using numerical values<br>specified to its row= and column= arguments.<br><br><br></p><p>Optionally, the pack() method may include a fill argument to expand the widget<br>in available space. For example, with fill='x'. Alternatively, the pacl() method<br>may include padx and pady arguments to expand the widget along an axis by a<br>specified amount.<br><br>There can be only one call to the TK() constructor and it must be at the start<br>of the program code.<br><br><code>from tkinter import *</code><br><code>window=Tk()</code><br><code>window.title('Window Label')</code><br><code>label=Label(window, text='This is an introduction to interfaces in Python')</code><br><code>label.pack(padx=200, pady=50)</code><br><code>window.mainloop()</code><br><br>Widgets will not appear in the window when running the program unless they have<br>been added with a program manager.<br><br><span style="color: #169179;"><strong>Responding to Buttons</strong></span><br>A button widget provides a graphical button in an application window that may<br>contain either text or an image to convey the button's purpose. A button object<br>is created by specifying the window name and options as arguments to a button()<br>constructor. Each option is specified as an option=value pair. The command<br>option must always specify the name of a function or method to call when the<br>user clicks that button. The most popular options are listed below, with a brief<br>description.<br><br>activebackground    background color when the cursor is over<br>activeforeground    foreground color when the cursor is over<br>bd            border width in pixels(default is 2)<br>bg            background color<br>font            font for button label<br>height            button height in text lines, or pixels for images<br>highlightcolor        border color when in focus<br>image            image to be displayed instead of text<br>justify            multiple text lines as Left, center, or Right<br>padx            horizontal padding<br>pady            vertical padding<br>relief            border style of Sunken, Ridge, Raised or Groove<br>state            enabled status of normal or Disabled<br>underline        index number in text of character to underline<br>width            button width in letters, or pixels for images<br>wraplength        length at which to wrap text<br><br>The values assigned to other options determine the widget's appearance. These<br>can be altered by specifying a new option=value pair as an argument to the<br>widget's configure() method. Additionally, a current option value can be<br>retrieved by specifying its name as a string argument to the widget's cget()<br>method.<br><br>You can also call a button's invoke() method to call the function nominated to<br>its command option. <br><br><code>from tkinter import *</code><br><code>window=Tk()</code><br><code>window.title('Click this Button')</code><br><code>btn_end=Button(window, text='Close', command=exit)</code><br><code>def tog():</code><br><code>    if window.cget('bg')=='yellow':</code><br><code>        window.configure(bg='gray')</code><br><code>    else:</code><br><code>        window.configure(bg='yellow')</code><br><code>btn_tog=Button(window,text='Switch', command=tog)</code><br><code>btn_tog.pack(padx=150,pady=20)</code><br><code>btn_end.pack(padx=150,pady=20)</code><br><code>window.mainloop()</code><br><br>Only the function name is specified to the command option. Do not add trailing<br>parentheses in the assignment. The 'gray' color is the original default color of<br>the window.<br><br><span style="color: #169179;"><strong>Displaying Messages</strong></span><br>A program can display messages to the user by calling methods provided in the<br>"tkinter.messagebox" module. This must be imported separately and its lengthy<br>name can be assigned a short alias by an "import as" statement.<br><br>A message box is created by supplying a box title and the message to be<br>displayed as the two arguments to one of these methods.<br><br>showinfo()            ok<br>showwarning()        ok<br>showerror()            ok<br>askquestion()        yes and no<br>askofcancel()        ok returns 1 and cancel<br>askyesno()            yes returns 1 and no<br>askretrycancel()    retry returns 1 and cancel<br><br>Those methods that produce a message box containing a single OK button return no<br>value when the button gets clicked by the user. Those that do not return a value<br>can be used to perform conditional branching by testing that value.<br><br><code>from tkinter import *</code><br><code>import tkinter.messagebox as box</code><br><code>window=Tk()</code><br><code>window.title('Message')</code><br><code>def dialog():</code><br><code>    var=box.askyesno('Message', 'Proceed?')</code><br><code>    if var==1:</code><br><code>        box.showinfo('Yes Box', 'Proceeding...')</code><br><code>    else:</code><br><code>        box.showwarning('No box', 'Canceling...')</code><br><code>btn=Button(window, text='Click', command=dialog)</code><br><code>btn.pack(padx=150, pady=50)</code><br><code>window.mainloop()</code><br><br>Options can be added as a third argument to these method calls. For example, add<br>'type=abortretryignore' to get three buttons.<br><br><span style="color: #169179;"><strong>Gathering Entries</strong></span><br>An entry widget provides a single-line input field in an application where the<br>program can gather entries from the user. An entry object is created by<br>specifying the name of its parent container, such as a window or frame name, and<br>options as arguments to an Entry() constructor. Each option is specified as an<br>option=value pair. Popular options are listed below, together with a brief<br>description.<br><br>bd                    border width in pixels(default is 2)<br>bg                    background color<br>fg                    foreground color used to render the text<br>font                font for the text<br>highlightcolor        border color when in focus<br>selectbackground    background color of selected text<br>selectforeground    foreground color of selected text<br>show                hide password characters with show='*'<br>state                enabled status of Normal or Disabled<br>width                entry width in letters<br><br>Multiple widgets can be grouped in frames for better positioning. A frame object<br>is created by specifying the name of the window to a Frame() constructor. The<br>frame's name can then be specified as the first argument to the widget<br>constructors to identify it as that widget's container.<br><br>When actually adding widgets to the frame you can specify which side to pack<br>them to in the frame with Top, Bottom, left, or Right constants. For example,<br>'entry.pack(side=Left)'.<br><br>Typically, an entry widget will appear alongside a label describing the type of<br>input expected there from the user, or alongside a button widget that the user<br>can click to perform some action on the data they have entered, so positioning<br>in a frame is ideal.<br><br>Data currently entered into an entry widget can be retrieved by the program<br>using that widget's get() method.<br><br><code>from tkinter import *</code><br><code>import tkinter.messagebox as box</code><br><code>window=Tk()</code><br><code>window.title('Entry Box')</code><br><code>frame=Frame(window)</code><br><code>entry=Entry(frame)</code><br><code>def dialog():</code><br><code>    box.showinfo('Greetings', 'Welcome ' + entry.get())</code><br><code>btn=Button(frame, text='Enter Name', command=dialog)</code><br><code>btn.pack(side=RIGHT, padx=5)</code><br><code>entry.pack(side=LEFT)</code><br><code>frame.pack(padx=20, pady=20)</code><br><code>window.mainloop()</code><br><br>Use a label widget instead of an Entry widget if you want to display text that<br>the user cannot edit.<br><br><span style="color: #169179;"><strong>Listing Options</strong></span><br>A Listbox widget provides a list of items in an application from which the user<br>can make a selection. A listbox object is created by specifying the name of its<br>parent container, such as a window or frame name, and options as arguments to a<br>Listbox() constructor. Popular options are listed below, together with a brief<br>description.<br><br>bd                    border width in pixels(default is 2)<br>bg                    background color<br>fg                    foreground color used to render the text<br>font                font for the text<br>height                number of lines in list(default is 10)<br>selectbackground    background color of selected text<br>selectmode            single(the default) or multiple selections<br>width                Listbox width in letters(default is 20)<br>yscrollcommand        attach to a vertical scrollbar<br><br>Items are added to the listbox by specifying a list index number and the item<br>string as arguments to its insert() method.<br><br>You can retrieve any item from a listbox by specifying its index number within<br>the parentheses of its get() method. Usefully, a listbox also has a<br>curselection() method that returns the index number of the currently selected<br>item, so this can be supplied as the argument to its get() method to retrieve<br>the current selection.<br><br><code>from tkinter import *</code><br><code>import tkinter.messagebox as box</code><br><code>window=Tk()</code><br><code>window.title('Listbox')</code><br><code>frame=Frame(window)</code><br><code>listbox=Listbox(frame)</code><br><code>listbox.insert(1, 'C++')</code><br><code>listbox.insert(2, 'Python')</code><br><code>listbox.insert(3, 'R')</code><br><code>def dialog():</code><br><code>    box.showinfo('Selection', 'Your Choice:')</code><br><code>    listbox.get(listbox.curselection())</code><br><code>btn=Button(frame, text='Choose', command=dialog)</code><br><code>btn.pack(side=RIGHT, padx=5)</code><br><code>listbox.pack(side=LEFT)</code><br><code>frame.pack(padx=30, pady=30)</code><br><code>window.mainloop()</code><br><br>If the selectmode is set to MULTIPLE, the curselection() method returns a tuple<br>of the selected index numbers.<br><br><span style="color: #169179;"><strong>Polling Radio Buttons</strong></span><br>A Radiobutton widget provides a single item in an application that the user may<br>select. Where a number of radio buttons are grouped together, they user may<br>only select any one item in the group. With tkinter, radio button objects are<br>grouped together when they nominate the same control variable object to assign a<br>value to upon selection. An empty string variable object can be created for this<br>purpose using the "stringvar()" constructor or an empty integer variable object<br>using the "intvar()" constructor. <br><br>A radio button object is created by specifying four arguments to a<br>"Radiobutton()" constructor.<br><br>1. name of the parent container, such as the frame name.<br>2. text for a display label, specified as a text=text pair.<br>3. control variable object, specified as a variable=variable pair.<br>4. value to be assigned, specified as a value=value pair.<br><br>Each radio button object has a select() method that can be used to specify a<br>default selection in a group of radio buttons when the program starts. A string<br>value assigned by selecting a radio button can be retrieved from a string<br>variable object by using its get() method.<br><br><code>from tkinter import *</code><br><code>import tkinter.messagebox as box</code><br><code>window=Tk()</code><br><code>window.title('Radio Button')</code><br><code>frame=Frame(window)</code><br><code>book=StringVar()</code><br><code>radio_1=Radiobutton(frame, text='Javascript', variable=book, value='web')</code><br><code>radio_2=Radiobutton(frame, text='C++', variable=book, value='microprocessor')</code><br><code>radio_3=Radiobutton(frame, text='R', variable=book, value='statistics')</code><br><code>radio_1.select()</code><br><code>def dialog():</code><br><code>    box.showinfo('Selection', 'Choice: ' + book.get())</code><br><code>btn=Button(frame, text='Choose', command=dialog)</code><br><code>btn.pack(side=RIGHT, padx=5)</code><br><code>radio_1.pack(side=LEFT)</code><br><code>radio_2.pack(side=LEFT)</code><br><code>radio_3.pack(side=LEFT)</code><br><code>frame.pack(padx=30, pady=30)</code><br><code>window.mainloop()</code><br><br>A Radiobutton object has a deselect() method that can be used to cancel a<br>selection programmatically.<br><br><span style="color: #169179;"><strong>Checking Boxes</strong></span><br>A Checkbutton widget provides a single item in an application that the user may<br>select. Where a number of check buttons appear together the user may select one<br>or more items. Check button objects nominate an individual control variable<br>object to assign a value to whether checked or unchecked. An empty string<br>variable object can be created for this using the stringvar() constructor or an<br>empty integer variable object using the intVar() constructor.<br><br>A check button object is created  by specifying five arguments to a<br>Checkbutton() constructor.<br><br>1. name of the parent container, such as the frame name<br>2. text for a display label, as a text=text pair<br>3. control variable object, as a variable=variable pair<br>4. value to assign if checked, as an onvalue=value pair<br>5. value to assign if unchecked, as an offvalue=value pair<br><br>An integer value assigned by a check button can be retrieved from an integer<br>variable object by its get() method.<br><br><code>from tkinter import *</code><br><code>import tkinter.messagebox as box</code><br><code>window=Tk()</code><br><code>window.title('Check Button')</code><br><code>frame=Frame(window)</code><br><code>var_1=IntVar()</code><br><code>var_2=IntVar()</code><br><code>var_3=IntVar()</code><br><code>book_1=Checkbutton(frame, text='C++', variable=var_1, onvalue=1, offvalue=0)</code><br><code>book_2=Checkbutton(frame, text='R', variable=var_2, onvalue=1, offvalue=0)</code><br><code>book_3=Checkbutton(frame, text='Javascript', variable=var_3, onvalue=1, offvalue=0)</code><br><code>def dialog():</code><br><code>    str='Your Choice:'</code><br><code>    if var_1.get()==1:str+='For Microprocessors'</code><br><code>    if var_2.get()==1:str+='For Statistics'</code><br><code>    if var_3.get()==1:str+='For Web Sites'</code><br><code>    box.showinfo('Selection', str)</code><br><code>btn=Button(frame, text='Choose', command=dialog)</code><br><code>btn.pack(side=RIGHT, padx=5)</code><br><code>book_1.pack(side=LEFT)</code><br><code>book_2.pack(side=LEFT)</code><br><code>book_3.pack(side=LEFT)</code><br><code>frame.pack(padx=30, pady=30)</code><br><code>window.mainloop()</code><br><br>A Checkbutton object has select() and deselect() methods that can be used to<br>turn the state on or off. For example, check_1, select(). The state of any<br>Checkbutton object can be reversed by calling its toggle() method.<br><br><span style="color: #169179;"><strong>Adding Images</strong></span><br>With the tkinter module, images in gif or pgm/ppm file formats can be displayed<br>on label, button, text, and canvas widgets using the PhotoImage() constructor to<br>create image objects. This simply requires a single file= argument to specify<br>the image file. It also has a subsample() method that can scale down a specified<br>image by stating a sample value to x= and y= arguments. For example, values of<br>x=2, y=2 samples every second pixel so the image object is half the size of the<br>original.<br><br>Once an image object has been created, it can be added to a label or button<br>constructor statement by an image= option. Text objects have an image_create()<br>method with which to embed an image into the text field. This requires two<br>arguments to specify location and image=. For example, '1.0' specifies the<br>first line and first character.<br><br>Canvas objects have a create_image() method that requires two arguments to<br>specify location and image=. Here, the location sets the x,y coordinates on the<br>canvas at which to paint the image.<br><br><code>from tkinter import *</code><br><code>window=Tk()</code><br><code>window.title('Image')</code><br><code>img=PhotoImage(file='galaxy.gif')</code><br><code>label=Label(window, image=img, bg='yellow')</code><br><code>small_img=PhotoImage.subsample(img, x=2, y=2)</code><br><code>btn=Button(window, image=small_img)</code><br><code>txt=Text(window, width=25, height=7)</code><br><code>txt.image_create('1.0', image=small_img)</code><br><code>txt.insert('1.0', 'Galaxies Are Cool')</code><br><code>can=Canvas(window, width=100, height=100, bg='cyan')</code><br><code>can.create_image((50,50), image=small_img)</code><br><code>can.create_line(0,0,100,100, width=25, fill='yellow')</code><br><code>label.pack(side=TOP)</code><br><code>btn.pack(side=LEFT, padx=10)</code><br><code>txt.pack(side=LEFT)</code><br><code>can.pack(side=LEFT, padx=10)</code><br><code>window.mainloop()</code><br><br>Notice that the text method is image_create() but the canvas method is<br>create_image(). Text and canvas widgets are both powerful and flexible. <br><br><span style="color: #169179;"><strong>Summary</strong></span><br>The tkinter module can be imported into a python program to provide attributes<br>and methods for windowed applications. Every tkinter program must begin by<br>calling Tk() to create a window and call its mainloop() method to capture<br>events.<br><br>The window object's title is specified by its title() method. A label widget is<br>created by specifying the name of its parent container and its text as arguments<br>to the Label() constructor.<br><br>Widgets can be added to an application using the pack(), grid(), or place()<br>geometry managers. A button widget is created by specifying the name of its<br>parent container, its text, and the name of a function to call when the user<br>pushes it, as arguments to the Button() constructor.<br><br>The tkinter.messagebox module can be imported into a python program to provide<br>attributes and methods for message boxes. Message boxes that ask the user to<br>make a choice return a value to the program for conditional branching.<br><br>The Frame() constructor creates a container in which multiple widgets can be<br>grouped for better positioning. The Entry() constructor creates a single line<br>text field whose current contents can be retrieved by its get() method.<br><br>Items are added to the Listbox object by its insert() method, and retrieved by<br>specifying their index numbers to its get() method. Radiobutton and Checkbutton<br>objects store values in the StringVar or IntVar object nominated by their<br>variable attribute.<br><br>The PhotoImage() constructor creates an image object that has a subsample()<br>method that can scale down an image. Images can be added to Button and Label<br>objects, embedded in Text objects, and painted on Canvas objects.</p><h2 id="mcetoc_1im5afsoau" class="align-center"><span style="color: #236fa1;"><strong>Creating Random Numbers in Python</strong></span></h2><p>Creating random numbers are one of the first tasks you learn to do. Well, they<br>are pseudo-random anyway. Base python includes a random function for us to get<br>started. You can create a text file to do this or use the python shell.<br><br><code>random()</code><br><br>The pseudo-random generator is usually based off our system time because it is<br>easy to start like this. Let's start writing some code to see how it works.<br><br># import required functions from the random module so we can use them<br><code>from random import random, sample</code><br><br># assign a random value to a variable and then print to console<br><code>value=random()</code><br><code>print(value)</code><br><br># multiply the value by 10 and then cast it so it to an integer<br><code>value=int(value*10)</code><br><code>print(value)</code><br><br># add a loop<br><code>values=[]; i=0</code><br><code>while i &lt; 20:</code><br><code>    values.append(int(random()*10)+1)</code><br><code>    i=i+1</code><br><code>print(values)</code><br><br># assign random integers<br><code>values=sample(range(1,100),20)</code><br><code>print(values)</code><br><br>The next step after you create software that does something is often packaging<br>it for distribution. You may have created a recipe app for your mother. You want<br>her to be able to use it, so you have to package it for the system she is<br>running. Most often this is Windows but we can do it for Mac and Linux as well.<br>There is a tool built for this which is "PyInstaller". It is not cross platform<br>so you built software for the platform you want. <br><br>You will need the "pip" tool installed also. This is very commonly used.<br>Use your package manager to install it.<br><br><code>sudo dnf install pip -y</code><br><br>Once that is done we are ready to install "pyinstaller". Go to the directory<br>where you work in python and install from there.<br><br><code>python -m pip install pyinstaller</code><br><br>Now type:<br><br><code>pyinstaller -h</code><br><br>This lets you see all of the options., As you can see, you can fine tune your<br>packaging a lot. For Windows, I would suggest using these options: -scriptname,<br>--onefile, --add-binary, and --noconsole. There is a lot more we could go over<br>but is probably not applicable right now. For now, these options should get you<br>started. </p><h2 id="mcetoc_1inpi09jd5" class="align-center"><span style="color: #236fa1;"><strong>Data Structures in Python</strong></span></h2><p>The two most commonly used data structures in python are the integer and float.<br>Integers deal with whole numbers while a float handles portions of an integer.<br>Either can be positive or negative. <br><br><code>a,b = 3,5</code><br><code>print(a+b)</code><br><code>print(a-b)</code><br><code>print(a*b)</code><br><code>print(a/b)</code><br><br>Booleans are also very important. They can be either true or false. You use<br>booleans to test conditions. This means testing some condition to see if it is<br>true or false.<br><br><code>a = 15 &gt; 10</code><br><code>print(a)</code><br><br><code>a = 10 &gt; 15</code><br><code>print(a)</code><br><br>For the first expression, you should get true and then false for the second<br>expression. You can also use "and", "or", and "not" for more complex<br>expressions. The expressions "a and b" evaluates to true if both "a" and "b" are<br>true. Similarly, the expression "a or b" evaluates to true if either or both "a"<br>or "b" are true. The "not" keyword evaluates to true if the expression is false.<br>Otherwise, it is true.<br><br>Here are some boolean examples.<br><br><code>a,b = True, False</code><br><code>print((a or b) == True)</code><br><br>This will evaluate to True. You will see that booleans have a priority. In<br>order, they are "not", "and", then "or".<br><br>Next, I want to talk about strings. Strings are a combination of characters.<br>Once a string is created, it cannot be changed. This is called being immutable.<br>You can make string by using single quotes, double quotes, triple quotes, string<br>method, and concatenation.<br><br><code>a = 'I am Wally'</code><br><code>a = "I am Wally"</code><br><code>a = '''I am Wally'''</code><br><br>There are several methods for strings.<br><br>This method removes beginning and ending white space if you wanted to.<br><code>a = '   I am Wally   '</code><br><code>print(a.strip())</code><br><br>This will make everything lower case.<br><code>print(a.lower())</code><br><br>This makes everything upper case.<br><code>print(a.upper())</code><br><br>Matches the first part of a string<br><code>print('I am Wally'.startswith('I'))</code><br><br>You can match any length of the string the same way.<br><code>print('I am Wally'.startswith('I am'))</code><br><br>You can check the end of the string:<br><code>print('I am Wally'.endswith('Wally'))</code><br><br>By the way, case matters so make sure you have that right.<br><br>You can check the index:<br><code>print('Wally'.find('all'))</code><br><br>You can find and replace characters:<br><code>print('Wally'.replace('W', 'S'))</code><br><br>We can check the length of a word or string:<br><code>print(len('Wally'))</code><br><code>print(len('I am Wally'))</code><br><br>Finally, we can test if a sequence of letters is in our string:<br><code>print('all' in 'Wally')</code><br><br>There are many more methods for working with strings. Check out the python user<br>manual for everything else.<br><br>Python has a keyword called "none". It means there is not a value. It does not<br>equal zero. There is no value at all. <br><br>There are several types of container data structures. Some of them are lists,<br>stacks, sets, and dictionaries.<br><br>A list is a container data type. It can store a sequence of values. You create a<br>list by using square brackets. Lists are mutable, which means they can be<br>changed. <br><br><code>list_a = [3,4,5,6,7,8,9]</code><br><code>print(len(list_a))</code><br><br>Python has an "is" keyword. It can be quite handy. It will check two variables<br>and see if they reference the same object in memory. <br><br><code>a=b=10</code><br><code>print(a is b)</code><br><br><br>Different objects have different memory addresses. So, two lists, no matter the<br>contents, will have different memory locations. <br><br>I mentioned above that lists are mutable, meaning their contents can be changed.<br>To change a list, we can append, insert, or join them together.<br><br><code>list_a = [3,4,5]</code><br><code>list_a.append(6)</code><br><code>print(list_a)</code><br><br><code>list_a = [5,7]</code><br><code>list_a.insert(1,6)</code><br><code>print(list_a)</code><br><br><code>list_a = [5,6,7]</code><br><code>list_b = [8,9,10]</code><br><code>print([5,6,7] + [8,9,10])</code><br><br><code>list_c = list_a + list_b</code><br><code>print(list_c)</code><br><br>Removing elements can be done too. Use the "remove()" method to do so. <br><br><code>list_a = [2,3,3,3,4,5]</code><br><code>list_a.remove(3)</code><br><code>print(list_a)</code><br><br>One thing to note, removing an item from a list does not work the same way as<br>inserting an element to a list. When inserting, we use an index position.<br>However, when removing an element from a list, you supply the value and the<br>first instance of that value is removed.<br><br>We can reverse a list. Use the "reverse()" method.<br><br><code>list_a = [2,3,3,3,4,5]</code><br><code>list_a.reverse()</code><br><code>print(list_a)</code><br><br>We can also sort lists using the "sort()" method.<br><br><code>list_a = [5,4,3,6,7,8]</code><br><code>list_a.sort()</code><br><code>print(list_a)</code><br><br>Indexing elements in a list is a common task. We use the "index()" method. You<br>supply the value and the method gives the index position. Indexing starts at<br>zero.<br><br><code>list_a = [3,4,5,6,7,8]</code><br><code>print(list_a.index(4))</code><br><br>A set is another type of data structure. It is an unordered collection of unique<br>values. The data types in a set must be unique. We can check the uniqueness of<br>an element by using the "hash()" method. It will give a unique code that is<br>called the hash.<br><br><code>easy = 'algebra'</code><br><code>medium = 'calculus'</code><br><code>hard = 'number_theory'</code><br><code>print(hash(easy))</code><br><code>print(hash(medium))</code><br><code>print(hash(hard))</code><br><br>We can then create a set of strings.<br><br><code>math_classes = {easy,medium,hard}</code><br><code>print(math_classes)</code><br><br>Dictionaries are another useful data structure. They store pairs of values.<br>The first is a key and then comes the value. <br><br>First, we create a dictionary called "grades". We give the key followed by a<br>colon and then the numerical value. The class names are string so must be<br>surrounded by some sort of quotes. Then we compare if the Calculus grade is less<br>than the Algebra grade. We are told it is True.<br><br><code>grades = {'Algebra' : 98, 'Calculus' : 91, 'Number_Theory' :84}</code><br><code>print(grades['Calculus'] &lt; grades['Algebra'])      </code><br>True<br><br>Next, we ask the numerical grade of the Number_Theory class. We got an 84.<br><br><code>print(grades['Number_Theory'])</code><br>84<br><br>Here, we ask if the Calculus class is included in the grades dictionary. It says<br>True.<br><br><code>print('Calculus' in grades.keys())</code><br>True<br><br>Then, we ask if we got a 98 in one of our classes. Again, it is True.<br><code>print(98 in grades.values())</code><br>True<br><br>Here, we use the "items()" method to ask what classes we got above an 80. It<br>reports all of them. You can see the useful features here.<br><br><code>for k,v in grades.items(): print(k) if v &gt; 80 else None</code><br>Algebra<br>Calculus<br>Number_Theory    </p><h2 id="mcetoc_1iqh0h55ss" class="align-center"><span style="color: #236fa1;"><strong>Decisions In Your Code</strong></span></h2><div>All programming languages I have heard of let you make decisions in your</div><div>code. Python is no exception.</div><div> </div><div>In Python we use the keywords if, else, and elif.</div><div> </div><div><code>answer = float(input("How many hours of TV do you watch a week?: \n"))</code></div><div><code>if answer &lt; 0:</code></div><div><code>    print("I don't think this is an accurate reply")</code></div><div><code>elif answer == 0:</code></div><div><code>    print("This is best")</code></div><div><code>elif answer &gt; 0 and answer &lt;= 6: </code></div><div><code>    print("That is not too bad")</code></div><div><code>elif answer &gt; 6:</code></div><div><code>    print("You might watch too much TV")</code></div><div> </div><div>I ask a how many hours of TV do you watch a week. I use the input() function</div><div>to get your answer. I assign your answer to a variable called "answer". I do</div><div>this so I can compare different inputs.</div><div> </div><div>After we have made a decision, we might want to do the action more than once.</div><div>This is where loops come in. Let us start with the "for" loop first.</div><div> </div><div><code>for i in [0,1,2,3,4,5,6,7,8,9,10]:</code></div><div><code>    print(i)</code></div><div> </div><div>Here is another example with string data. </div><div> </div><div><code>pokemon = ['Mienfoo', 'Mow Rotom', 'Scorbunny', 'Tornadus']</code></div><div><code>for p in pokemon:</code></div><div><code>    print(p, len(p))</code></div><div> </div><div>Running this code will list these Pokemon along with how many chars are in their</div><div>name. </div><div> </div><div>We can do more interesting things with numbers, though. The range() function</div><div>will be helpful in doing this. We combine it in the for() function.</div><div> </div><div><code>for i in range(20):</code></div><div><code>    print (i)</code></div><div> </div><div>Here we print the first 20 numbers starting at zero.</div><div> </div><div>Now, to continue with decisions and controlling how a program works, we will talk about the "while" statement next.</div><div>The "while" loop lets you run a block of code as long as the given condition remains true. This is ideal when you do not know how many times your loop needs to run. It works by evaluating a condition at the beginning of your block of code. </div><div> </div><div><code>digit = 0</code></div><div><code>while digit &lt; 11:</code></div><div><code>    print(digit)</code></div><div><code>    digit = digit + 1</code></div><div> </div><div>We initialize digit to zero. We set the condition for as long as digit is less than 11, we then print the digit variable. Lastly, we increment the digit variable by one for each loop iteration. </div><div> </div><div><code>digit = 0</code></div><div><code>while digit != 20:</code></div><div><code>    print(digit)</code></div><div><code>    digit = digit + 1</code></div><div> </div><div>This is another way the "while" loop can be used. We initialize our digit variable then give it an ending condition. As long the digit variable does not equal 20, we want to print digit and then increment it by one each round.</div><div> </div><div><code>digit = 30</code></div><div><code>while digit != 19:</code></div><div><code>    print(digit)</code></div><div><code>    digit = digit - 1</code></div><div> </div><div>We can also use a "while" loop to count down too. The above code should make sense by now as to what it does.</div><div> </div><div>The "while" loop has some additional features that make it very useful. I am</div><div>talking about the "break" and "continue" statements. The "break" statement can</div><div>immediately terminate a loop. The "continue" statement ends the current iteration of the loop. These both make the "while" loop very flexible.</div><div> </div><div><code>digit = -30</code></div><div><code>while digit != 0:</code></div><div><code>    print(digit)</code></div><div><code>    if digit == -6:</code></div><div><code>        break</code></div><div><code>    digit = digit + 2</code></div><div> </div><div>This is an example of the "break" statement. At first glance you expect the loop to print -30 to -2. However, because the break statement says to end the loop when digit equals -6, this modifies the behavior in the code block.</div><div> </div><div><code>digit = -30</code></div><div><code>while digit != 0:</code></div><div><code>    digit = digit + 2</code></div><div><code>    if digit == -6:</code></div><div><code>        continue</code></div><div><code>    print(digit)</code></div><div><code>print("Loop skipped -6 because of continue statement")</code></div><div> </div><div>In this code example, we are using the "continue" statement. It is very similar to the "break" statement from earlier. In this example, if our variable is equal to -6, we ask it to be skipped from printing and continue on after it.</div><div> </div><div>There is also the "else" keyword. It is optional but can be very useful.</div><div> </div><div><code>While some-condition:</code></div><div><code>code</code></div><div><code>else:</code></div><div><code>other-code</code></div><div> </div><div>So, the code under the "else" keyword only runs when the condition in first part</div><div>of body becomes false. Let's try an example to see it in action.</div><div> </div><div><code>digit = 0</code></div><div><code>while digit != 10:</code></div><div><code>    print(digit)</code></div><div><code>    digit = digit + 1</code></div><div><code>else: </code></div><div><code>    print(digit + 100)</code></div><div> </div><div>Our code runs normally then we add 100 to make it nice and noticeable. Lots of</div><div>things can be tested and run this way. It is very useful.</div><p>Functions are also useful data structures. You can create small pieces of code and use them over and over. A function is started with the "def" keyword. You will then have some arguments, and these customize how the function body is run. You then have a "return" keyword to end the function and give a result if that is the design of your function. </p><p>Lambdas are another data stucture that are used a lot. You use the keyword "lambda" to define one of these functions. They are anonymous functions, not defined in the namespace, without names, and intended for single use.</p><p><code>lambda arguments : return expression</code></p><p>It can have multiple arguments. After the colon, you have the return expression that can be any expression or another function. </p><h2 id="mcetoc_1j14ip0f116s"><strong>List Comprehension in Python</strong></h2><div> </div><div>List comprehension is a way of creating lists in python. It is a smart way of</div><div>creating lists and I know you will like it. Here is an example:</div><div> </div><div><code>[x*3 for x in range(10)]</code></div><div><code>[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</code></div><div> </div><div>The variable "x" start at zero and goes up by 1 each time. Each x is multiplied</div><div>by 3. The range function gives you 10 values. The expression can be more complex</div><div>if you need it to. It can be a function, do calculations, and also call other</div><div>functions. </div><div> </div><div><code>print([x for x in range(10))]</code></div><div><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></div><div> </div><div>In this next example we change it up a little bit. Hopefully you can see how</div><div>this works and why. It is really neat. The variables "x" becomes the values</div><div>0-4(because range(5)) and them multiples each value by 4 and prints it.</div><div> </div><div><code>print([x*4 for x in range(5)])</code></div><div><code>[0, 4, 8, 12, 16]</code></div><div> </div><div>We can make it more complex and do more at once.</div><div><code>print([(a,b) for a in range(5) for b in range(5)])</code></div><div><code>[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]</code></div><div> </div><div>The variable "a" iterates over each value of "range(5)". The variable "b" does</div><div>the same thing. Each combination is then printed.</div><div> </div><div>Here is another expression where we square a number.</div><div><code>print([x**2 for x in range(30) if x % 2 &gt; 0])</code></div><div><code>[1, 9, 25, 49, 81, 121, 169, 225, 289, 361, 441, 529, 625, 729, 841]</code></div><div> </div><div>The variable "x" iterated over each value returned by the "range()" function.</div><div>The variable "x" is then squared for each value. </div><div> </div><div>The next example analyzes text. We will just do something simple to show one of</div><div>the possibilities. We put everything in triple quotes. This text is from a</div><div>Pokemon card. It looks at all the words and gets rid of anything 3 chars or</div><div>less. Then we print that to the screen.</div><div> </div><div><code>text = '''</code></div><div><code>Discard the top card of your deck, and if that card is a Pokemon that does not have a rule box, choose 1 of its attacks and use it as this attack.</code></div><div><code>'''</code></div><div><code>w = [[x for x in line.split() if len(x) &gt; 3] for line in text.split('\n')]</code></div><div><code>print(w)</code></div><div><code>[[], ['Discard', 'card', 'your', 'deck,', 'that', 'card', 'Pokemon', 'that', 'does', 'have', 'rule', 'box,', 'choose', 'attacks', 'this', 'attack.'], []]</code></div><div> </div><div>Reading a file is another common task. There are several ways to do so. This is</div><div>just one way. I will leave it to you to decide which is the best way. In this</div><div>example, we read all the lines in a file, get rid of white space characters, and</div><div>put the result in a list. Adjust your filename to whatever file you are using.</div><div>This file must be in system path, same directory, or you must state the explicit</div><div>path. I did this this in IDLE from my Linux system.</div><div> </div><div><code>print([line.strip() for line in open("slowking.py")])</code></div><div> </div><div>In this next example, we analyze a list of strings. It could be something we</div><div>type in or reading from a text file, like we did earlier. We are looking for a</div><div>certain sub-string called "Pokemon" from the list of string we provide. We have</div><div>a Boolean indicate whether each string that is analyzed contains the sub-string</div><div>we are looking for.</div><div> </div><div><code>slowking = ['Discard the top card of your deck.',</code></div><div><code>            'If that card is a Pokemon.',</code></div><div><code>            'Choose one of its attacks and use it.']</code></div><div><code>pokemon = map(lambda a: (True, a) if 'Pokemon' in a else (False, a), slowking)</code></div><div><code>print(list(pokemon))</code></div><div> </div><div><code>[(False, 'Discard the top card of your deck.'), (True, 'If that card is a Pokemon.'), (False, 'Choose one of its attacks and use it.')]</code></div><div> </div><div>Our next topic is slicing. This is important when analyzing string data. When we</div><div>want to search for specific text or a string, slicing will get that data for us.</div><div>Slicing gets you part of a string. It looks like this:</div><div> </div><div><code>x[start:stop:step]</code></div><div> </div><div>Start and stop should be obvious. The step part is optional. If you do not</div><div>include it then the default step is 1. Remember the first element is index 0. If</div><div>you do not include the stop or stop position then python goes from the start to</div><div>the end. </div><div> </div><div><code>s = 'seek inspiration'</code></div><div><code>print(s[0:4])</code></div><div><code>seek</code></div><div> </div><div><code>print(s[3:])</code></div><div><code>k inspiration</code></div><div> </div><div><code>print(s[:5])</code></div><div><code>seek </code></div><div> </div><div><code>print(s[5:])</code></div><div><code>inspiration</code></div><div> </div><div><code>print(s[:100])</code></div><div><code>seek inspiration</code></div><div> </div><div>In this next example we are trying to find a specific sequence of</div><div>characters. </div><div> </div><div><code>slowking ='''Discard the top card of your deck. If that card is a pokemon that does not have a rule box, choose one of </code></div><div><code>its attack as this attack. Pokemon EX have rule boxes. Super psybolt is 120.'''</code></div><div><code>find = lambda x, q: x[x.find(q)-10:x.find(q)+10] if q in x else -1</code></div><div><code>print(find(slowking,'Pokemon'))</code></div><div> </div><div>Given a large set of numbers, we might want to break it down some to make it</div><div>easier to work with. We can attempt this by using a step 2 when we slice to</div><div>cut it in half. Then we want to print what we have. Let us consider some batting</div><div>averages of the top players in the current 2025 season.</div><div> </div><div><code>ba = [[.384, .369, .338, .329, .328, .322],</code></div><div><code>      [.318, .317, .316, .312, .310, .310],</code></div><div><code>      [.309, .304, .304, .302, .300, .299],</code></div><div><code>      [.299, .299, .299, .297, .296, .296]]</code></div><div><code>half = [line[::2] for line in ba]</code></div><div><code>print(half)</code></div><div><code>[[0.384, 0.338, 0.328], [0.318, 0.316, 0.31], [0.309, 0.304, 0.3], [0.299, 0.299, 0.296]]</code></div><div> </div><div>Sometimes you are given a list of numbers and you need to graph them. There are</div><div>many ways to do this but the first you should learn is the matplotlib library.</div><div>First, we need to install it.</div><div> </div><div><code>pip install matplotlib</code></div><div> </div><div>Now, let us work with some data. You can copy/paste or use some other method.</div><div>This is just an example so I will leave that part to you. Later on, I will do a</div><div>dedicated section on matplotlib. Here is how you work with it on a basic level.</div><div> </div><div><code>import matplotlib.pyplot as plt</code></div><div><code>integers = [1,2,3,2,4,5,3,6,7,4,7,8,5,8,9,6,2,1,3,3,2,4,5,4,3,7,6,6]</code></div><div><code>plt.plot(integers)</code></div><div><code>plt.show()</code></div><div> </div><div>First, we import the matplotlib library. We then create an integer variable.</div><div>Last, we load the variable and show the plot.</div><div> </div><div>The last thing we will do is learn how to combine lists. We do this by using the</div><div>'zip()' function.</div><div> </div><div><code>list1 = [1,2,3,4,5,6,7,8,9,10]</code></div><div><code>list2 = [11,12,13,14,15,16,17,18,19,20]</code></div><div><code>combined = list(zip(list1, list2))</code></div><div><code>print(combined)</code></div><div> </div><div><code>[(1,11), (2,12), (3,13), (4,14), (5,15), (6,16), (7,17), (8,18), (9,19), (10,20)]</code></div><p> </p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on July 26, 2025</p><ul class="post__tag"><li><a href="https://aindien.com/python/">Python</a></li></ul><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Faindien.com%2Fpython-basics.html" class="js-share facebook" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/share?url=https%3A%2F%2Faindien.com%2Fpython-basics.html&amp;via=_Aindien&amp;text=Python%20Explained" class="js-share twitter" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span></a></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://aindien.com/authors/jason-moore/" class="invert" rel="author">Jason Moore</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://aindien.com/economics-essentials.html" class="invert post__nav-link" rel="prev"><span>Previous</span> Economics Explained</a></div><div class="post__nav-next"><a href="https://aindien.com/cloud-fundamentals.html" class="invert post__nav-link" rel="next"><span>Next</span> Cloud Computing Explained </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2023-12-31T01:18" class="feed__date">December 31, 2023</time></div><h3 class="h1"><a href="https://aindien.com/getting-started-with-git.html" class="invert">Git Explained</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2023-12-26T23:12" class="feed__date">December 26, 2023</time></div><h3 class="h1"><a href="https://aindien.com/cloud-fundamentals.html" class="invert">Cloud Computing Explained</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2022-10-13T17:44" class="feed__date">October 13, 2022</time></div><h3 class="h1"><a href="https://aindien.com/economics-essentials.html" class="invert">Economics Explained</a></h3></article></div></div><div class="banner banner--after-post"><div class="wrapper"><link href="//cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel="stylesheet" type="text/css"><style type="text/css">#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
	/* Add your own Mailchimp form style overrides in your site stylesheet or in this style block.
	   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */</style><div id="mc_embed_signup"><form action="https://aindien.us11.list-manage.com/subscribe/post?u=5aefa50c3a5900492b165a83f&amp;id=1c348b805a" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate><div id="mc_embed_signup_scroll"><h2>Subscribe</h2><div class="indicates-required"><span class="asterisk">*</span> indicates required</div><div class="mc-field-group"><label for="mce-EMAIL">Email Address <span class="asterisk">*</span></label> <input type="email" name="EMAIL" class="required email" id="mce-EMAIL"></div><div class="mc-field-group"><label for="mce-FNAME">First Name</label> <input type="text" name="FNAME" id="mce-FNAME"></div><div class="mc-field-group"><label for="mce-LNAME">Last Name</label> <input type="text" name="LNAME" id="mce-LNAME"></div><div id="mce-responses" class="clear"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5aefa50c3a5900492b165a83f_1c348b805a" tabindex="-1"></div><div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div></div></form></div><script type="text/javascript" src="//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js"></script><script type="text/javascript">(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';}(jQuery));var $mcj = jQuery.noConflict(true);</script></div></div></main><footer class="footer"><div class="footer__copyright"><p>Jason Moore 2022</p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://aindien.com/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>