<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux Explained - Jason&#x27;s Computing Guides</title><meta name="description" content="Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://aindien.com/linux-essentials-.html"><link rel="alternate" type="application/atom+xml" href="https://aindien.com/feed.xml"><link rel="alternate" type="application/json" href="https://aindien.com/feed.json"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://aindien.com/assets/css/style.css?v=e0d2512160dcefa5eef886706cef7856"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://aindien.com/linux-essentials-.html"},"headline":"Linux Explained","datePublished":"2021-07-05T22:23","dateModified":"2024-08-14T14:28","image":{"@type":"ImageObject","url":"https://aindien.com/media/posts/53/linux-0.jpg","height":3000,"width":3000},"description":"Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you.","author":{"@type":"Person","name":"Jason Moore"},"publisher":{"@type":"Organization","name":"Jason Moore"}}</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-393JFJ482L"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-393JFJ482L');</script><script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/5aefa50c3a5900492b165a83f/93dcd5a76da18d3becc7e677f.js");</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://aindien.com/">Jason&#x27;s Computing Guides</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://mailchi.mp/70ab982b2619/computing" target="_self">Home</a></li><li><a href="https://aindien.com/python-basics.html" target="_self">Python Basics</a></li><li><a href="https://aindien.com/getting-started-with-git.html" target="_self">Git Basics</a></li><li><a href="https://aindien.com/c-essentials.html" target="_self">C++ Basics</a></li><li class="active"><a href="https://aindien.com/linux-essentials-.html" target="_self">Linux Basics</a></li><li><a href="https://aindien.com/networking-essentials.html" target="_self">Networking Basics</a></li><li><a href="https://aindien.com/r-essentials.html" target="_self">R Programming Basics</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://aindien.com/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://aindien.com/media/posts/53/linux-0.jpg" srcset="https://aindien.com/media/posts/53/responsive/linux-0-xs.jpg 300w, https://aindien.com/media/posts/53/responsive/linux-0-sm.jpg 480w, https://aindien.com/media/posts/53/responsive/linux-0-md.jpg 768w, https://aindien.com/media/posts/53/responsive/linux-0-lg.jpg 1024w, https://aindien.com/media/posts/53/responsive/linux-0-xl.jpg 1360w, https://aindien.com/media/posts/53/responsive/linux-0-2xl.jpg 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="3000" width="3000" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2021-07-05T22:23">July 5, 2021</time></div><h1>Linux Explained</h1><div class="post__meta post__meta--author"><a href="https://aindien.com/authors/jason-moore/" class="feed__author invert">Jason Moore</a></div></div></header></div><div class="wrapper post__entry"><p>Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you.</p><p><a target="_blank" href="https://amzn.to/3y97zia" rel="noopener">Samsung Store on Amazon! If you buy something, I get a small commission and that makes it easier to keep on writing. Thank you in advance if you buy something.</a></p><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1f9st1def88s">Introduction To Linux</a></li><li><a href="#mcetoc_1f9sus8jj8cu">Things To Know Before You Install Linux</a></li><li><a href="#mcetoc_1hu4eo8ea3">Exploring Your Linux System</a></li><li><a href="#mcetoc_1hipjg8uvng">Using The Shell In Linux </a></li><li><a href="#mcetoc_1f9sus8jj8cv">Doing More With The Shell</a></li><li><a href="#mcetoc_1f9v9jt1i957">Filtering Text In Linux</a></li><li><a href="#mcetoc_1i2s6qiqc4">Working With Files</a></li><li><a href="#mcetoc_1h4km0vek1o">Rsync</a></li></ul></div><h2 id="mcetoc_1f9st1def88s" class="align-center"><span style="color: #236fa1;"><strong>Introduction To Linux</strong></span></h2><p>Linux is a direct descendant of the Unix operating system. Unix was created by government researchers who needed some custom tools. It spread to universities and students popularized it greatly.</p><p>Berkeley also played an important part because they modified it extensively. This became known as BSD, the Berkeley Software Distribution. At the same time there was also Unix System V, which came from the version maintained by Bell Labs.</p><p id="mcetoc_1eim2v6td1" class="align-left"><span style="color: #169179;"><strong>Linus Torvalds</strong></span></p><p>Torvalds was a Finnish student in the early 90s. He was working on the core of that would be the Linux kernel as we know it. After it was finished, he combined it with the GNU operating system for the applications.</p><p>Linux the name comes from the combination of Linus and Unix.</p><p id="mcetoc_1eim2vdh32" class="align-left"><span style="color: #169179;"><strong>Distributions</strong></span></p><p>Neither a kernel nor applications make a complete operating system. So putting them together was a must. It just so happened that different parties each the separate part ready. Others have since as well.</p><p>The combination of a kernel and related packages that run on that system are known as a distribution. There are hundreds of distributions today.</p><p>They include development systems, word processing, spreadsheet software, music players, and many other nice utilities. Fedora, Opensuse, and Ubuntu are great ones to get started with.</p><p id="mcetoc_1eim2vkp23" class="align-left"><span style="color: #169179;"><strong>Software</strong></span></p><p>There are tons of nice packages available for Linux systems today. Most are free, but you can buy some also that will include extras like nice support built in. Graphics tools, web servers, and networking utilities are some of the most popular packages.</p><p id="mcetoc_1eim2vqpr4" class="align-left"><span style="color: #169179;"><strong>Supported Platforms</strong></span></p><p>Almost everything today will run Linux. Intel, Mac, IBM, and Arm based computers all run Linux and does so very well. In fact, Linux is only getting more popular.</p><p id="mcetoc_1eim300dg5" class="align-left"><span style="color: #169179;"><strong>Portability</strong></span></p><p>Originally, Unix messed this part up because vendors made versions all for themselves. So the market was very fragmented. However, Linux was written most in the &lt;C&gt; language.</p><p>This allowed it to be portable between other systems. Doing so allowed it to spread much quicker than Unix ever could.</p><p>Now, Linux is used everywhere and for any type of system.</p><p id="mcetoc_1eim3081a6" class="align-left"><span style="color: #169179;"><strong>The Kernel</strong></span></p><p>The kernel’s job is to distribute the computer’s resources. The resources of a computer are things like cpu and memory. Peripherals need access to these items as well, so the kernel will make sure each one gets what it needs.</p><p>Software will request resources through system calls. The kernel then gives the software what it needs.</p><p id="mcetoc_1eim30dqk7" class="align-left"><span style="color: #169179;"><strong>Multiuser Support</strong></span></p><p>A Linux system is designed to have many users on one computer. This gives them each their own little area of the operating system and storage. This makes cost a lot less. In fact, this was often done to save money.</p><p>An organization could have one nice machine and dumb terminals to access located anywhere in the building. It is probably still a good idea if you think about it. Another advantage to this is that it makes the machine more cost efficient.</p><p>No one can use all of a machine’s resources constantly. So if one person is using it then most of the resources are going unused. This goes hand in hand with the task system.</p><p>Since Linux is designed to handle multiple users, it can also handle many concurrent tasks at the same time too. This means that each user can run many processes at the same time.</p><p id="mcetoc_1eim30lce8" class="align-left"><span style="color: #169179;"><strong>Bash And Other Shells</strong></span></p><p>A shell is a command interpreter. This is just an interface to the core of the operating system. It allows you to run commands and have them act instantly. It is a very powerful concept.</p><p>Bash is the most popular shell, but there are many other ones. Some are older, but there are newer ones too. Each user on a machine can use his own shell if that is his preference. This allows for nice customization.</p><p id="mcetoc_1eim30qqj9" class="align-left"><span style="color: #169179;"><strong>Desktops</strong></span></p><p>Originally, computers were mostly used with shells. This involved users issuing commands as needed on a machine. They could do calculations, manage a server or use a text editor.</p><p>Eventually, however, a GUI was created, and these were the first desktops. When I say desktop, I am referring to the graphical system that lets you do the same tasks as a shell.</p><p>The Gnome, Cinnamon, and KDE desktop environments are some of the most popular today. They each have a very different style, but they are also fun to learn. They are fun because each has its own advantages.</p><p>Today, you can even get desktops with certain spins built in to them. A spin means they come with certain software packages that do a certain role.</p><p>For example, I could download an Astronomy spin that would include many types of Astronomy software. That is a really cool feature, by the way.</p><p id="mcetoc_1eim314h5a" class="align-left"><span style="color: #169179;"><strong>Utilities</strong></span></p><p>Linux comes with many types of useful programs called utilities. These all do some unique task and do it very well. These are the basis behind the commands that you use in a terminal window.</p><p>I can check the speed of my system, disk space, free memory, cpu usage by process and the list could go on and on.</p><p id="mcetoc_1eim31c4rb" class="align-left"><span style="color: #169179;"><strong>Application Development</strong></span></p><p>This is one of my favorite features. Almost every distribution has program development built in to its core. Compilers and interpreters are there. Several text editors are there too. Support for several languages comes right out of the box.</p><p>You can start with C++ or C immediately after an install. In one distribution I have, a very nice Python pdf book is even included along with its support of course. Many times an IDE is also included if you prefer that kind of workflow.</p><p>Whole books have been written about the history and usage of Linux. It is very rich in history and you can spend a lifetime learning useful things that you can with these Linux essentials.</p><p>Did I mention it is free and has the best computing community in the world? While it came from Unix, it has far surpassed its digital parent. There is a distribution for everyone.</p><p>It does everything and more that a Windows and Mac computer can do. This is because 99% of the software is free and easily installed.</p><h2 id="mcetoc_1f9sus8jj8cu" class="align-center"><span style="color: #236fa1;"><strong>Things To Know Before You Install Linux</strong></span></h2><p>Installing Linux is not difficult, but there are some details you should be aware of. You don't want to lose data. </p><p id="mcetoc_1ent5irsm0" class="align-left" data-pm-slice="0 0 []"><span style="color: #169179;">Formatting The Hard Drive</span></p><p>A new hard drive will have to be specially prepared by its manufacturer. They then send it to a retail store or reseller. Once in a consumer’s hand, it can be partitioned. A partition is a logical section on the drive.</p><p>It will have a device name to make it easy to refer to. With certain utilities, you can resize and change most partitions. When you partition a drive, you are creating a partition table and a filesystem. The table contains all the information on the partitions.</p><p>The filesystem is how data is read. It shows where the data is stored on the drive. It does this by mappings called inodes. There are many kinds of filesystems.</p><p>They each have their advantages. Most installation utilities will do these steps automatically if you prefer.</p><p>While formatting is not something you do every day, it is useful to know that it happens. You lose whatever data is on the drive when you format it. If it is a new system, then it is not a concern.</p><p>However, if this is an older drive then you will want to back up your data. Losing good data is not good.</p><p id="mcetoc_1ent5j76f1" class="align-left"><span style="color: #169179;">Setting Up Directories</span></p><p>You have probably heard that everything in Linux is a file. This is really pretty true. Every file in a system has a unique identifier. These are path names. The entire path name is the identifier.</p><p>So, /home/music has a separate identifier than /home/documents. Notice also that Linux systems use the slash that is closest to the right-shift button.</p><p>I admit this may be out of the realm of first users. Setting your own directories in a filesystem is for advanced users. It is possible that you need to do it, so I am mentioning it for this. For instance, you could be asked to by your boss.</p><p id="mcetoc_1ent5je8t2" class="align-left"><span style="color: #169179;">Mount Points</span></p><p>A filesystem needs to be mounted. It will have a specific mount point. A mount point is therefore the directory where the filesystem is placed. Most installation programs will do this automatically.</p><p>However, it is good to know that this takes place in the background. You might want to customize this process in the future. There can be multiple filesystems within a system. They can be different ones and hold different files.</p><p>There is a file that holds the filesystem information and it is called the /etc/fstab file. This is configurable if you want to adjust settings one day.</p><p id="mcetoc_1ent5jko33" class="align-left"><span style="color: #169179;">Making Partitions</span></p><p>Every specific distribution will have its own installation program. These programs will usually take care of steps like partitioning. However, it is important to know that you can usually do it yourself.</p><p>Some people have specific needs for what they want their setup to look like after they finish it. To do this correctly, they will have to manually setup their disk. You can decide what partitions that you want and their sizes.</p><p>This can be very important. If you think you're going to need a large &lt;swap&gt; partition, then you can set this manually. Partition examples include /boot, /root, /swap, and /home.</p><p>There used to be good reasons to set up several other partitions on a Linux system. A lot of those reasons revolved around disk fragmentation. That is not too common anymore, as most new disks are SSD or NVME now.</p><p>These types of disks do not fragment. If you reinstall often, then it could be useful to separate your partitions so you do not have to recreate programs or data as much.</p><p>A /var partition could be useful. If your data changes all the time, then you might want to do this. The /log directory is often in here too. Standardizing where log files are kept is a good idea for everyone.</p><p>They are always the keys to what is wrong with your system, so it is important to know where they are quickly. Another popular partition is /opt. This is where installation packages are on your system.</p><p>It is handy to know where to find certain types of files like I stated above. Packages are no exception. If you need to distribute to other systems on your network, then it is easier if they are all in one place.</p><p id="mcetoc_1ent5jquo4" class="align-left"><span style="color: #169179;">RAID</span></p><p>A redundant array of independent disks system is definitely something to consider. You will want to consider this if this is a server or any other machine with valuable data stored on the disks.</p><p>However, if you store your data on a remote server or a local device, then the extra cost may not be justified.</p><p>A RAID system uses two or more disks, partitions, or some combination of these two. It is a way to protect your data or add performance to your system. There are several RAID modes, and each has its advantages and disadvantages.</p><p>RAID can be hardware or software. Hardware RAID is usually in the form of addon cards within your system. They can contain processing power and often some cache memory. Software RAID is built in to Linux systems through certain utilities and is usually the better choice.</p><p>A long time ago hardware RAID was more popular because system hardware had progressed little. In current times with SSD’s, high-powered processors, and systems with 16-128 GB of ram, software RAID is the way to go.</p><p>The main reason administrators use RAID is to help protect their important data from hardware failure. It should not be the only tactic you use, just like you should not only have one backup of your data.</p><p>Software RAID is what I use when I deem it necessary. It also costs nothing because the Linux kernel controls it. It is also more powerful and gives greater flexibility to your system. The downside is that it takes more skill to set up.</p><p>Understand what mode you desire, how to use the utilities to implement it, and know how to query your system to find out the kinds of devices it has internally.</p><p id="mcetoc_1ent5k1565" class="align-left"><span style="color: #169179;">Logical Volume Manager</span></p><p>LVM is a great utility. It gives you the chance to implement it when you first do any installs. I highly recommend doing so. It gives your system great flexibility. So what does it do? LVM allows you to control your logical volumes at a moment’s notice.</p><p>You can add more space at any time. A logical volume is like a partition, except it is adjustable as you need it. Partitions are not and are pretty much set in stone.</p><p>This works by taking any physical part of your drives, which include disks and partitions and grouping them into a storage pool. With these individual parts in a storage pool, you use the LVM to group them how you need them to appear to your system.</p><p>You can also change these groupings and their allocated space at any time.</p><h2 id="mcetoc_1hu4eo8ea3" class="align-center"><span style="color: #236fa1;"><strong>Exploring Your Linux System</strong></span></h2><p><span style="color: #169179;"><strong>Ls Command</strong></span></p><p><span style="font-weight: 400;">The ls command is one of the most used commands. It lists directory contents. It will quickly become second nature. We can see directory contents and other information about files. It is used like this:</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">We can specify a directory:</span></p><p><code><span style="font-weight: 400;">Ls /Music</span></code></p><p><span style="font-weight: 400;">We can see more detail like this:</span></p><p><code><span style="font-weight: 400;">Ls -l /Music</span></code></p><p> </p><p><span style="font-weight: 400;">As with almost all commands, there are options and arguments you can use with them. These options and arguments modify how the commands work. An option is usually a dash followed by a single character. These are called short options. There are also long options that do the same thing in most cases. A long option is two dashes followed by a word. You can even use more than one option at a time. So we can do things like:</span></p><p><code><span style="font-weight: 400;">Ls -a</span></code></p><p><code><span style="font-weight: 400;">Ls -h</span></code></p><p><code><span style="font-weight: 400;">Ls -ah</span></code></p><p><span style="font-weight: 400;">Options in Linux are case sensitive. It can be easy to forget this so keep it in mind. </span></p><p> </p><p><span style="color: #169179;"><strong>CD Command</strong></span></p><p><span style="font-weight: 400;">The cd command lets you move around your system. It changes directories.</span></p><p><span style="font-weight: 400;">Once we look at our current location with the ls command, we can change to a directory that is listed there if we want to.</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">I am still in my home directory but I see a Music folder. What’s in there I wonder? Let us see.</span></p><p><code><span style="font-weight: 400;">Cd Music</span></code></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">Well, there isn’t anything in there yet. I need to fix that soon. I like music like everyone else. Hopefully you can see how this is helpful. Cd also has other things it can do like move backward one file level.</span></p><p><code><span style="font-weight: 400;">Cd ..</span></code></p><p><code><span style="font-weight: 400;">ls</span></code><span style="font-weight: 400;"><br></span><span style="font-weight: 400;">Now, you see that you are back where you started. That is the basic usage for the cd command. It is enough for now.</span></p><p> </p><p><span style="color: #169179;"><strong>File Command</strong></span></p><p><span style="font-weight: 400;">The file command gives you the file type of the file you are looking at. </span></p><p><code><span style="font-weight: 400;">File .bashrc</span></code></p><p><span style="font-weight: 400;">This shows you it is a text file. Since there are many types of files it is not always obvious what kind of file you are seeing. </span></p><p> </p><p><span style="color: #169179;"><strong>Less Command</strong></span></p><p><span style="font-weight: 400;">The less command lets us look at text files and see a smaller portion. This is helpful when the file in question is many pages long. We look at text files so we can modify them. An example would be a file that controls settings. Another reason is that program code is text and that is how we make programs. We can use it like this:</span></p><p><code><span style="font-weight: 400;">Less .bashrc</span></code></p><p><span style="font-weight: 400;">We can now scroll up and down. I do not recommend changing anything yet, but you need to know how to examine a file. Files are how settings are done in Linux so it is important to know about. </span></p><p><span style="font-weight: 400;">Type q to exit the less program</span></p><p> </p><p><span style="color: #169179;"><strong>Symbolic Links</strong></span></p><p><span style="font-weight: 400;">While you are exploring your system, you might see something that looks pretty weird after you use ls to view a directory’s contents. This is called a symbolic link. In fact, you can identify these symbolic links because they start with an &lt;l&gt;. This special file is also called a soft link. A soft link is like a pointer to a real file. It is useful because a program can change the pointer instead of countless versions of the file itself. This lets your system be much more efficient. </span></p><h2 id="mcetoc_1hipjg8uvng" class="align-center"><span style="color: #236fa1;"><strong>Using The Shell In Linux</strong><span style="font-weight: 400;"> </span></span></h2><p><span style="font-weight: 400;">When people talk about using the command line, they are really referring to the Shell. This is accessed by your terminal window which you run commands in. The shell itself is just a program that works behind the scenes. Almost all distributions of Linux have one included with their version. There are several different versions of Shells also. Some of these are Bash, Zsh, and Fish. </span></p><p> </p><p><span style="font-weight: 400;">There are also pieces of software called terminal emulators. These small programs help you talk to the Shell. This is something like Konsole or Terminal depending on your distribution. </span></p><p> </p><p><span style="font-weight: 400;">Your Shell prompt is where you type in commands. If the last character is a ‘$’ then you are a regular user. If the last character is a ‘#’ you are running as a root user which gives you superpowers in the Linux world. </span></p><p> </p><p><span style="font-weight: 400;">The Shell will give you access to your command history. You see the command history by using the up arrow on your keyboard. Keep pressing the up arrow to see more of your commands you have used. This is useful because you can just use the up arrow to redo commands instead of retyping a long command. Most distributions remember around a thousand of your last commands. </span></p><p> </p><p><span style="font-weight: 400;">Let’s start using some basic commands. Type the command and then hit enter:</span></p><p><code><span style="font-weight: 400;">Date</span></code></p><p><span style="font-weight: 400;">You will see the current time and date pop up.</span></p><p><span style="font-weight: 400;">Now, try the ‘cal’ command:</span></p><p><code><span style="font-weight: 400;">Cal</span></code></p><p><span style="font-weight: 400;">You should get a view of the current month. I like to use the ‘cal’ command as I am always forgetting what day it is and it is quicker to use than most other calendar systems. </span></p><p><span style="font-weight: 400;">Another useful command to use is ‘df’ which tells you how much free space is on your system.</span></p><p><code><span style="font-weight: 400;">Df</span></code></p><p><span style="font-weight: 400;">There is a useful parameter you can run with this command and I recommend using it:</span></p><p><code><span style="font-weight: 400;">Df -h</span></code></p><p><span style="font-weight: 400;">This makes the output easier to read. I will get into parameters and options later on.</span></p><p><span style="font-weight: 400;">The next command to learn is the ‘free’ command. We will also add the ‘-h’ parameter after it:</span></p><p><code><span style="font-weight: 400;">Free -h</span></code></p><p><span style="font-weight: 400;">This output tells you about the memory on your system.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Navigating Your File System</strong></span></p><p><span style="font-weight: 400;">The Linux file system looks very different from a Windows file system. It is mainly because everything is named differently. The file system is organized by directories. These directories can contain either files or more directories. In Windows, they are called folders. I will use directories from here on out though. </span></p><p> </p><p><span style="font-weight: 400;">The first directory in a Linux system is called the ‘root’ directory. It contains everything else on the local system. Linux has a single file system for everything in or attached to that computer. It is important to remember this when navigating. An external storage device is mounted or attached to somewhere in the file system. </span></p><p> </p><p><span style="font-weight: 400;">To see where you are at any time, use the ‘pwd’ command. This stands for present working directory.</span></p><p><code><span style="font-weight: 400;">Pwd</span></code></p><p><span style="font-weight: 400;">It gives a simple one line of output. Mine says:</span></p><p><code><span style="font-weight: 400;">/home/jason</span></code></p><p><span style="font-weight: 400;">Whenever we start our computer session in Linux, we start at ‘/home/username’. My username is Jason of course. We can change that later if we want to but that is not important right now. </span></p><p> </p><p><span style="font-weight: 400;">To see what files are in a directory, we use the ‘ls’ command.</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">This command can be used to see the contents of any directory if you know the path. We already know one because we are part of it. It is our ‘home’ directory.</span></p><p><code><span style="font-weight: 400;">Ls /home</span></code></p><p><span style="font-weight: 400;">You can also see the contents of the whole computer by looking at the ‘root’. To see the ‘root’, we use ‘/’. So try this:</span></p><p><code><span style="font-weight: 400;">Ls /</span></code></p><p><span style="font-weight: 400;">This shows you everything at the ‘root’ level. See the ‘/home’ directory? Your user directory is located within that ‘/home’ directory. Hopefully you can see how your system is organized now. </span></p><p> </p><p><span style="font-weight: 400;">This brings us to moving directories. We move to a different directory for various reasons. Often, we just want to work from that directory. While we can see what is there by using the path or make a file and put it there, it is easier to just be in that directory. To get to that directory we use the ‘cd’ command:</span></p><p><code><span style="font-weight: 400;">Cd /home/jason</span></code></p><p><span style="font-weight: 400;">This is called using an absolute path because we started at the ‘root’ directory denoted by the first ‘/’ and then listed the directory structure until we got to our directory under ‘/home’.  We can also use relative pathnames. It is called this because it is relative to our present directory. So:</span></p><p><code><span style="font-weight: 400;">Cd ..</span></code></p><p><span style="font-weight: 400;">Will move us up one directory from our present working directory. </span></p><p><span style="font-weight: 400;">‘Cd’ is a very helpful command. It allows for fast movement if you use a few tricks.</span></p><p><span style="font-weight: 400;">To instantly go to your ‘/home’ directory:</span></p><p><code><span style="font-weight: 400;">Cd</span></code></p><p><span style="font-weight: 400;">To change the working directory to the previous directory:</span></p><p><code><span style="font-weight: 400;">Cd -</span></code></p><h2 id="mcetoc_1f9sus8jj8cv" class="align-center"><span style="color: #236fa1;"><strong>Doing More With The Shell</strong></span></h2><p>Using a shell gives you great satisfaction. It does have a learning curve but, it is well worth it. I am assuming you have no prior knowledge. Taking it slow and using it every day is the best way.</p><p id="mcetoc_1f9sus8jj8d0" class="align-left"><span style="color: #169179;"><strong>Files and Directories</strong></span></p><p><br>Files are where your data is kept. A file can be many things. When you are storing input, it goes into a file. This can be a text file, a drawing program, or a sound file. These are some Linux essentials you can't forget.</p><p><br>Directories are organizational structures. They can organize your files and other directories. At any one time, you will be in a distinct directory. You have to be logged in to have a current working directory.</p><p id="mcetoc_1f9sus8jj8d1" class="align-left"><br><span style="color: #169179;"><strong>The Shell</strong></span></p><p><br>A shell is the interface to the operating system. It is text based and it accepts input as text. The input will usually invoke small programs or utilities that are installed in the operating system.</p><p>There are many different shells but the most common one is &lt;Bash&gt;. This is part of the history and usage of Linux.</p><p><br>When you first log in, the operating system will put you in your home directory. You can change this behavior, just so you know. When you change directories, you can always find out where you are.</p><p><br>I can enter in the command:</p><pre><br><code>pwd</code></pre><p>and it will tell me what directory I am currently in.</p><p><br>Now, when you invoke a utility like "pwd" the shell executes this command. What it does and what you will see from then on depends entirely on the utility and what it is designed to do.<br><br>You can also modify commands. This is done by the use of "arguments".</p><pre><br><br><code>pwd -L </code>             "use from the environment"</pre><pre><br><code>pwd -P </code>             "avoid all symbolic links"</pre><pre><br><code>pwd --version  </code>     "output version information and exit"</pre><pre><br><code>pwd --help    </code>      "display help and exit"</pre><p><br><br>You can also have multiple arguments for a command. This can greatly change its<br>behavior.</p><p><br>Certain commands require certain arguments. A "cp" command, which copies, needs<br>to know what it is copying and where it is copying to.</p><pre><br><code>cp directory1 directory2</code><br><br></pre><p>You can also have options for any particular command. They are called "options"<br>because you do not have to use them to get the command to work. They work like<br>arguments, however, they extend the behavior of that command.</p><p><br>Options and arguments are usually preceded by a hyphen or two depending on<br>the command. If you need to use multiple arguments and options, then use a<br>single hyphen with the corresponding letters.</p><pre><br><code>pwd -LP</code><br><br></pre><p>As you can see, there are no spaces in between the options. Most of the time<br>it does not matter in what order you put the arguments or options.</p><p><br>Most utilities will have a help feature.</p><pre><br><code>pwd --help</code><br><br></pre><p>It works the same for most commands. It will give you a lot of details about<br>the command. Arguments, options, and examples are very helpful to understand<br>how a command is supposed to be used.</p><p id="mcetoc_1f9sus8jj8d2" class="align-left"><br><span style="color: #169179;"><strong>Using Commands</strong></span></p><p><br>You usually have to be in the directory of a utility in order to run it. The<br>exception to this is, of course, how the path is set. The path is a  variable the<br>operating system uses to check directories for programs to run.</p><p>That makes it very useful so you don't always have to be in the /bin directory for example.</p><p><br>Of course, this was never the case as the path variable was always used.<br>However, if you did not have a path set somehow, you would have to be in the<br>directory to use any utility you wanted.</p><p><br>There is a trick to run a program without using the path.</p><pre><br><code>./script1.sh</code><br><br></pre><p>This lets you run a utility without using the path variable. This can be useful<br>at times. Experienced users should not need to do this much. Keep it in mind as<br>an option though if you need it sometime.</p><p id="mcetoc_1f9sus8jj8d3" class="align-left"><br><span style="color: #169179;"><strong>Redirecting Output</strong></span></p><p><br>You can redirect the output of commands. The output can be sent to another command or even a file.</p><pre><br><code>pwd &gt; test.txt</code></pre><p><br>This will run the "pwd" command, which tells the present working directory. The results or output will be sent and stored into the test.txt file. This is very flexible and should be used when you need to do something like this.</p><p><br>This operation will delete the file if there is another with the same name. Be careful using it.</p><p id="mcetoc_1f9sus8jj8d4" class="align-left"><br><span style="color: #169179;"><strong>Redirecting Input</strong></span></p><p><br>Just like output, you can redirect input. This is most often done with files. A file can contain a book list, for example. Commands like &lt;cat&gt; or &lt;grep&gt; can have the fileinput sent to it.</p><pre><br><code>cat &lt; booklist.txt</code></pre><pre><br><code>grep Magnus &lt; booklist.txt</code></pre><p id="mcetoc_1f9sus8jj8d5" class="align-left"><br><span style="color: #169179;"><strong>Pipelines</strong></span></p><p><br>You can connect two different commands through the use of a pipeline. This is<br>the pipeline symbol &lt; | &gt;. When it is used, it takes the output of the first<br>command and sends it to the input of the second command.</p><p><br>This is very similar to redirecting output and sending it to a file. The difference is that we are just dealing with commands. This makes the pipeline very flexible and good to use when appropriate.</p><pre><br><code>ls | lpr</code></pre><p><br>The above example takes the output from the &lt;ls&gt; command and sends it to the &lt;lpr&gt; command. The &lt;lpr&gt; command is a print utility, so &lt;lpr&gt; will print the<br>files listed by &lt;ls&gt;.</p><pre><br><code> who | sort</code></pre><p><br> This example takes the output of the &lt;who&gt; utility and sends it to the &lt;sort&gt;<br> utility. A list of users on your computer will be alphabetically sorted by this one command.</p><pre><br> <code>who | grep jmoore</code></pre><p><br> This is another good command to use. The &lt;who&gt; utility lists users and the<br> &lt;grep&gt; utility searches for patterns that you specify. We want to search for a user.</p><p>If you have a bunch of users and you need specific information, then use this to get your list and send the output to the &lt;grep&gt; utility.</p><p><br>There are many utilities that will work for this. Don't worry about knowing all at once. Over time, it gets easier to put them together when you need specific information. You can also use three or more utilities at once with pipelines as long as nothing conflicts.</p><p id="mcetoc_1f9sus8jj8d6" class="align-left"><br><span style="color: #169179;"><strong> Background Commands</strong></span></p><p><br> You can run commands or utilities in the foreground or background. Most of<br> your commands will be in the foreground. There are good times when you want<br> to run them in the background though.</p><p>If a command will take a long time to run, then it is a good candidate to run in the background.</p><p><br>The reason you would want to do this is that it frees up your shell for your to run other commands and do other tasks. When you run a command in the background, it is now a job.</p><p>The shell keeps track of it and assigns it a job number. You can even query this job number to check on the progress of the job.</p><p><br>You use the &lt;&amp;&gt; sign to indicate the current command is to run in the background. One thing I do a lot is update computers on my network. I have a script I wrote for this.</p><pre><br> <code> updates.sh &amp;</code></pre><p><br> This will run my script in the background as a job. I can do other things because it is going to take a long time. This makes it very useful.</p><p><br> To use an earlier example, you can do it with whatever you need to print.</p><p> </p><pre><code> ls | lpr &amp;</code></pre><p><br>Again, this throws the output of &lt;ls&gt; into the &lt;lpr&gt; print utility and prints everything in the background.</p><p>Commands can have options and arguments that you use after the command. These will modify the behavior of the command itself. When you enter a command it needs to listed in the path variable or you need to be in the current directory of the program.</p><p>You can chain commands through the use of pipelines. Pipelines use the &lt;|&gt; symbol. They take the output of the first command and send it to the input of the second command.</p><p>Commands can also be run in the background. This is another useful feature that will enhance your productivity. If there is a long task to run, start it and have it run in the background.</p><p>It will go away from sight but still be running. You can then use your shell to do other tasks like create new users or modify permissions on files.   </p><h2 id="mcetoc_1f9v9jt1i957" class="align-center"><span style="color: #236fa1;"><strong>Filtering Text In Linux</strong></span></h2><p>Filtering text allows you to do many efficient tasks in Linux. Displaying and sorting text is one of the most common tasks that you will do. This section is an introduction to filters in order to create pipelines for your workflow.</p><p id="mcetoc_1f9v9jt1i958" class="align-left" data-pm-slice="1 1 []"><span style="color: #169179;"><strong>Introduction</strong></span></p><p>Filtering text is the process of capturing text, doing something with it, and then sending it to the output stream. Most commonly, the output from one command is taken and redirected to the input of another command. This is usually accomplished through pipes and stream operators.</p><p id="mcetoc_1f9v9jt1i959" class="align-left"><span style="color: #169179;"><strong>Streams</strong></span></p><p>A stream is a series of data. There are input and output streams. Data flows both ways. Streams can be sent to a terminal, a file, or a network device. There are three main types:</p><ul><li>stdin</li><li>stdout</li><li>stderr</li></ul><p>The first, stdin, sends input to commands. Next, stdout, displays output from commands. Then, stderr, shows errors that were produced.</p><p id="mcetoc_1f9v9jt1i95a" class="align-left"><span style="color: #169179;"><strong>Pipes</strong></span></p><p>The pipe symbol, “|”, is one way to redirect output from one command to the input of another. Input can come from a command or a file. You can make a long sequence of commands using pipes. The output is usually shown in the terminal.</p><p id="mcetoc_1f9v9jt1i95b" class="align-left"><span style="color: #169179;"><strong>Output Redirection</strong></span></p><p>The operator, “&gt;”, can send output to a file. This is what you want to do if you need to save the results. Once you have data in a file, you have many more options. You can show the contents of a file, see any special characters associated with it, and split a file into two pieces.</p><p id="mcetoc_1f9v9jt1i95c" class="align-left"><span style="color: #169179;"><strong>The Cat Command</strong></span></p><p>The cat command can show the contents of a file and create files. By default, it reads from stdin unless you specify a file to read from.</p><pre>echo -e "1 teamup\n2 unbroken_bonds\n3 unified_minds\n4 cosmic_eclipse" &gt; edition.txt</pre><pre>$ cat edition.txt<br>1 teamup<br>2 unbroken_bonds<br>3 unified_minds<br>4 cosmic_eclipse</pre><p>In the first snippet we just sent some data to a text file that we created at the same time. Then we showed the contents of the file in the second snippet. This shows you how it works.</p><p>Let's make a second file now.</p><pre>echo -e "1 breakpoint\n2 breakthrough\n3 ultra_prism\n4 celestial_storm" &gt; edition2.txt</pre><p>Make sure the output is what we expect.</p><pre>$ cat edition2.txt<br>1 breakpoint<br>2 breakthrough<br>3 ultra_prism<br>4 celestial_storm</pre><p>The cat command also concatenates files. It just so happens that we have two files, ready for joining.</p><pre>$ cat edition*</pre><p>The asterisk is short for getting everything that has the partial name of "edition". </p><pre>1 teamup<br>2 unbroken_bonds<br>3 unified_minds<br>4 cosmic_eclipse<br>1 breakpoint<br>2 breakthrough<br>3 ultra_prism<br>4 celestial_storm</pre><p>This sends everything in those two files to the screen output. We can do something else cool, we can just make a third file with the contents of the first two.</p><pre>$ cat edition.txt edition2.txt &gt; edition3.txt</pre><p>This makes a third file that contains the contents of the first two.</p><pre>$ cat edition3.txt<br>1 teamup<br>2 unbroken_bonds<br>3 unified_minds<br>4 cosmic_eclipse<br>1 breakpoint<br>2 breakthrough<br>3 ultra_prism<br>4 celestial_storm<br><br></pre><p>That is really useful text manipulation. This also showcases the flexibility of the "cat" command.</p><p id="mcetoc_1f9v9jt1i95d" class="align-left"><span style="color: #169179;"><strong>Wordcount Command</strong></span></p><p>We can use this utility, "wc", to get more information from a file. This is handy if we know nothing about a file.</p><pre>$ wc edition3.txt<br>  8  16 119 edition3.txt</pre><p>We used this on the file we just created. It shows us the lines, words, and bytes in the file. It is very nice if you need to examine a file. The file may be thousands of lines long, you don't want all of that in your terminal output. If it is huge like that, you have another option.</p><p id="mcetoc_1f9v9jt1i95e" class="align-left"><span style="color: #169179;"><strong>Tail Command</strong></span></p><p>The tail command can show you the last lines of a file. By default, it shows you the last ten lines.</p><pre>$ tail edition3.txt</pre><p>My file is small but if it was large, that is the usage you would want to try first. </p><p id="mcetoc_1f9v9jt1i95f"><strong>Head Command</strong></p><p>The head command is the same as tail, except it shows you the first lines of a file. It is used in the same way. </p><h2 id="mcetoc_1i2s6qiqc4" class="align-center"><span style="color: #236fa1;"><strong>Working With Files</strong></span></h2><p>The following commands are what makes working with the command line worth it.<br>All of these tasks can be performed in a graphical environment, but when you get<br>used to the command line, they become much faster.<br><br><span style="color: #169179;"><strong>Wildcards</strong></span><br>Wildcards is one of the things that makes the command line so strong. They give<br>us a lot of flexibility. Wildcards allow you to select filenames based on<br>patterns of characters.<br>*     matches any characters<br>?     matches any single character<br>Using wildcards makes it possible to create complicated search queries. <br>*       all files<br>a*      any file begining with a<br>a*.txt  any file beginning with a followed by characters and ending with .txt<br>file??? any file beginning with the name file and followed by exactly 3<br>        characters.<br>Wildcards can be used with any command that accepts filenames as arguments.<br><br><span style="color: #169179;"><strong>Creating Directories</strong></span><br>The mkdir command is used to create directories.<br>mkdir directory-name<br>We can also make several directories at once.<br>mkdir name1 name2 name3 name4 name5<br><br><span style="color: #169179;"><strong>Copying Files</strong></span><br>The cp command is what we use to copy files or directories. <br>cp file1 file2<br>This copies the single file to another file.<br>cp -a file1 file2<br>The option -a copies a file with all of its attributes to another file.<br>cp -i file1 file2<br>The option -i will prompt the user for confirmation when overwriting a file.<br>cp -r folder1 folder2<br>The -r option will copy folders and all of their contents. <br>cp -u file1 file2<br>The -u option will only copy files that do not exist or are newer than the<br>existing correspondinf files in the destination directory.<br>cp -v folder1 folder2<br>The -v option will display extra information as copying is done.<br><br><span style="color: #169179;"><strong>Moving Files</strong></span><br>We move and rename files with the mv command. So, the mv command can be used in<br>multiple ways. <br>mv file1 file2<br>This will rename file1 to file2.<br>mv file1 folder1<br>When used like this, it moves file1 to folder 1. <br>mv -i file1 file1<br>The -i option will confirm you want to complete the action.<br>mv -u file1 file2<br>This will again only move files that do not exist or are newer than the files in<br>the destination folder.<br>mv -v file1 folder1<br>The -v will also give extra information when moving file1 to folder 1.<br><br><span style="color: #169179;"><strong>Removing Files</strong></span><br>The rm command is used to remove files and folders.<br>rm file1<br>That will remove a file.<br>rm -i file1<br>This will ask for confirmation because of the -i option.<br>rm -r folder1<br>This will remove a folder and all of its subdirectories. You must use this<br>option to delete folders. <br>rm -v file1<br>The -v gives extra information when performing this task.<br><br><span style="color: #169179;"><strong>Creating Links</strong></span><br>We create links using the ln command. Links can be either hard or soft. Hard<br>links are an older way of doing things, while soft links are the modern way. <br>This creates a hard link:<br>ln file link<br>This creates a soft link:<br>ln -s file link<br>ln -s folder link<br>As you can see, you cannot make a hard link of a folder or directory. That must<br>be done with a soft link. <br><br>Every file has a hard link associated with it. When a hard link is created, we<br>are making another way to refernce the file. Hard links cannot reference<br>anything outside its original file system. It also cannot reference a directory. <br><br>Soft links were made to overcome the limitations of hard links. When you create<br>a soft link, you are creating a unique file that contains a pointer to the<br>original file or directory. When you wrtie information to the soft link, the<br>original file is updated. So unless you go looking, it is hard to tell the<br>difference between the two. However, when you delete the link, the original file<br>is untouched. If the file is deleted first, the link stays but points to<br>nothing. </p><h2 id="mcetoc_1h4km0vek1o" class="align-center"><span style="color: #236fa1;"><strong>Rsync</strong></span></h2><p><span style="font-weight: 400;">Rsync stands for remote synchronization and it transfers and syncs files. It can do this locally and remotely. It is a very good tool. Though it has a learning curve, it is not hard to pick up. Its main use is to copy files and directories between two different computers. It can look at files and only send what has been changed. It can preserve all kinds of links and metadata.   </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"> </span></p><p class="align-left"><span style="color: #169179;"><strong>Installing Rsync  </strong><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"> </span></p><p><span style="font-weight: 400;">If you do not already have it installed on your system, you will need to install it. I am running Fedora. If you are running another distribution, use whatever package manager you have to install it.</span></p><p> </p><p><span style="font-weight: 400;">On Fedora run:</span></p><p><code><span style="font-weight: 400;">dnf update -y</span></code></p><p> </p><p><span style="font-weight: 400;">This will update your files. Then:</span></p><p><code><span style="font-weight: 400;">dnf install rsync -y</span></code></p><p> </p><p><span style="font-weight: 400;">This will install rsync to your system if it is not already there.</span></p><p> </p><p><span style="font-weight: 400;">Now run:</span></p><p><code><span style="font-weight: 400;">which rsync</span></code></p><p> </p><p><span style="font-weight: 400;">This will show you where it is installed on your system</span></p><p><span style="font-weight: 400;">Then run:</span></p><p><code><span style="font-weight: 400;">rsync –version</span></code></p><p> </p><p><span style="font-weight: 400;">That shows you the version you have.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Files</strong></span></p><p><span style="font-weight: 400;">Copying files is really easy. It is:</span></p><p> </p><p><code><span style="font-weight: 400;">rsync -v </span><span style="font-weight: 400;"></span><span style="font-weight: 400;">source </span><span style="font-weight: 400;"></span><span style="font-weight: 400;">destination</span></code></p><p> </p><p><span style="font-weight: 400;">The -v option means output will be given verbosely</span></p><p><span style="font-weight: 400;">Source is the full path of the source file unless you are in its directory already.</span></p><p><span style="font-weight: 400;">Destination should be the full path unless it is in your current path too.</span></p><p><span style="font-weight: 400;">It looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">rsync -v program1.cpp Documents</span></code></p><p> </p><p><span style="font-weight: 400;">In the above example I was already in the directory of the file I wanted to copy. You should do that when you can. I transferred it to the Documents folder.</span></p><p><span style="font-weight: 400;">Another example that is slightly different:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/documents /home/jason/Writing/</span></code></p><p> </p><p><span style="font-weight: 400;">This command copies all the files in Documents to my Writing folder.</span></p><p><span style="font-weight: 400;">You can use the ls command to look and make sure everything is transferred as expected.</span></p><p> </p><p><code><span style="font-weight: 400;">Ls Writing/</span></code></p><p> </p><p><span style="font-weight: 400;">There are many reasons to make copies of your files. Backing up important files to another remote location is something we should all do more.</span></p><p> </p><p><span style="font-weight: 400;">Whenever you do a file transfer, it is a good idea to switch to that location and make sure it is copied over. Doing this a few times will instill confidence in your command line abilities.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>The Trailing /</strong></span></p><p><span style="font-weight: 400;">The trailing slash at the end of a path dictates whether rsync will copy the contents of a directory or the entire directory with the folder included. Excluding the / from the source path copies the directory to the source destination.</span></p><p> </p><p><span style="font-weight: 400;"># This command will copy the Writing directory and its contents to the backup drive</span></p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/Writing /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;"># This command will only copy the files in the Writing directory to the backup drive.</span></p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/Writing/ /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">This is a small difference but it is very important to get right.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Contents of Directories</strong></span></p><p><span style="font-weight: 400;">It is often very useful to copy entire directories at once. It is easy to do this. Use:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av     /source/     /destination/</span></code></p><p> </p><p><span style="font-weight: 400;">Just use the full paths of the source and destination</span></p><p><span style="font-weight: 400;">So, something like this should get the job done:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Documents/ /home/jason/Backup/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directories to other Directories</strong></span></p><p><span style="font-weight: 400;">If we want to copy a folder to another folder then we do this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Documents /home/jason/Backup/</span></code></p><p> </p><p><span style="font-weight: 400;">You should look inside the directory to make sure you typed the command over correctly. You should see the folder nested in there.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying A File Remotely</strong></span></p><p><span style="font-weight: 400;">Rsync lets you connect to different machines. This makes copying files to other machines an easy practice. You will need:</span></p><ol><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">File path from local machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">IP address of remote machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">File path on remote machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Root access to remote machine</span></li></ol><p><span style="font-weight: 400;">The command will look something like this depending on what you need to do:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -v /path/from/local/machine     root@123.45.56.678:/root/remote/path</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directory To Another Drive</strong></span></p><p><span style="font-weight: 400;">This is very handy and gives you better protection. It is also easy to implement. </span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Writing /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">As usual, go and look to make sure everything happened the way you expect. After a while, you will not feel the need to do this.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directories Remotely</strong></span></p><p><span style="font-weight: 400;">Rsync can handle remote directories just as easily as single files. When you run this command, you will be asked for its password. So, be prepared on this front. The command looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av   /local/path   root@123.45.56.678:/root/remote/path/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Compressing Files</strong></span></p><p><span style="font-weight: 400;">Rsync can compress files that it tries to transfer. This will speed up a transfer. If your transfer is very small, you will not see a difference. However, if you are doing lots of video, for example, this will be of great benefit. Do it like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/video /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;">This command will copy the Video folder over to my backup drive.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Monitoring Your Progress</strong></span></p><p><span style="font-weight: 400;">If we are doing a long transfer, we can monitor the progress. I like statistics so this is useful for me. The command looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avz –info=progress2  /home/jason/Video /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;">This will give you the results of your transfer.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Syncing Directories</strong></span></p><p><span style="font-weight: 400;">Syncing directories is easily done. Keep in mind that sometimes files will be deleted and they will be gone. So, use this command after careful consideration. We use the –delete option with the regular command plus source and destination paths. This will look at the source directory and then make the destination directory match it. It looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -aP –delete /home/jason/Writing/ /path/BackupDrive/Writing/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Excluding Files and Directories</strong></span></p><p><span style="font-weight: 400;">Rsync can easily look the other way during a command if you want it to. So, if I want to exclude a subfolder of my Writing folder, it will do that. Here is how.</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avzP –exclude=Algebra /home/jason/Writing /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">We can also exclude files from a transfer or sync operation. If I want to exclude .mp3 files it looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avzP –exclude=*.mp3 /home/jason/Music/ /path/BackupDrive</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Options</strong></span></p><ul><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-a = –archive mode and equal to several other flags at once. It tells rsync to sync recursively,transfer special and block devices, preserve symbolic links,modification times, groups, ownership, and permissions</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-z = –compress. This option compresses the data that is sent to the destination machine.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-P = –partial and –progress. Using this option shows a progress bar during the transfer and keeps track of partially transferred files.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">–delete. When you use this option, it will delete extra files from the destination folder that are not in the source folder. It is how you mirror directories.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-q or –quiet. Use this when you don’t want to see error messages</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-e. Use this when you want to choose the remote shell to use</span></li></ul><p> </p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on August 14, 2024</p><ul class="post__tag"><li><a href="https://aindien.com/linux/">Linux</a></li></ul><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Faindien.com%2Flinux-essentials-.html" class="js-share facebook" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/share?url=https%3A%2F%2Faindien.com%2Flinux-essentials-.html&amp;via=_Aindien&amp;text=Linux%20Explained" class="js-share twitter" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span></a></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://aindien.com/authors/jason-moore/" class="invert" rel="author">Jason Moore</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://aindien.com/how-to-use-strings-in-c.html" class="invert post__nav-link" rel="prev"><span>Previous</span> How To Use Strings In C++</a></div><div class="post__nav-next"><a href="https://aindien.com/using-variables-in-c.html" class="invert post__nav-link" rel="next"><span>Next</span> Using Variables in C++ </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2021-08-07T08:43" class="feed__date">August 7, 2021</time></div><h3 class="h1"><a href="https://aindien.com/managing-input-and-output-streams-in-the-linux-shell.html" class="invert"> Managing Input and Output Streams in the Linux Shell</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2021-07-15T23:08" class="feed__date">July 15, 2021</time></div><h3 class="h1"><a href="https://aindien.com/managing-files-in-a-linux-environment.html" class="invert">Managing Files In A Linux Environment</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2021-04-27T22:35" class="feed__date">April 27, 2021</time></div><h3 class="h1"><a href="https://aindien.com/the-linux-shell-for-beginners.html" class="invert">The Linux Shell For Beginners</a></h3></article></div></div><div class="banner banner--after-post"><div class="wrapper"><link href="//cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel="stylesheet" type="text/css"><style type="text/css">#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
	/* Add your own Mailchimp form style overrides in your site stylesheet or in this style block.
	   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */</style><div id="mc_embed_signup"><form action="https://aindien.us11.list-manage.com/subscribe/post?u=5aefa50c3a5900492b165a83f&amp;id=1c348b805a" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate><div id="mc_embed_signup_scroll"><h2>Subscribe</h2><div class="indicates-required"><span class="asterisk">*</span> indicates required</div><div class="mc-field-group"><label for="mce-EMAIL">Email Address <span class="asterisk">*</span></label> <input type="email" name="EMAIL" class="required email" id="mce-EMAIL"></div><div class="mc-field-group"><label for="mce-FNAME">First Name</label> <input type="text" name="FNAME" id="mce-FNAME"></div><div class="mc-field-group"><label for="mce-LNAME">Last Name</label> <input type="text" name="LNAME" id="mce-LNAME"></div><div id="mce-responses" class="clear"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5aefa50c3a5900492b165a83f_1c348b805a" tabindex="-1"></div><div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div></div></form></div><script type="text/javascript" src="//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js"></script><script type="text/javascript">(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';}(jQuery));var $mcj = jQuery.noConflict(true);</script></div></div></main><footer class="footer"><div class="footer__copyright"><p>Jason Moore 2022</p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://aindien.com/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>