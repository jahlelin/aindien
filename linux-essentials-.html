<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Learning the Linux Operating System - Jason&#x27;s Computing Guides</title><meta name="description" content="Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://aindien.com/linux-essentials-.html"><link rel="alternate" type="application/atom+xml" href="https://aindien.com/feed.xml" title="Jason&#x27;s Computing Guides - RSS"><link rel="alternate" type="application/json" href="https://aindien.com/feed.json" title="Jason&#x27;s Computing Guides - JSON"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://aindien.com/assets/css/style.css?v=166a31b4480c68773db8a06507216db7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://aindien.com/linux-essentials-.html"},"headline":"Learning the Linux Operating System","datePublished":"2021-07-05T22:23-05:00","dateModified":"2025-07-26T17:31-05:00","description":"Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you.","author":{"@type":"Person","name":"Jason Moore","url":"https://aindien.com/authors/jason-moore/"},"publisher":{"@type":"Organization","name":"Jason Moore"}}</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-393JFJ482L"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-393JFJ482L');</script><script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/5aefa50c3a5900492b165a83f/93dcd5a76da18d3becc7e677f.js");</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://aindien.com/">Jason&#x27;s Computing Guides</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://aindien.com/about-me.html" target="_self">Andromeda</a></li><li><a href="https://aindien.com/c/" target="_self">C++</a></li><li><a href="https://aindien.com/linux/" target="_self">Linux</a></li><li><a href="https://aindien.com/networking/" target="_self">Networking</a></li><li><a href="https://aindien.com/git/" target="_self">Git</a></li><li><a href="https://aindien.com/python/" target="_self">Python</a></li><li><a href="https://aindien.com/ai/" target="_self">AI</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://aindien.com/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://aindien.com/media/website/computing-logo-2.jpg" srcset="https://aindien.com/media/website/responsive/computing-logo-2-xs.jpg 300w, https://aindien.com/media/website/responsive/computing-logo-2-sm.jpg 480w, https://aindien.com/media/website/responsive/computing-logo-2-md.jpg 768w, https://aindien.com/media/website/responsive/computing-logo-2-lg.jpg 1024w, https://aindien.com/media/website/responsive/computing-logo-2-xl.jpg 1360w, https://aindien.com/media/website/responsive/computing-logo-2-2xl.jpg 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2021-07-05T22:23">July 5, 2021</time></div><h1>Learning the Linux Operating System</h1><div class="post__meta post__meta--author"><a href="https://aindien.com/authors/jason-moore/" class="feed__author invert">Jason Moore</a></div></div></header></div><div class="wrapper post__entry"><p>Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you.</p><p><a target="_blank" href="https://amzn.to/4cmUtgG" rel="noopener">Ankr Store on Amazon.</a></p><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1f9st1def88s">Introduction To Linux</a></li><li><a href="#mcetoc_1f9sus8jj8cu">Things To Know Before You Install Linux</a></li><li><a href="#mcetoc_1hu4eo8ea3">Exploring Your Linux System</a></li><li><a href="#mcetoc_1hipjg8uvng">Using The Shell In Linux </a></li><li><a href="#mcetoc_1f9sus8jj8cv">Doing More With The Shell</a></li><li><a href="#mcetoc_1f9v9jt1i957">Filtering Text In Linux</a></li><li><a href="#mcetoc_1i2s6qiqc4">Working With Files</a></li><li><a href="#mcetoc_1i5cbf0acbr">Commands in Linux</a></li><li><a href="#mcetoc_1h4km0vek1o">Rsync</a></li><li><a href="#mcetoc_1i80ndtv0f">Input and Output Redirection</a></li><li><a href="#mcetoc_1i8tnrhk0p">Permissions</a></li><li><a href="#mcetoc_1i9aekmko6">Processes</a></li><li><a href="#mcetoc_1i9k2jfo56">Environment Variables</a></li><li><a href="#mcetoc_1iam684qlm">Intro To Vim</a></li><li><a href="#mcetoc_1ib7v7d3ie">Customizing Your Prompt</a></li><li><a href="#mcetoc_1ilrsbqka1o">Managing Software</a></li><li><a href="#mcetoc_1io9e0qg015">Managing Storage Devices</a></li><li><a href="#mcetoc_1iq6p7ei129">Networking</a></li></ul></div><h2 id="mcetoc_1f9st1def88s" class="align-center"><span style="color: #236fa1;"><strong>Introduction To Linux</strong></span></h2><p>Linux is a direct descendant of the Unix operating system. Unix was created by government researchers who needed some custom tools. It spread to universities and students popularized it greatly.</p><p>Berkeley also played an important part because they modified it extensively. This became known as BSD, the Berkeley Software Distribution. At the same time there was also Unix System V, which came from the version maintained by Bell Labs.</p><p id="mcetoc_1eim2v6td1" class="align-left"><span style="color: #169179;"><strong>Linus Torvalds</strong></span></p><p>Torvalds was a Finnish student in the early 90s. He was working on the core of that would be the Linux kernel as we know it. After it was finished, he combined it with the GNU operating system for the applications.</p><p>Linux the name comes from the combination of Linus and Unix.</p><p id="mcetoc_1eim2vdh32" class="align-left"><span style="color: #169179;"><strong>Distributions</strong></span></p><p>Neither a kernel nor applications make a complete operating system. So putting them together was a must. It just so happened that different parties each the separate part ready. Others have since as well.</p><p>The combination of a kernel and related packages that run on that system are known as a distribution. There are hundreds of distributions today.</p><p>They include development systems, word processing, spreadsheet software, music players, and many other nice utilities. Fedora, Opensuse, and Ubuntu are great ones to get started with.</p><p id="mcetoc_1eim2vkp23" class="align-left"><span style="color: #169179;"><strong>Software</strong></span></p><p>There are tons of nice packages available for Linux systems today. Most are free, but you can buy some also that will include extras like nice support built in. Graphics tools, web servers, and networking utilities are some of the most popular packages.</p><p id="mcetoc_1eim2vqpr4" class="align-left"><span style="color: #169179;"><strong>Supported Platforms</strong></span></p><p>Almost everything today will run Linux. Intel, Mac, IBM, and Arm based computers all run Linux and does so very well. In fact, Linux is only getting more popular.</p><p id="mcetoc_1eim300dg5" class="align-left"><span style="color: #169179;"><strong>Portability</strong></span></p><p>Originally, Unix messed this part up because vendors made versions all for themselves. So the market was very fragmented. However, Linux was written most in the &lt;C&gt; language.</p><p>This allowed it to be portable between other systems. Doing so allowed it to spread much quicker than Unix ever could.</p><p>Now, Linux is used everywhere and for any type of system.</p><p id="mcetoc_1eim3081a6" class="align-left"><span style="color: #169179;"><strong>The Kernel</strong></span></p><p>The kernel’s job is to distribute the computer’s resources. The resources of a computer are things like cpu and memory. Peripherals need access to these items as well, so the kernel will make sure each one gets what it needs.</p><p>Software will request resources through system calls. The kernel then gives the software what it needs.</p><p id="mcetoc_1eim30dqk7" class="align-left"><span style="color: #169179;"><strong>Multiuser Support</strong></span></p><p>A Linux system is designed to have many users on one computer. This gives them each their own little area of the operating system and storage. This makes cost a lot less. In fact, this was often done to save money.</p><p>An organization could have one nice machine and dumb terminals to access located anywhere in the building. It is probably still a good idea if you think about it. Another advantage to this is that it makes the machine more cost efficient.</p><p>No one can use all of a machine’s resources constantly. So if one person is using it then most of the resources are going unused. This goes hand in hand with the task system.</p><p>Since Linux is designed to handle multiple users, it can also handle many concurrent tasks at the same time too. This means that each user can run many processes at the same time.</p><p id="mcetoc_1eim30lce8" class="align-left"><span style="color: #169179;"><strong>Bash And Other Shells</strong></span></p><p>A shell is a command interpreter. This is just an interface to the core of the operating system. It allows you to run commands and have them act instantly. It is a very powerful concept.</p><p>Bash is the most popular shell, but there are many other ones. Some are older, but there are newer ones too. Each user on a machine can use his own shell if that is his preference. This allows for nice customization.</p><p id="mcetoc_1eim30qqj9" class="align-left"><span style="color: #169179;"><strong>Desktops</strong></span></p><p>Originally, computers were mostly used with shells. This involved users issuing commands as needed on a machine. They could do calculations, manage a server or use a text editor.</p><p>Eventually, however, a GUI was created, and these were the first desktops. When I say desktop, I am referring to the graphical system that lets you do the same tasks as a shell.</p><p>The Gnome, Cinnamon, and KDE desktop environments are some of the most popular today. They each have a very different style, but they are also fun to learn. They are fun because each has its own advantages.</p><p>Today, you can even get desktops with certain spins built in to them. A spin means they come with certain software packages that do a certain role.</p><p>For example, I could download an Astronomy spin that would include many types of Astronomy software. That is a really cool feature, by the way.</p><p id="mcetoc_1eim314h5a" class="align-left"><span style="color: #169179;"><strong>Utilities</strong></span></p><p>Linux comes with many types of useful programs called utilities. These all do some unique task and do it very well. These are the basis behind the commands that you use in a terminal window.</p><p>I can check the speed of my system, disk space, free memory, cpu usage by process and the list could go on and on.</p><p id="mcetoc_1eim31c4rb" class="align-left"><span style="color: #169179;"><strong>Application Development</strong></span></p><p>This is one of my favorite features. Almost every distribution has program development built in to its core. Compilers and interpreters are there. Several text editors are there too. Support for several languages comes right out of the box.</p><p>You can start with C++ or C immediately after an install. In one distribution I have, a very nice Python pdf book is even included along with its support of course. Many times an IDE is also included if you prefer that kind of workflow.</p><p>Whole books have been written about the history and usage of Linux. It is very rich in history and you can spend a lifetime learning useful things that you can with these Linux essentials.</p><p>Did I mention it is free and has the best computing community in the world? While it came from Unix, it has far surpassed its digital parent. There is a distribution for everyone.</p><p>It does everything and more that a Windows and Mac computer can do. This is because 99% of the software is free and easily installed.</p><h2 id="mcetoc_1f9sus8jj8cu" class="align-center"><span style="color: #236fa1;"><strong>Things To Know Before You Install Linux</strong></span></h2><p>Installing Linux is not difficult, but there are some details you should be aware of. You don't want to lose data. </p><p id="mcetoc_1ent5irsm0" class="align-left" data-pm-slice="0 0 []"><span style="color: #169179;">Formatting The Hard Drive</span></p><p>A new hard drive will have to be specially prepared by its manufacturer. They then send it to a retail store or reseller. Once in a consumer’s hand, it can be partitioned. A partition is a logical section on the drive.</p><p>It will have a device name to make it easy to refer to. With certain utilities, you can resize and change most partitions. When you partition a drive, you are creating a partition table and a filesystem. The table contains all the information on the partitions.</p><p>The filesystem is how data is read. It shows where the data is stored on the drive. It does this by mappings called inodes. There are many kinds of filesystems.</p><p>They each have their advantages. Most installation utilities will do these steps automatically if you prefer.</p><p>While formatting is not something you do every day, it is useful to know that it happens. You lose whatever data is on the drive when you format it. If it is a new system, then it is not a concern.</p><p>However, if this is an older drive then you will want to back up your data. Losing good data is not good.</p><p id="mcetoc_1ent5j76f1" class="align-left"><span style="color: #169179;">Setting Up Directories</span></p><p>You have probably heard that everything in Linux is a file. This is really pretty true. Every file in a system has a unique identifier. These are path names. The entire path name is the identifier.</p><p>So, /home/music has a separate identifier than /home/documents. Notice also that Linux systems use the slash that is closest to the right-shift button.</p><p>I admit this may be out of the realm of first users. Setting your own directories in a filesystem is for advanced users. It is possible that you need to do it, so I am mentioning it for this. For instance, you could be asked to by your boss.</p><p id="mcetoc_1ent5je8t2" class="align-left"><span style="color: #169179;">Mount Points</span></p><p>A filesystem needs to be mounted. It will have a specific mount point. A mount point is therefore the directory where the filesystem is placed. Most installation programs will do this automatically.</p><p>However, it is good to know that this takes place in the background. You might want to customize this process in the future. There can be multiple filesystems within a system. They can be different ones and hold different files.</p><p>There is a file that holds the filesystem information and it is called the /etc/fstab file. This is configurable if you want to adjust settings one day.</p><p id="mcetoc_1ent5jko33" class="align-left"><span style="color: #169179;">Making Partitions</span></p><p>Every specific distribution will have its own installation program. These programs will usually take care of steps like partitioning. However, it is important to know that you can usually do it yourself.</p><p>Some people have specific needs for what they want their setup to look like after they finish it. To do this correctly, they will have to manually setup their disk. You can decide what partitions that you want and their sizes.</p><p>This can be very important. If you think you're going to need a large &lt;swap&gt; partition, then you can set this manually. Partition examples include /boot, /root, /swap, and /home.</p><p>There used to be good reasons to set up several other partitions on a Linux system. A lot of those reasons revolved around disk fragmentation. That is not too common anymore, as most new disks are SSD or NVME now.</p><p>These types of disks do not fragment. If you reinstall often, then it could be useful to separate your partitions so you do not have to recreate programs or data as much.</p><p>A /var partition could be useful. If your data changes all the time, then you might want to do this. The /log directory is often in here too. Standardizing where log files are kept is a good idea for everyone.</p><p>They are always the keys to what is wrong with your system, so it is important to know where they are quickly. Another popular partition is /opt. This is where installation packages are on your system.</p><p>It is handy to know where to find certain types of files like I stated above. Packages are no exception. If you need to distribute to other systems on your network, then it is easier if they are all in one place.</p><p id="mcetoc_1ent5jquo4" class="align-left"><span style="color: #169179;">RAID</span></p><p>A redundant array of independent disks system is definitely something to consider. You will want to consider this if this is a server or any other machine with valuable data stored on the disks.</p><p>However, if you store your data on a remote server or a local device, then the extra cost may not be justified.</p><p>A RAID system uses two or more disks, partitions, or some combination of these two. It is a way to protect your data or add performance to your system. There are several RAID modes, and each has its advantages and disadvantages.</p><p>RAID can be hardware or software. Hardware RAID is usually in the form of addon cards within your system. They can contain processing power and often some cache memory. Software RAID is built in to Linux systems through certain utilities and is usually the better choice.</p><p>A long time ago hardware RAID was more popular because system hardware had progressed little. In current times with SSD’s, high-powered processors, and systems with 16-128 GB of ram, software RAID is the way to go.</p><p>The main reason administrators use RAID is to help protect their important data from hardware failure. It should not be the only tactic you use, just like you should not only have one backup of your data.</p><p>Software RAID is what I use when I deem it necessary. It also costs nothing because the Linux kernel controls it. It is also more powerful and gives greater flexibility to your system. The downside is that it takes more skill to set up.</p><p>Understand what mode you desire, how to use the utilities to implement it, and know how to query your system to find out the kinds of devices it has internally.</p><p id="mcetoc_1ent5k1565" class="align-left"><span style="color: #169179;">Logical Volume Manager</span></p><p>LVM is a great utility. It gives you the chance to implement it when you first do any installs. I highly recommend doing so. It gives your system great flexibility. So what does it do? LVM allows you to control your logical volumes at a moment’s notice.</p><p>You can add more space at any time. A logical volume is like a partition, except it is adjustable as you need it. Partitions are not and are pretty much set in stone.</p><p>This works by taking any physical part of your drives, which include disks and partitions and grouping them into a storage pool. With these individual parts in a storage pool, you use the LVM to group them how you need them to appear to your system.</p><p>You can also change these groupings and their allocated space at any time.</p><h2 id="mcetoc_1hu4eo8ea3" class="align-center"><span style="color: #236fa1;"><strong>Exploring Your Linux System</strong></span></h2><p><span style="color: #169179;"><strong>Ls Command</strong></span></p><p><span style="font-weight: 400;">The ls command is one of the most used commands. It lists directory contents. It will quickly become second nature. We can see directory contents and other information about files. It is used like this:</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">We can specify a directory:</span></p><p><code><span style="font-weight: 400;">Ls /Music</span></code></p><p><span style="font-weight: 400;">We can see more detail like this:</span></p><p><code><span style="font-weight: 400;">Ls -l /Music</span></code></p><p> </p><p><span style="font-weight: 400;">As with almost all commands, there are options and arguments you can use with them. These options and arguments modify how the commands work. An option is usually a dash followed by a single character. These are called short options. There are also long options that do the same thing in most cases. A long option is two dashes followed by a word. You can even use more than one option at a time. So we can do things like:</span></p><p><code><span style="font-weight: 400;">Ls -a</span></code></p><p><code><span style="font-weight: 400;">Ls -h</span></code></p><p><code><span style="font-weight: 400;">Ls -ah</span></code></p><p><span style="font-weight: 400;">Options in Linux are case sensitive. It can be easy to forget this so keep it in mind. </span></p><p> </p><p><span style="color: #169179;"><strong>CD Command</strong></span></p><p><span style="font-weight: 400;">The cd command lets you move around your system. It changes directories.</span></p><p><span style="font-weight: 400;">Once we look at our current location with the ls command, we can change to a directory that is listed there if we want to.</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">I am still in my home directory but I see a Music folder. What’s in there I wonder? Let us see.</span></p><p><code><span style="font-weight: 400;">Cd Music</span></code></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">Well, there isn’t anything in there yet. I need to fix that soon. I like music like everyone else. Hopefully you can see how this is helpful. Cd also has other things it can do like move backward one file level.</span></p><p><code><span style="font-weight: 400;">Cd ..</span></code></p><p><code><span style="font-weight: 400;">ls</span></code><span style="font-weight: 400;"><br></span><span style="font-weight: 400;">Now, you see that you are back where you started. That is the basic usage for the cd command. It is enough for now.</span></p><p> </p><p><span style="color: #169179;"><strong>File Command</strong></span></p><p><span style="font-weight: 400;">The file command gives you the file type of the file you are looking at. </span></p><p><code><span style="font-weight: 400;">File .bashrc</span></code></p><p><span style="font-weight: 400;">This shows you it is a text file. Since there are many types of files it is not always obvious what kind of file you are seeing. </span></p><p> </p><p><span style="color: #169179;"><strong>Less Command</strong></span></p><p><span style="font-weight: 400;">The less command lets us look at text files and see a smaller portion. This is helpful when the file in question is many pages long. We look at text files so we can modify them. An example would be a file that controls settings. Another reason is that program code is text and that is how we make programs. We can use it like this:</span></p><p><code><span style="font-weight: 400;">Less .bashrc</span></code></p><p><span style="font-weight: 400;">We can now scroll up and down. I do not recommend changing anything yet, but you need to know how to examine a file. Files are how settings are done in Linux so it is important to know about. </span></p><p><span style="font-weight: 400;">Type q to exit the less program</span></p><p> </p><p><span style="color: #169179;"><strong>Symbolic Links</strong></span></p><p><span style="font-weight: 400;">While you are exploring your system, you might see something that looks pretty weird after you use ls to view a directory’s contents. This is called a symbolic link. In fact, you can identify these symbolic links because they start with an &lt;l&gt;. This special file is also called a soft link. A soft link is like a pointer to a real file. It is useful because a program can change the pointer instead of countless versions of the file itself. This lets your system be much more efficient. </span></p><h2 id="mcetoc_1hipjg8uvng" class="align-center"><span style="color: #236fa1;"><strong>Using The Shell In Linux</strong><span style="font-weight: 400;"> </span></span></h2><p><span style="font-weight: 400;">When people talk about using the command line, they are really referring to the Shell. This is accessed by your terminal window which you run commands in. The shell itself is just a program that works behind the scenes. Almost all distributions of Linux have one included with their version. There are several different versions of Shells also. Some of these are Bash, Zsh, and Fish. </span></p><p> </p><p><span style="font-weight: 400;">There are also pieces of software called terminal emulators. These small programs help you talk to the Shell. This is something like Konsole or Terminal depending on your distribution. </span></p><p> </p><p><span style="font-weight: 400;">Your Shell prompt is where you type in commands. If the last character is a ‘$’ then you are a regular user. If the last character is a ‘#’ you are running as a root user which gives you superpowers in the Linux world. </span></p><p> </p><p><span style="font-weight: 400;">The Shell will give you access to your command history. You see the command history by using the up arrow on your keyboard. Keep pressing the up arrow to see more of your commands you have used. This is useful because you can just use the up arrow to redo commands instead of retyping a long command. Most distributions remember around a thousand of your last commands. </span></p><p> </p><p><span style="font-weight: 400;">Let’s start using some basic commands. Type the command and then hit enter:</span></p><p><code><span style="font-weight: 400;">Date</span></code></p><p><span style="font-weight: 400;">You will see the current time and date pop up.</span></p><p><span style="font-weight: 400;">Now, try the ‘cal’ command:</span></p><p><code><span style="font-weight: 400;">Cal</span></code></p><p><span style="font-weight: 400;">You should get a view of the current month. I like to use the ‘cal’ command as I am always forgetting what day it is and it is quicker to use than most other calendar systems. </span></p><p><span style="font-weight: 400;">Another useful command to use is ‘df’ which tells you how much free space is on your system.</span></p><p><code><span style="font-weight: 400;">Df</span></code></p><p><span style="font-weight: 400;">There is a useful parameter you can run with this command and I recommend using it:</span></p><p><code><span style="font-weight: 400;">Df -h</span></code></p><p><span style="font-weight: 400;">This makes the output easier to read. I will get into parameters and options later on.</span></p><p><span style="font-weight: 400;">The next command to learn is the ‘free’ command. We will also add the ‘-h’ parameter after it:</span></p><p><code><span style="font-weight: 400;">Free -h</span></code></p><p><span style="font-weight: 400;">This output tells you about the memory on your system.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Navigating Your File System</strong></span></p><p><span style="font-weight: 400;">The Linux file system looks very different from a Windows file system. It is mainly because everything is named differently. The file system is organized by directories. These directories can contain either files or more directories. In Windows, they are called folders. I will use directories from here on out though. </span></p><p> </p><p><span style="font-weight: 400;">The first directory in a Linux system is called the ‘root’ directory. It contains everything else on the local system. Linux has a single file system for everything in or attached to that computer. It is important to remember this when navigating. An external storage device is mounted or attached to somewhere in the file system. </span></p><p> </p><p><span style="font-weight: 400;">To see where you are at any time, use the ‘pwd’ command. This stands for present working directory.</span></p><p><code><span style="font-weight: 400;">Pwd</span></code></p><p><span style="font-weight: 400;">It gives a simple one line of output. Mine says:</span></p><p><code><span style="font-weight: 400;">/home/jason</span></code></p><p><span style="font-weight: 400;">Whenever we start our computer session in Linux, we start at ‘/home/username’. My username is Jason of course. We can change that later if we want to but that is not important right now. </span></p><p> </p><p><span style="font-weight: 400;">To see what files are in a directory, we use the ‘ls’ command.</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">This command can be used to see the contents of any directory if you know the path. We already know one because we are part of it. It is our ‘home’ directory.</span></p><p><code><span style="font-weight: 400;">Ls /home</span></code></p><p><span style="font-weight: 400;">You can also see the contents of the whole computer by looking at the ‘root’. To see the ‘root’, we use ‘/’. So try this:</span></p><p><code><span style="font-weight: 400;">Ls /</span></code></p><p><span style="font-weight: 400;">This shows you everything at the ‘root’ level. See the ‘/home’ directory? Your user directory is located within that ‘/home’ directory. Hopefully you can see how your system is organized now. </span></p><p> </p><p><span style="font-weight: 400;">This brings us to moving directories. We move to a different directory for various reasons. Often, we just want to work from that directory. While we can see what is there by using the path or make a file and put it there, it is easier to just be in that directory. To get to that directory we use the ‘cd’ command:</span></p><p><code><span style="font-weight: 400;">Cd /home/jason</span></code></p><p><span style="font-weight: 400;">This is called using an absolute path because we started at the ‘root’ directory denoted by the first ‘/’ and then listed the directory structure until we got to our directory under ‘/home’.  We can also use relative pathnames. It is called this because it is relative to our present directory. So:</span></p><p><code><span style="font-weight: 400;">Cd ..</span></code></p><p><span style="font-weight: 400;">Will move us up one directory from our present working directory. </span></p><p><span style="font-weight: 400;">‘Cd’ is a very helpful command. It allows for fast movement if you use a few tricks.</span></p><p><span style="font-weight: 400;">To instantly go to your ‘/home’ directory:</span></p><p><code><span style="font-weight: 400;">Cd</span></code></p><p><span style="font-weight: 400;">To change the working directory to the previous directory:</span></p><p><code><span style="font-weight: 400;">Cd -</span></code></p><h2 id="mcetoc_1f9sus8jj8cv" class="align-center"><span style="color: #236fa1;"><strong>Doing More With The Shell</strong></span></h2><p>Using a shell gives you great satisfaction. It does have a learning curve but, it is well worth it. I am assuming you have no prior knowledge. Taking it slow and using it every day is the best way.</p><p id="mcetoc_1f9sus8jj8d0" class="align-left"><span style="color: #169179;"><strong>Files and Directories</strong></span></p><p><br>Files are where your data is kept. A file can be many things. When you are storing input, it goes into a file. This can be a text file, a drawing program, or a sound file. These are some Linux essentials you can't forget.</p><p><br>Directories are organizational structures. They can organize your files and other directories. At any one time, you will be in a distinct directory. You have to be logged in to have a current working directory.</p><p id="mcetoc_1f9sus8jj8d1" class="align-left"><br><span style="color: #169179;"><strong>The Shell</strong></span></p><p><br>A shell is the interface to the operating system. It is text based and it accepts input as text. The input will usually invoke small programs or utilities that are installed in the operating system.</p><p>There are many different shells but the most common one is &lt;Bash&gt;. This is part of the history and usage of Linux.</p><p><br>When you first log in, the operating system will put you in your home directory. You can change this behavior, just so you know. When you change directories, you can always find out where you are.</p><p><br>I can enter in the command:</p><p><br><code>pwd</code></p><p>and it will tell me what directory I am currently in.</p><p><br>Now, when you invoke a utility like "pwd" the shell executes this command. What it does and what you will see from then on depends entirely on the utility and what it is designed to do.<br><br>You can also modify commands. This is done by the use of "arguments".</p><p><br><br><code>pwd -L</code>             "use from the environment"</p><p><br><code>pwd -P</code>             "avoid all symbolic links"</p><p><br><code>pwd --version  </code>     "output version information and exit"</p><p><br><code>pwd --help    </code>      "display help and exit"</p><p><br><br>You can also have multiple arguments for a command. This can greatly change its<br>behavior.</p><p><br>Certain commands require certain arguments. A "cp" command, which copies, needs<br>to know what it is copying and where it is copying to.</p><p><br><code>cp directory1 directory2</code><br><br></p><p>You can also have options for any particular command. They are called "options"<br>because you do not have to use them to get the command to work. They work like<br>arguments, however, they extend the behavior of that command.</p><p><br>Options and arguments are usually preceded by a hyphen or two depending on<br>the command. If you need to use multiple arguments and options, then use a<br>single hyphen with the corresponding letters.</p><p><br><code>pwd -LP</code><br><br></p><p>As you can see, there are no spaces in between the options. Most of the time<br>it does not matter in what order you put the arguments or options.</p><p><br>Most utilities will have a help feature.</p><p><br><code>pwd --help</code><br><br></p><p>It works the same for most commands. It will give you a lot of details about<br>the command. Arguments, options, and examples are very helpful to understand<br>how a command is supposed to be used.</p><p id="mcetoc_1f9sus8jj8d2" class="align-left"><br><span style="color: #169179;"><strong>Using Commands</strong></span></p><p><br>You usually have to be in the directory of a utility in order to run it. The<br>exception to this is, of course, how the path is set. The path is a  variable the<br>operating system uses to check directories for programs to run.</p><p>That makes it very useful so you don't always have to be in the /bin directory for example.</p><p><br>Of course, this was never the case as the path variable was always used.<br>However, if you did not have a path set somehow, you would have to be in the<br>directory to use any utility you wanted.</p><p><br>There is a trick to run a program without using the path.</p><p><br><code>./script1.sh</code><br><br></p><p>This lets you run a utility without using the path variable. This can be useful<br>at times. Experienced users should not need to do this much. Keep it in mind as<br>an option though if you need it sometime.</p><p id="mcetoc_1f9sus8jj8d3" class="align-left"><br><span style="color: #169179;"><strong>Redirecting Output</strong></span></p><p><br>You can redirect the output of commands. The output can be sent to another command or even a file.</p><p><br><code>pwd &gt; test.txt</code></p><p><br>This will run the "pwd" command, which tells the present working directory. The results or output will be sent and stored into the test.txt file. This is very flexible and should be used when you need to do something like this.</p><p><br>This operation will delete the file if there is another with the same name. Be careful using it.</p><p id="mcetoc_1f9sus8jj8d4" class="align-left"><br><span style="color: #169179;"><strong>Redirecting Input</strong></span></p><p><br>Just like output, you can redirect input. This is most often done with files. A file can contain a book list, for example. Commands like &lt;cat&gt; or &lt;grep&gt; can have the fileinput sent to it.</p><p><br><code>cat &lt; booklist.txt</code></p><p><br><code>grep Magnus &lt; booklist.txt</code></p><p id="mcetoc_1f9sus8jj8d5" class="align-left"><br><span style="color: #169179;"><strong>Pipelines</strong></span></p><p><br>You can connect two different commands through the use of a pipeline. This is<br>the pipeline symbol &lt; | &gt;. When it is used, it takes the output of the first<br>command and sends it to the input of the second command.</p><p><br>This is very similar to redirecting output and sending it to a file. The difference is that we are just dealing with commands. This makes the pipeline very flexible and good to use when appropriate.</p><p><br><code>ls | lpr</code></p><p><br>The above example takes the output from the &lt;ls&gt; command and sends it to the &lt;lpr&gt; command. The &lt;lpr&gt; command is a print utility, so &lt;lpr&gt; will print the<br>files listed by &lt;ls&gt;.</p><p><br><code> who | sort</code></p><p><br> This example takes the output of the &lt;who&gt; utility and sends it to the &lt;sort&gt;<br> utility. A list of users on your computer will be alphabetically sorted by this one command.</p><p><br> <code>who | grep jmoore</code></p><p><br> This is another good command to use. The &lt;who&gt; utility lists users and the<br> &lt;grep&gt; utility searches for patterns that you specify. We want to search for a user.</p><p>If you have a bunch of users and you need specific information, then use this to get your list and send the output to the &lt;grep&gt; utility.</p><p><br>There are many utilities that will work for this. Don't worry about knowing all at once. Over time, it gets easier to put them together when you need specific information. You can also use three or more utilities at once with pipelines as long as nothing conflicts.</p><p id="mcetoc_1f9sus8jj8d6" class="align-left"><br><span style="color: #169179;"><strong> Background Commands</strong></span></p><p><br> You can run commands or utilities in the foreground or background. Most of<br> your commands will be in the foreground. There are good times when you want<br> to run them in the background though.</p><p>If a command will take a long time to run, then it is a good candidate to run in the background.</p><p><br>The reason you would want to do this is that it frees up your shell for your to run other commands and do other tasks. When you run a command in the background, it is now a job.</p><p>The shell keeps track of it and assigns it a job number. You can even query this job number to check on the progress of the job.</p><p><br>You use the &lt;&amp;&gt; sign to indicate the current command is to run in the background. One thing I do a lot is update computers on my network. I have a script I wrote for this.</p><p><br> <code>updates.sh &amp;</code></p><p><br> This will run my script in the background as a job. I can do other things because it is going to take a long time. This makes it very useful.</p><p><br> To use an earlier example, you can do it with whatever you need to print.</p><p> </p><p><code>ls | lpr &amp;</code></p><p><br>Again, this throws the output of &lt;ls&gt; into the &lt;lpr&gt; print utility and prints everything in the background.</p><p>Commands can have options and arguments that you use after the command. These will modify the behavior of the command itself. When you enter a command it needs to listed in the path variable or you need to be in the current directory of the program.</p><p>You can chain commands through the use of pipelines. Pipelines use the &lt;|&gt; symbol. They take the output of the first command and send it to the input of the second command.</p><p>Commands can also be run in the background. This is another useful feature that will enhance your productivity. If there is a long task to run, start it and have it run in the background.</p><p>It will go away from sight but still be running. You can then use your shell to do other tasks like create new users or modify permissions on files.   </p><h2 id="mcetoc_1f9v9jt1i957" class="align-center"><span style="color: #236fa1;"><strong>Filtering Text In Linux</strong></span></h2><p>Filtering text allows you to do many efficient tasks in Linux. Displaying and sorting text is one of the most common tasks that you will do. This section is an introduction to filters in order to create pipelines for your workflow.</p><p id="mcetoc_1f9v9jt1i958" class="align-left" data-pm-slice="1 1 []"><span style="color: #169179;"><strong>Introduction</strong></span></p><p>Filtering text is the process of capturing text, doing something with it, and then sending it to the output stream. Most commonly, the output from one command is taken and redirected to the input of another command. This is usually accomplished through pipes and stream operators.</p><p id="mcetoc_1f9v9jt1i959" class="align-left"><span style="color: #169179;"><strong>Streams</strong></span></p><p>A stream is a series of data. There are input and output streams. Data flows both ways. Streams can be sent to a terminal, a file, or a network device. There are three main types:</p><ul><li>stdin</li><li>stdout</li><li>stderr</li></ul><p>The first, stdin, sends input to commands. Next, stdout, displays output from commands. Then, stderr, shows errors that were produced.</p><p id="mcetoc_1f9v9jt1i95a" class="align-left"><span style="color: #169179;"><strong>Pipes</strong></span></p><p>The pipe symbol, “|”, is one way to redirect output from one command to the input of another. Input can come from a command or a file. You can make a long sequence of commands using pipes. The output is usually shown in the terminal.</p><p id="mcetoc_1f9v9jt1i95b" class="align-left"><span style="color: #169179;"><strong>Output Redirection</strong></span></p><p>The operator, “&gt;”, can send output to a file. This is what you want to do if you need to save the results. Once you have data in a file, you have many more options. You can show the contents of a file, see any special characters associated with it, and split a file into two pieces.</p><p id="mcetoc_1f9v9jt1i95c" class="align-left"><span style="color: #169179;"><strong>The Cat Command</strong></span></p><p>The cat command can show the contents of a file and create files. By default, it reads from stdin unless you specify a file to read from.</p><p><code>echo -e "1 teamup\n2 unbroken_bonds\n3 unified_minds\n4 cosmic_eclipse" &gt; edition.txt</code></p><p><code>$ cat edition.txt</code><br><code>1 teamup</code><br><code>2 unbroken_bonds</code><br><code>3 unified_minds</code><br><code>4 cosmic_eclipse</code></p><p>In the first snippet we just sent some data to a text file that we created at the same time. Then we showed the contents of the file in the second snippet. This shows you how it works.</p><p>Let's make a second file now.</p><p><code>echo -e "1 breakpoint\n2 breakthrough\n3 ultra_prism\n4 celestial_storm" &gt; edition2.txt</code></p><p>Make sure the output is what we expect.</p><p><code>$ cat edition2.txt</code><br><code>1 breakpoint</code><br><code>2 breakthrough</code><br><code>3 ultra_prism</code><br><code>4 celestial_storm</code></p><p>The cat command also concatenates files. It just so happens that we have two files, ready for joining.</p><p><code>$ cat edition*</code></p><p>The asterisk is short for getting everything that has the partial name of "edition". </p><p><code>1 teamup</code><br><code>2 unbroken_bonds</code><br><code>3 unified_minds</code><br><code>4 cosmic_eclipse</code><br><code>1 breakpoint</code><br><code>2 breakthrough</code><br><code>3 ultra_prism</code><br><code>4 celestial_storm</code></p><p>This sends everything in those two files to the screen output. We can do something else cool, we can just make a third file with the contents of the first two.</p><p><code>$ cat edition.txt edition2.txt &gt; edition3.txt</code></p><p>This makes a third file that contains the contents of the first two.</p><p><code>$ cat edition3.txt</code><br><code>1 teamup</code><br><code>2 unbroken_bonds</code><br><code>3 unified_minds</code><br><code>4 cosmic_eclipse</code><br><code>1 breakpoint</code><br><code>2 breakthrough</code><br><code>3 ultra_prism</code><br><code>4 celestial_storm</code><br><br></p><p>That is really useful text manipulation. This also showcases the flexibility of the "cat" command.</p><p id="mcetoc_1f9v9jt1i95d" class="align-left"><span style="color: #169179;"><strong>Wordcount Command</strong></span></p><p>We can use this utility, "wc", to get more information from a file. This is handy if we know nothing about a file.</p><p><code>$ wc edition3.txt</code><br><code>  8  16 119 edition3.txt</code></p><p>We used this on the file we just created. It shows us the lines, words, and bytes in the file. It is very nice if you need to examine a file. The file may be thousands of lines long, you don't want all of that in your terminal output. If it is huge like that, you have another option.</p><p id="mcetoc_1f9v9jt1i95e" class="align-left"><span style="color: #169179;"><strong>Tail Command</strong></span></p><p>The tail command can show you the last lines of a file. By default, it shows you the last ten lines.</p><p><code>$ tail edition3.txt</code></p><p>My file is small but if it was large, that is the usage you would want to try first. </p><p id="mcetoc_1f9v9jt1i95f"><strong>Head Command</strong></p><p>The head command is the same as tail, except it shows you the first lines of a file. It is used in the same way. </p><h2 id="mcetoc_1i2s6qiqc4" class="align-center"><span style="color: #236fa1;"><strong>Working With Files</strong></span></h2><p>The following commands are what makes working with the command line worth it.<br>All of these tasks can be performed in a graphical environment, but when you get<br>used to the command line, they become much faster.<br><br><span style="color: #169179;"><strong>Wildcards</strong></span><br>Wildcards is one of the things that makes the command line so strong. They give<br>us a lot of flexibility. Wildcards allow you to select filenames based on<br>patterns of characters.<br>*     matches any characters<br>?     matches any single character<br>Using wildcards makes it possible to create complicated search queries. <br>*       all files<br>a*      any file begining with a<br>a*.txt  any file beginning with a followed by characters and ending with .txt<br>file??? any file beginning with the name file and followed by exactly 3<br>        characters.<br>Wildcards can be used with any command that accepts filenames as arguments.<br><br><span style="color: #169179;"><strong>Creating Directories</strong></span><br>The mkdir command is used to create directories.<br><code>mkdir directory-name</code><br>We can also make several directories at once.<br><code>mkdir name1 name2 name3 name4 name5</code><br><br><span style="color: #169179;"><strong>Copying Files</strong></span><br>The cp command is what we use to copy files or directories. <br><code>cp file1 file2</code><br>This copies the single file to another file.<br><code>cp -a file1 file2</code><br>The option -a copies a file with all of its attributes to another file.<br><code>cp -i file1 file2</code><br>The option -i will prompt the user for confirmation when overwriting a file.<br><code>cp -r folder1 folder2</code><br>The -r option will copy folders and all of their contents. <br><code>cp -u file1 file2</code><br>The -u option will only copy files that do not exist or are newer than the<br>existing correspondinf files in the destination directory.<br><code>cp -v folder1 folder2</code><br>The -v option will display extra information as copying is done.<br><br><span style="color: #169179;"><strong>Moving Files</strong></span><br>We move and rename files with the mv command. So, the mv command can be used in<br>multiple ways. <br><code>mv file1 file2</code><br>This will rename file1 to file2.<br><code>mv file1 folder1</code><br>When used like this, it moves file1 to folder 1. <br><code>mv -i file1 file1</code><br>The -i option will confirm you want to complete the action.<br><code>mv -u file1 file2</code><br>This will again only move files that do not exist or are newer than the files in<br>the destination folder.<br><code>mv -v file1 folder1</code><br>The -v will also give extra information when moving file1 to folder 1.<br><br><span style="color: #169179;"><strong>Removing Files</strong></span><br>The rm command is used to remove files and folders.<br><code>rm file1</code><br>That will remove a file.<br><code>rm -i file1</code><br>This will ask for confirmation because of the -i option.<br><code>rm -r folder1</code><br>This will remove a folder and all of its subdirectories. You must use this<br>option to delete folders. <br><code>rm -v file1</code><br>The -v gives extra information when performing this task.<br><br><span style="color: #169179;"><strong>Creating Links</strong></span><br>We create links using the ln command. Links can be either hard or soft. Hard<br>links are an older way of doing things, while soft links are the modern way. <br>This creates a hard link:<br><code>ln file link</code><br>This creates a soft link:<br><code>ln -s file link</code><br><code>ln -s folder link</code><br>As you can see, you cannot make a hard link of a folder or directory. That must<br>be done with a soft link. <br><br>Every file has a hard link associated with it. When a hard link is created, we<br>are making another way to refernce the file. Hard links cannot reference<br>anything outside its original file system. It also cannot reference a directory. <br><br>Soft links were made to overcome the limitations of hard links. When you create<br>a soft link, you are creating a unique file that contains a pointer to the<br>original file or directory. When you wrtie information to the soft link, the<br>original file is updated. So unless you go looking, it is hard to tell the<br>difference between the two. However, when you delete the link, the original file<br>is untouched. If the file is deleted first, the link stays but points to<br>nothing. </p><h2 id="mcetoc_1i5cbf0acbr" class="align-center"><span style="color: #236fa1;"><strong>Commands in Linux</strong></span></h2><p>In Linux, a command can be a program, something in the shell, a shell function,<br>and an alias. Programs are those in the /usr/bin directory. There can be many<br>different types.</p><p>Commands in the shell are built in to the shell. A shell<br>function is a small script that does something useful, hopefully. Aliases are<br>commands that we make ourselves, that come from other commands.<br><br><span style="color: #169179;"><strong>Type</strong></span><br>It can be useful to know what kind of command you are using. You can find out by<br>typing:</p><p><br><code>type free or</code><br><code>type dnf</code></p><p>You could get a different result for each command, depending on what you type.<br>The reason is, as mentioned above, there are a few different types of commands.<br>So, don't freak out when you see multiple types. <br><br><span style="color: #169179;"><strong>Which</strong></span><br>The which command gives you the location of an executable.</p><p> <br><code>which free</code></p><p>It only works for executable programs.<br><br><span style="color: #169179;"><strong>Documentation</strong></span><br>We can now get the documentation for a command. Use "help" for the built in<br>commands.</p><p><br><code>help cd</code></p><p>It will give a description of what the command does as well as options. Also,<br>when square brackets appear in the description of a command's syntax, they<br>indicate optional items. A vertical bar character indicates mutually exclusive<br>items. There is a help option after these commands, so you can get help either<br>way you like.</p><p><br><code>free --help</code></p><p>This gives you usage and options related to the command in question.<br><br><span style="color: #169179;"><strong>Man</strong></span><br>Most programs will have a manual page. It can be abbreviated as "man".</p><p><br><code>man free</code></p><p>This will give you almost everything related to the "free" command. Probably<br>more than you care to know, honestly. Just know it is available. Most do not<br>provide examples and are just a reference. <br><br><span style="color: #169179;"><strong>Apropos</strong></span><br>This will display appropriate commands related to a search term.</p><p> <br><code>apropos free</code></p><p>This will give different man pages that might be helpful. The first column is<br>the name of the man page and afterwards, a description. <br><br><span style="color: #169179;"><strong>Whatis</strong></span><br>This command will display one line manual page descriptions.</p><p><br><code>whatis dnf</code></p><p>It is a simplified view but can be useful.<br><br><span style="color: #169179;"><strong>Info</strong></span><br>This will display a program's info entry.</p><p> <br><code>info dnf</code></p><p>It gives you a lot of information but it is well formatted. It contains<br>hyperlinks to help you move around in the directory structure. use page up or<br>page down to move quickly. Hit enter with a hyperlink selected. Then, Q to quit<br>the info program.<br><br><span style="color: #169179;"><strong>Readme Files</strong></span><br>A lot of software packages that are installed on your system have documentation<br>files. These files are located in the /usr/share/doc directory. Most of these<br>are stored in text format and can be viewed with the less command. Some are also<br>in HTML format and can be viewed in a web browser. <br><br><span style="color: #169179;"><strong>Creating Aliases</strong></span><br>We can create our own commands, or aliases, for other commands and associated<br>options. The first thing we do is see if there is an alias for a command you are<br>thinking of. If I want to check for freem, for free memory, I would type:</p><p><br><code>type fr</code></p><p>It will say not found if it is available. So, you might use the same aliases on<br>every system you are on. Sometimes I can't remember what I have done on a<br>system, that is why it is useful to check. To make an alias:</p><p><br><code>alias fr='free -h'</code></p><p>As you can see, we aren't just making a shorter command to type less. We<br>included an option there too. We are typing a lot less when we do this command<br>several times a day. We can again use the type command and we can see our alias<br>now.</p><p> <br><code>type fr</code></p><p>You can see what we just did, which is cool! The aliases will go away when your<br>session ends, so remember that. We will go over how to make them permanent<br>later, which is very useful. </p><ul><li style="font-weight: 400;" aria-level="1"> </li></ul><h2 id="mcetoc_1i80ndtv0f" class="align-center"><span style="color: #236fa1;"><strong>Input and Output Redirection</strong></span></h2><p><span style="color: #169179;"><strong>Standard Input and Output</strong></span><br>Many of the programs we have used so far produce output of some kind. This<br>output consists of two types. The programs's results like when the data is<br>designed to produce something. It also produces status and error messages that<br>tell us about the program in question.<br><br>If we look at a command like ls, we can see that it displays its results and its<br>error messages on screen. Programs such as ls send their results to a special<br>file called standard output and their status messages to another file called<br>standard error. By default, both standard output and standard error are linked<br>to the screen and not saved into a disk file. In addition, many programs take<br>input from a facility called the standard input, which by default is attached to<br>the keyboard.<br><br>Input and output redirection allows us to change where output goes and where<br>input comes from. Normally, output goes to the screen and input comes from the<br>keyboard, but with redirection, we can change that.<br><br><span style="color: #169179;"><strong>Redirecting Output</strong></span><br>Redirection allows us to redefine where standard output goes. To redirect<br>standard output to another file instead of the screen, we use the redirection<br>operator "&gt;" followed by the name of the file. <br><br><code>ls -l /usr/bin &gt; ls-output.txt</code><br><br>Here, we created a long listing of the /usr/bin directoryt and sent the results<br>to the ls-output.txt file. If it is a long file we can use the less command:<br><br><code>less ls-output.txt</code><br><br>If we want to append information to the file instead of reqriting it, we use the<br>"&gt;&gt;" redirection operator.<br><br><code>ls -l /usr/bin &gt;&gt; ls-output.txt</code><br><br>Using the &gt;&gt; operator will result in the output being appended to the file. If<br>the file does not exist, it is created.<br><br><span style="color: #169179;"><strong>Redirecting Standard Error</strong></span><br>Redirecting standard error lacks the ease of a dedicated redirection operator.<br>To redirect standard error, we must refer to its file descriptor. A program can<br>produce output on any of several numbered file streams. While we have referred<br>to the first three of these file streams as standard input, output, and error,<br>the shell references them internally as file descriptors 0, 1, and 2. The shell<br>provides a notation for redirecting files using the file descriptor number.<br>Because standard error is number 2, we can redirect standard error like this:<br><br><code>ls -l /bin/usr 2&gt; ls-error.txt</code><br><br>The file descriptor 2 is placed immediately before the redirection operator to<br>perform the redirection of standard error to the file ls-error.txt. There are<br>cases in which we may want to capture all of the output of a command to a single<br>file. To do this, we must redirect both standard output and standard error at<br>the same time. <br><br><code>ls -l /usr/bin &gt; ls-output.txt 2&gt;&amp;1</code><br><br>Using this method, we perform two redirections. First we redirect standard<br>output and then we redirect file descriptor 2 to file descriptor 1 using the<br>notation 2&gt;&amp;1.<br><br>Sometimes, we do not want output from a command. This usually applies to error<br>and status messages. The system provides a way to do this by redirecting output<br>to a special file called /dev/null. This file is a system device often referred<br>to as a bit bucket, which accepts input and does nothing with it. <br><br><code>ls -l /usr/bin 2&gt; /dev/null</code><br><br>Redirecting Standard Input<br>Up to now, we have not encountered many commands that make use of standard<br>input. The "cat" command reads one or more files and copies them to standard<br>output.<br><br><code>cat filename</code><br><br>You can use it to display files without paging. <br><br><code>cat ls-output.txt</code><br><br>It is often used to display short text files. Because "cat" can accept more than<br>one file as an argument, it can also be used to join files together.<br><br><span style="color: #169179;"><strong>Pipelines</strong></span><br>The capability of commands to read data from standard input and send to standard<br>output is utilized by a shell feature called pipelines. Using the pipe operator<br>|, the standard output of one command can be piped into the standard input of<br>another.<br><br><code>ls -l /usr/bin | less</code><br><br>Using this technique, we can conveniently examine the output of any command that<br>produces standard output.<br><br>Pipelines are often used to perform complex operations on data. It is possible<br>to put several commands together into a pipeline. Frequently, the commands used<br>in this way are referred to as filters. Filters take input, change it, then<br>output it. <br><br><code>ls /bin /usr/bin | sort | less</code><br><br>Because we specified two directories, the output of ls would have consisted of<br>two sorted lists, one for each directory. By including sort in our pipeline, we<br>changed the data to produce a single sorted list.<br><br>The "uniq" command is often used in conjunction with "sort". It accepts a sorted<br>list of data from either standard input or a single filename argument then<br>removes any duplicates from the list. <br><br><code>ls /bin /usr/bin | sort |uniq | less</code><br><br>We use "uniq" to remove any duplicates from the output of the "sort" command. If<br>we want to see the list of duplicates, we add the "-d" option to "uniq".<br><br><code>ls /bin /usr/bin | sort | uniq -d | less</code><br><br>The "wc" command is used to display the number of lines, words, and bytes<br>contained in files.<br><br><code>wc ls-output.txt</code><br><br>In this case, it prints out three numbers: lines, words, and bytes. Like our<br>previous commands, if executed without command line arguments, "wc" accepts<br>standard input. The "-l" option limits its output to report only lines. Adding<br>it to a pipeline is a handy way to count things. To see the number of items we<br>have in our sorted list we can do this:<br><br><code>ls /bin /usr/bin | sort uniq | wc -l</code><br><br>The command "grep" is a powerful program used to find text patterns within<br>files. It is used like this:<br><br><code>grep pattern filename</code><br><br>When "grep" encounters a pattern in the file, it prints out the lines containing<br>it. The patterns that "grep" can match can be very complex. Suppose we wanted to<br>find all the files in our list of programs that had the word zip embedded in the<br>name. Such a search might give us an idea of some of the programs on our system<br>that had something to do with file compression.<br><br><code>ls /bin /usr/bin | sort | uniq | grep zip</code><br><br>There are a couple handy options for "grep".<br>The option "-i" causes "grep" to ignore case when performing the search.<br>the option "-v" tells "grep" to print only those lines that do not match the<br>pattern. <br><br>Sometimes, you do not want all the output from a command. You might want only<br>the first few lines or the last few lines. The "head" command prints the first<br>10 lines of a file, and the "tail" command prints the last 10 lines. By default,<br>both commands print 10 lines of text, but this can be adjusted with the "-n"<br>option.<br><br><code>head -n 5 ls-output.txt</code><br><br>The "tail" command operates the same way:<br><br><code>tail -n 5 ls-output.txt</code><br><br>The "tail" command also has an option to let you view files in real time. This<br>is useful for watching the progress of files as they are being written. <br><br><code>tail -f /var/log/messages</code><br><br>Using the "-f" option, "tail" continues to monitor the file, and when new lines<br>are appended, they immediately appear on the display. This continues until you<br>type "ctrl-c".<br><br>The "tee" command reads standard input and copies it to both standard output and<br>to one or more files. This is useful for capturing a pipeline's contents at an<br>intermediate stage of processing. <br><br><code>ls /usr/bin | tee ls.txt | grep zip</code><br><br>As always, check out the documentation of each of the commands we have covered.<br>We have seen only the most basic usage but have a number of interesting options.<br>You will see that the redirection feature of the command line is very useful for<br>solving specialized problems.</p><h2 id="mcetoc_1i8tnrhk0p" class="align-center"><span style="color: #236fa1;"><strong>Permissions</strong></span></h2><div><strong>Ownership of Files</strong></div><div>Sometimes, when we try to access a file, we do not have permission to do so.</div><div>This can be a read or write permission, for example. In Unix and Linux, a user</div><div>may own files and directories. When a user owns a file or directory, the user</div><div>has control over its access. Users can belong to a group consisting of one or</div><div>more users who are given access to files and directories by their owners. In</div><div>addition to granting access to a group, an owner may also grant some set of</div><div>access rights to everybody. To find out details about yourself on the system,</div><div>use the "id" command.</div><div> </div><div><code>id</code></div><div> </div><div>When user accounts are created, users are assigned a number called a user ID,</div><div>which is then mapped to a username. The user is assigned a group ID and may</div><div>belong to other groups. </div><div> </div><div>This information comes from certain text files in Linux. User accounts are</div><div>defined in the /etc/passwd file, and groups are defined in the /etc/group file.</div><div>When user accounts and groups are created, these files are modified along with</div><div>/etc/shadow, which holds information about the user's password. </div><div> </div><div>For each user account, the /etc/passwd file defines the user login name, user</div><div>ID, group ID, and account's real name, home directory, and login shell. When we</div><div>look at the contents of /etc/passwd and /etc/group, we see that besides the</div><div>regular user accounts, there are accounts for the superuser and other system</div><div>users.</div><div> </div><div><span style="color: #169179;"><strong>Reading, Writing, and Executing</strong></span></div><div>Access rights to files and directories are defined in terms of read access,</div><div>write access, and execution access. If we look at the output of the ls command,</div><div>we can get some clue as to how this is implemented.</div><div> </div><div><code>ls</code></div><div> </div><div>The first 10 characters of the listing are the file attributes. The first of</div><div>these characters is the file type. </div><div> </div><ul><li>- a     regular file</li><li>d       a directory</li><li>l        a symbolic link</li><li>c       a character special file</li><li>b       a block special file</li></ul><div> </div><div>The remaining 9 characters of the file attributes, called the file mode,</div><div>represent the read, write, and execute permissions for the file's owner, the</div><div>file's group owner, and everyone else.</div><div> </div><ul><li>r     allows a file to be opened and read</li><li>w    allows a file to be written to</li><li>x     allows a file to be treated as a program and executed</li></ul><div> </div><div><span style="color: #169179;"><strong>Change File Mode</strong></span></div><div>To change the mode or permission of a file or directory, use the "chmod"</div><div>command. Only the file's owner or the superuser can change the mode of a file or</div><div>directory. This command supports two distinct ways of specifying mode changes.</div><div>They are octal number representation and symbolic representation.</div><div> </div><div>We will cover octal number representation first. With octal notation, we use</div><div>octal numbers to set the pattern of desired permissions. Because each digit in</div><div>an octal number represents 3 binary digit, this maps nicely to the scheme used</div><div>to store the file mode. By using 3 octal digits, we can set the file mode for</div><div>the owner, group owner, and everyone else.</div><div> </div><div><code>chmod 600 example.txt</code></div><div> </div><div>By passing the argument 600, we were able to set the permissions of the owner to</div><div>read and write while removing all permissions from the group owner and everyone</div><div>else. Though remembering the octal to binary mapping may seem inconvenient, you</div><div>will usually have to use only a few common ones.</div><ul><li>7     rwx</li><li>6     rw</li><li>5     r-x</li><li>4     r--</li><li>0     ---</li></ul><div> </div><div>Chmod also supports a symbolic notation for specifying file modes. Symbolic</div><div>notation is divided into 3 parts.</div><div>who the change will affect</div><div>which operation will be performed</div><div>what permission will be set</div><div>To specify who is affected, a combination of the characters u,g,o, and a is</div><div>used.</div><div> </div><ul><li>u     file or directory owner</li><li>g     group owner</li><li>o     everyone else</li><li>a     all, short for u,g, and o</li></ul><div> </div><div>If no character is specified, all will be assumed. The operation may be a+</div><div>indicating that a permission is to be added, a- indicating that a permission is</div><div>to be taken away, or  a= indicating that only the specified permissions are to</div><div>be applied and that all others are to be removed.</div><div> </div><div>Some people prefer to use octal notation and some like the symbolic. Symbolic</div><div>notation does offer the advantage of allowing you to set a single attribute</div><div>without disturbing any of the others.</div><div> </div><div><span style="color: #169179;"><strong>Setting Umask</strong></span></div><div>The umask command controls the default permissions given to a file when it is</div><div>created. It uses octal notation to express a mask of bits to be removed from a</div><div>file's mode attrributes.</div><div> </div><div>When we set the mask to 0000 we are turning it off. This makes a file writable</div><div>by anyone.</div><div> </div><div><span style="color: #169179;"><strong>Changing Identities</strong></span></div><div>Sometimes, we need to become another user. This is often done to test an account</div><div>or figure out what is wrong for a certain user. We can log in as the user, use</div><div>the "su" command in the terminal, or use the "sudo" command in the terminal.</div><div>These all do things differently. The "su" command allows you to assume the</div><div>identity of another user and either start a new shell session with that user's</div><div>ID or issue a single command as that user.</div><div> </div><div>The "sudo" command allows an administrator to set up a configuration file called</div><div>/etc/sudoers and define specific commands that particular users are permitted to</div><div>execute under an assumed identity. This means the administrator can configure</div><div>"sudo" to allow an ordinary user to execute commands as a different user in a</div><div>controlled way. A user may be restricted to one or more specific commands and no</div><div>others. An important difference is that the use of "sudo" does not require</div><div>access to the superuser's password. </div><div> </div><div><span style="color: #169179;"><strong>Changing Passwords</strong></span></div><div>To set or change a password, use the "passwd" command.</div><div> </div><div><code>passwd username</code></div><div> </div><div>To change your password, just enter the "passwd" command. You will be prompted</div><div>for your old password and then your new password. The command will try to</div><div>enforce the use of strong passwords. This means it will refuse to accept</div><div>passwords that are too short or are too similar to previous passwords, are</div><div>dictionary words, or are too easily guessed.</div><div> </div><div>If you have superuser privileges, you can specify a username as an argument to</div><div>the "passwd" command to set the password for another user. Other options are</div><div>available to the superuser to allow locking, password expiration, and other</div><div>things. </div><h2 id="mcetoc_1i9aekmko6" class="align-center"><span style="color: #236fa1;"><strong>Processes</strong></span></h2><p><span style="color: #169179;"><strong>Intro</strong></span><br>Prcoesses are how Linux organizes the different programs waiting for their turn<br>at the cpu.<br><br><span style="color: #169179;"><strong>How processes Work</strong></span><br>When a system starts up, the kernel initiates a few of its own activities as<br>processes and lauches a program called init. It runs a series of shell scripts<br>(located in /etc) called init scripts, which start all the system services. Many<br>of these services are implemented as daemon programs, programs that just sit in<br>the background and do their thing without having any user interface. So, even if<br>we are not logged in, the system is at least a little busy performing routine<br>stuff.<br><br>The fact that a program can launch other programs is expressed in the process<br>scheme as a parent process producing a child process. The kernel maintains<br>information about each process to help keep things organized. For example, each<br>process is assigned a number called a process ID. PID's are assigned in<br>descending order, with init always getting PID 1. The kernel also keeps track of<br>the memory assigned to each process, as well as the processes' readiness to<br>resume execution. Like files, processes also have owners and user IDs, effective<br>user IDs, and so on.<br><br><span style="color: #169179;"><strong>Viewing Processes</strong></span><br>The most commonly used command to view processes is 'ps'. The 'ps' program has a<br>lot of options but it is used like this:<br><br><code>ps</code><br><br>The result in this example lists two processes, which are bash and ps. As we can<br>see, ps does not show us very much, just the processes associated with the<br>current terminal session. To see more, we need to add some options. <br><br>If we add an option, we can get a bigger picture of what the system is doing.<br><br><code>ps x</code><br><br>Adding the x option tells ps to show all of our processes regardless of what<br>terminal they are controlled by. The presence of a ? in the TTY column indicates<br>no controlling terminal. Using this option, we see a list of every process that<br>we own.<br><br>Because the system is running a lot of processes, ps produces a long list. It is<br>often helpful to pipe the output from ps to less for easier viewing. Some option<br>combinations also produce long lines of output, so maximizing the terminal<br>emulator window might be a good idea too.<br><br><span style="color: #169179;"><strong>Processor States</strong></span><br>R       Running<br>S       Sleeping<br>D       Uninterruptible sleep<br>T       Stopped<br>Z       Defunct or zombie process<br>&lt;       High priority process<br>N       Low priority process<br><br>The process state may be followed by other characters. These indicate various<br>exotic process characteristics. Another popular set of options is aux. This<br>gives us even more information. <br><br><code>ps aux</code><br><br>This set of options displays the processes belonging to every user. Using the<br>options without the leading dash invokes the command with BSD style behavior.<br>The linux version of ps can emulate the behavior of the ps program found in<br>different unix implementations.<br><br><span style="color: #169179;"><strong>Viewing Processes Dynamically</strong></span><br>While the ps command can reveal a lot about what the machine is doing, it<br>provides only a snapshot of the machine's state at the moment the ps command is<br>executed. To see a more dynamic view of the machine's activity, we use the top<br>command.<br><br><code>top</code><br><br>The top program displays a continuously updating display of the system processes<br>listed in order of process activity. The name top comes from the fact that the<br>top program is used to see the top processes of the system. The top display<br>consists of two parts, a system summary at the top of the display, followed by a<br>table of processes sorted by cpu activity. <br><br>The top program accepts a number of keyboard commands. The two most interesting are h, which displays the program's help screen, and q, which quits top. <br><br>Both major desktop environments provide graphical applications that display<br>information similar to top, but top is better than the graphical versions<br>because it is faster and it consumes far fewer system resources. After all, our<br>system monitor program should not be the source of the system slowdown that we<br>are trying to track.<br><br><span style="color: #169179;"><strong>Controlling Processes</strong></span><br>Now that we can see and monitor processes, let us gain some control over them.<br>Type gedit to open that program. Now type control-c to interrupt the program. It<br>should close. Most command line programs can be closed in this way. <br><br>If we want the shell program back on top but still want another program to run,<br>we can put it into the background. To launch a program so that it is immediately<br>placed in the background, we follow the command with a &amp; character.<br><br><code>gedit &amp;</code><br><br>After entering the command, the window appeared and the shell prompt returned. A message will appear which is a shell feature called job control. With this<br>message, the shell is telling us we have started a job number and what its PID<br>is. If we then run ps, we can see this process.<br><br>The shell's job control facility also gives us a way to list the jobs that have<br>been launched from our terminal. Using the jobs command, we can see this list.<br><br><code>jobs</code><br><br>This shows us a list of the current jobs running.<br><br><span style="color: #169179;"><strong>Returning a Process to the Foreground</strong></span><br>A process in the background is immune from terminal keyboard input, including<br>any attempt to interrupt it with control-c. To return a process to the<br>foreground, use the fg command:<br><br><code>// run jobs command to get the job number of process you want</code><br><code>jobs</code><br><code>// then use the job number with the fg command</code><br><code>fg %1    // 1 is the job number we want to bring to foreground</code><br><br>The fg command followed by a percent sign and then job number is how you use it. If we have only one background, the job number is optional.<br><br><span style="color: #169179;"><strong>Stopping A Process</strong></span><br>Sometimes we will want to stop a process without terminating it. This is the<br>same as pausing it. This is often done to allow a foreground process to be moved<br>to the background. To stop a foreground process and place it in the background,<br>press control-z.<br><br>After stopping the process, we can verify that the program has stopped by trying<br>to use it. It will not work. We can either continue the program's execution in<br>the background, using the fg command, or resume the program's execution in the<br>background with the bg command. <br><br><code>bg %1</code><br><br>As with the fg command, the job number is optional if there is only one job.<br>Moving a process from the foreground to the background is handy if we launch a<br>graphical program from the command line but forget to place it in the background<br>by appending the trailing &amp;.<br><br>There are two reasons why we would want to launch a graphical program from the<br>command line. The program you want to run might not be listed on the window<br>manager's menu. By launching a program from the command line, you might be able<br>to see error messages that would otherwise be invisible if the program were<br>launched graphically. <br><br>Sometimes, a program will fail to start up when launched from the graphical<br>menu. By launching it from the command line instead, we may see an error message<br>that will reveal the problem. Also, some graphical programs have interesting and<br>useful command line options.<br><br><span style="color: #169179;"><strong>Signals</strong></span><br>The kill command is used to kill processes. This allows us to terminate programs<br>that need killing.<br><br><code>kill 16606</code><br><br>We get the process ID from one of the ways mentioned before, then use that ID<br>with the kill command. We could have also used a job number if we wanted to go<br>that route. <br><br>While this is straightforward, there is more to it than that. The kill command<br>does not exactly kill processes, it sends them signals. Signals are one of<br>several ways that the operating system communicates with programs. We have<br>already seen signals in action with the use of control-c and control-z.<br><br>When the terminal receives one of these keystrokes, it sends a signal to the<br>program in the foreground. In the case of control-c, a signal called INT<br>(interrupt) is sent. Programs, in turn, listen for signals and may act upon them<br>as they are received. The fact that a program can listen and act upon signals<br>allows a program to do things such as save work in progress when it is sent a<br>terminating signal.<br><br><span style="color: #169179;"><strong>Sending Signals to Processes</strong></span><br>The kill command is used to send signals to programs. Its most common syntax is<br>this:<br><br><code>kill -signal (PID)</code><br><br>If no signal is specified on the command line, then the terminate signal is sent<br>by default. <br><br>1        hup        hang up<br>2        int        interrupt<br>9        kill    kill<br>15        term    terminate<br>18        cont    continue<br>19        stop    stop<br>20        tstp    terminal stop<br><br><code>kill -1 16606</code><br><br>In this example,  sent the process a hup singal with the kill command. It<br>terminates and the shell indicates that the background process has received a<br>hang up signal. We may need to press enter a couple of times before the message<br>appears. Note that the signal may be specified either by number or by name.<br><br><span style="color: #169179;"><strong>Sending Signals to Multiple Processes</strong></span><br>It is also possible to send signals to multiple processes matching a specified<br>program or username by using the killall command.<br><br><code>killall -u user -signal name</code><br><br>To demonstrate, we will start a couple of instances of programs and terminate<br>them.<br><br><code>killall gedit</code><br><br>As with the kill command, you must have superuser privileges to send kill<br>signals to processes that do not belong to you.<br><br><span style="color: #169179;"><strong>Shutting Down the System</strong></span><br>The process of shutting down the system involves the orderly termination of all<br>the processes on the system, as well as performing some vital housekeeping<br>chores before the system powers off. Four different commands can perform this<br>function.<br><br>halt<br>poweroff<br>reboot<br>shutdown<br><br>The first three are self explanatory and are generally used without any command<br>line options. The shutdown command is more interesting. With it, we can specify<br>which of the actions to perform and provide a time delay to the shutdown event.<br>Most often it is used like this to halt the system:<br><br><code>shutdown -h now</code><br><br>We can also use it like this:<br><br><code>shutdown -r now</code><br><br>The delay can be specified in a variety of ways. Once the shutdown command is<br>executed, a message is broadcast to all logged in users warning them of the<br>impending event. Because monitoring processes is an important system<br>administration task, there are a lot of commands for it.<br><br>pstree        outputs a process list arranged in a tree like pattern<br>vmstat        outputs a snapshot of system resource usage<br>xload        graphical program that draws a graph showing system load over time<br>tload        same as xload but draws the graph in the terminal<br><br>Most modern systems feature a mechanism for managing multiple processes. Linux provides a rich set of tools for this purpose. Unlike other systems, Linux<br>relies primarily on command line tools for process management. Though there are<br>graphical process tools for Linux, the command line tools are greatly preferred<br>because of their speed and light footprint.</p><h2 id="mcetoc_1i9k2jfo56" class="align-center"><span style="color: #236fa1;"><strong>Environment Variables</strong></span></h2><p>The shell holds information about our session and this is called the<br>environment. Programs use this information to determine our system<br>configuration. Many programs will use configuration files to store program data<br>but they will also look to the environment.<br><br><span style="color: #169179;"><strong>Information in the Environment</strong></span><br>The shell stores two basic types of data in the environment, environment<br>variables and shell variables. Shell variables are bits of data placed there by<br>bash and environment variables are everything else. In addition to variables,<br>the shell stores some programmatic data like aliases and shell functions.<br><br>To see what is stored in the environment, we can use either the set builtin in<br>bash or the 'printenv' program. The set command will show both the shell and<br>environment variables, while 'printenv' will display only the latter. Because<br>the list of environment contents will be fairly long, it is best to pipe the<br>output of either command into less.<br><br><code>printenv | less</code><br><br>What we see is a list of environment variables and their values. For example, we<br>see a variable called user, which contains the value 'me'. The 'printenv'<br>command can also list the value of a specific variable.<br><br><code>printenv user</code><br><br>The set command, when used without options or arguments, will display both the<br>shell and environment variables, as well as any defined shell functions. Unlike<br>'printenv', its output is nicely sorted in alphabetical order.<br><br><code>set | less</code><br><br>It is also possible to view the contents of a variable using the echo command:<br><br><code>echo $HOME</code><br><br>One element of the environment that neither 'set' nor 'printenv' displays is<br>aliases. To see them, enter the alias command without arguments.<br><br><code>alias</code><br><br>You will see all the defined aliases in your environment.<br><br>The environment contains quite a few variables, and though the environment will<br>differ from system to sytem, we will likely see the most common variables.<br><br><strong>Environment</strong><br>When we log on to the system, the bash program starts and reads a series of<br>configuration scripts called startup files, which define the default environment<br>shared by all users. This is followed by more startup files in our home<br>directory that define our personal environment. The exact sequence depends on<br>the type of shell session being started. There are two kinds.<br><br>There is a login shell session. This is one in which we are prompted for our<br>username and password. This happens when we start a virtual console session, for<br>example. There is also a non-login shell session. This typically occurs when we<br>launch a terminal session in the GUI. login shells read one or more startup</p><p>files:<br><br>/etc/profile<br>~/bash.login<br>~/.profile<br><br></p><p>Non-login shell sessions read these startup files:</p><p><br>/etc/bash.bashrc</p><p>~/.bashrc</p><p>In addition to reading the startup files, non-login shells inherit the<br>environment from their parent process, usually a login shell. Take a look and<br>see which of these startup files are installed. Most are hidden so we will need<br>to use the '-a' option when using the 'ls' command. <br><br>The ~/.bashrc file is probably the most important startup file from the ordinary<br>user's point of view, because it is almost always read. non-login shells read it<br>by default, and most startup files for login shells are written in such a way as<br>to read the ~/.bashrc file as well.<br><br><span style="color: #169179;"><strong>Startup Files</strong></span><br>Lines that begin with a # are comments and are not read by the shell. These are<br>there for human readability. The first interesting thing occurs below:<br><br><code>if [-f ~/.bashrc]; then</code><br><code>    . ~/.bashrc</code><br><code>fi</code><br><br>This is called an 'if' compound command. It is saying that fi there is a<br>~/.bashrc file then read it. <br><br>We can see that this bit of code is how a login shell gets the contents of<br>.bashrc. The next thing in the startup file has to do with the 'path' variable.<br>The 'path' variable tells the shell where to find commands when we enter them on<br>the command line. The 'path' variable is often set by the /etc/profile startup<br>file with this code:<br><br><code>PATH=$PATH:HOME/bin</code><br><br>PATH is modified to add the directory $HOME/bin to the end of the list. Many<br>distributions provide this PATH setting by default. <br><br>We also have this command to 'export' our path.<br><br><code>export PATH</code><br><br>The export command tells the shell where the startup files are and what they<br>contain, we can modify them to customize our environment.<br><br><span style="color: #169179;"><strong>Modifying the Environment</strong></span><br>Because we know where the startup files are and what they contain, we can modify<br>them to customize our environment. As a general rule, to add directories to your<br>PATH or define additional environment variables, place those changes in<br>.bash_profile. For everything else, place the changes in .bashrc.<br><br>Unless you are the system administrator and need to change the defaults for all<br>users of the system, restrict your modifications to the files in your home<br>directory. It is certainly possible to change the files system wide but it is<br>safer to not do so.<br><br><span style="color: #169179;"><strong>Text Editors</strong></span><br>To edit the shell's startup files, as well as most of the other configuration<br>files on the system, we use a program called a text editor. A text editor is a<br>program that allows us to edit words on the screen. It differs from a word<br>processor by only supporting pure text and often contains features designed for<br>writing programs. Text editors are the central tool used by software developers<br>to write code and by system administrators to manage the configuration files<br>that control the system.<br><br>A lot of different text editors are available for linux so most systems have a<br>few installed by default. Text editors fall into two basic categories, graphical<br>and text-based. <br><br>There are many text-based editors. The popular ones we will encounter are nano,<br>vi, and emacs. The nano editor is a simple easy to use editor designed as a<br>replacement for the pico editor. The vi editor has mostly been replaced by vim,<br>is the traditional editor for unix and linux systems. The emacs editor is an<br>all-purpose programming environment installed on most linux systems by default. <br><br><span style="color: #169179;"><strong>Using a Text Editor</strong></span><br>Text editors can be invoked from the command line by typing the name of the<br>editor followed by the name of the file you want toe dit. If the file does not<br>already exist, the editor will assume that we want to create a new file.<br><br><code>vim filename</code><br><br>This command will start the vim editor and load the file named 'filename'.<br><br>Graphical text editors are pretty self-explanatory, think word processor but<br>just for plain text. Programmers do not want a word processor because it would<br>not work well for programming and could mess up configuration files with its<br>formatting of text. <br><br><span style="color: #169179;"><strong>Comments in Files</strong></span><br>Whenever you modify configuration files, it is a good idea to add comments to<br>document your changes. shell scripts and bash startup files use a # symbol to<br>begin a comment. Other configuration files could use a different symbol but they<br>do the same thing. <br><br>You will often see lines in configuration files that are commented out to<br>prevent them from being used by the affected program. This is done to give the<br>reader suggestions for possible configuration choices or examples of correct<br>configuration syntax. <br><br><span style="color: #169179;"><strong>Activating Our Changes</strong></span><br>The changes we have made to our .bashrc or other configuration files will not<br>take effect until we close our terminal session and start a new one because the<br>.bashrc file is read only at the beginning of a session. however, we can force<br>bash to reread the modified .bashrc file with the following command:<br><br><code>source ~/.bashrc</code><br><br>After doign this, we should be able to see the effect of our changes.</p><h2 id="mcetoc_1iam684qlm" class="align-center"><span style="color: #236fa1;"><strong>Intro To Vim</strong></span></h2><div>Why should you learn Vim? Vim is on almost every Linux system. When you have to</div><div>be on different Linux systems regularly, it is by far the best thing to do. Vim</div><div>is also just powerful and will do just about anything a developer or writer</div><div>would want it to do. I do not switch systems very much and I still prefer it</div><div>over word processors and other editors. However, everyone's situation is</div><div>different and sometimes it just makes sense to use something else for your</div><div>workflow.</div><div> </div><div>Vim is very lightweight and fast. These are attributes that I value in an</div><div>editor. I do not want a piece of software that is so large it makes a noticeable</div><div>dent in my drive space. Those word processors and editors are much slower too. I</div><div>want speed. I want to be able to do things as fast as I can think or type it.</div><div>That is one of the advantages of Vim.</div><div> </div><div>Of course, every developer and writer will have particular needs. I write my</div><div>articles using Vim and a couple of features I want is distraction free writing</div><div>and highlighting the paragraph I am in. Vim has plugins that do just that. So I</div><div>installed those 2. That's it. I did not have to put up with 40 other features I</div><div>do not want in order to use Vim. That makes Vim flexible and extensible. I can</div><div>modify it for whatever writing purpose I need and nothing more. It stays fast</div><div>and small, just the way I like software.</div><div> </div><div><span style="color: #169179;"><strong>Opening Vim</strong></span></div><div>To open Vim, we just go to our command line and type:</div><div> </div><div><code>vim</code></div><div> </div><div>This will give us our opening Vim page with how to access help and other things.</div><div>The next thing to know about Vim is that it is a modal editor. This means it has</div><div>different modes to work in. Command mode is where you start at. Insert mode lets</div><div>enter in text. There is also visual and other modes. We will get to those</div><div>eventually.</div><div> </div><div>To close Vim, we type :q and then press enter.</div><div> </div><div><code>:q then press enter</code></div><div> </div><div>Since we have not typed anything, we can just exit like this. Now, let us open a</div><div>new file, type some stuff, and save. Type from the command line:</div><div> </div><div><code>vim sample.py</code></div><div> </div><div>You will get a blank screen. You start in command mode. To enter in text, we</div><div>must get to insert mode. Type:</div><div> </div><div><code>i then press enter</code></div><div> </div><div>Now you will notice you can type text. Also, at the bottom left of your screen,</div><div>you will see the mode indicated --insert--. This will let you know what mode you</div><div>are in. If you do not see anything listed there, you are in command mode. </div><div> </div><div>So type some text, it does not matter what at this point. We are just learning.</div><div>Now, here is an important part to remember. To exit any mode, hit the escape</div><div>button to go back to command mode. Then you will hit :w then press enter to save</div><div>your document.</div><div> </div><div><code>escape</code></div><div><code>:w then press enter</code></div><div> </div><div>You can also type :q after that to quit or you can do it at the same time.</div><div> </div><div><code>escape</code></div><div><code>:w </code></div><div><code>then</code></div><div><code>:q</code></div><div><code>Or </code></div><div><code>escape</code></div><div><code>:wq</code></div><div> </div><div>Vim has many options and you can learn them as needed but this will get you</div><div>started.</div><div> </div><div><span style="color: #169179;"><strong>Moving Around Files</strong></span></div><div>While in command mode, Vim lets you use certain keys to quickly move around your</div><div>document. This is important when your document or configuration file is large.</div><div>You will appreciate it then. It is much faster than using the mouse to move</div><div>around or scroll with. </div><div> </div><div> </div><ul><li>l right one character</li><li>h left one character</li><li>j down one line</li><li>k up one line</li><li>0 go to beginning of current line</li><li>$ go to end of current line</li><li>^ go to first non-whitespace character on current line</li><li>w go to the beginning of the next word</li><li>b go to beginning of previous word</li><li>ctrl-F down one page</li><li>ctrl-B up one page</li></ul><div> </div><div> </div><div>For more fun, most of these commands can be prefixed with a number to indicate</div><div>how many times a certain command is to be carried out. Try that to see how it</div><div>works. </div><div> </div><div>So, now that we know some of the basics, let's think about editing. Most editing</div><div>consists of inserting text, deleting text, and moving text to different places</div><div>in your document. </div><div> </div><div>If you press 'u' while in command mode, vim will undo the last change that you</div><div>made. </div><div> </div><div><code>u  - undo last change you made</code></div><div> </div><div>This will come in handy as we try some of the basic editing commands. </div><div> </div><div>Vim has several different ways of entering insert mode. We have already used the</div><div>'i' command to insert text. If we wanted to add some text to the end of a</div><div>sentence, we would use the 'a' command. If we move the cursor to the end of the</div><div>line and type 'a', the cursor will move past the end of the line and vim will</div><div>enter insert mode. This will allow us to add some more text.</div><div> </div><div>move cursor to end of line</div><div>press 'a'</div><div>enter more text</div><div> </div><div>Remember to press the 'esc' key to exit insert mode. Because we will almost</div><div>always want to append text to the end of a line, vim offers a shortcut to move</div><div>to the end of the current line and start appending. It is the 'A' command. This</div><div>moves your cursor to the end of the line and automatically puts you in insert</div><div>mode.</div><div> </div><div>We can also insert text by opening a line. This inserts a blank line between two</div><div>existing lines and enters insert mode. </div><div> </div><div><code>o - opens a line below the current line</code></div><div><code>O - opens a line above the current line</code></div><div> </div><div>Vim also offers a variety of ways to delete text. The 'x' command will delete a</div><div>character at the cursor location. It may be preceded by a number specifying how</div><div>many characters are to be deleted.</div><div> </div><div>The 'd' command is more general purpose. Like 'x', it may be preceded by a</div><div>number specifying the number of times the deletion is to be performed. In</div><div>addition, 'd' is always followed by a movement command that controls the size of</div><div>the deletion.</div><div> </div><ul><li>x current character</li><li>3x the current character and the next two characters</li><li>dd the current line</li><li>5dd the current line and the next four lines</li><li>dw from the current cursor position to the beginning of the next word</li><li>d$ current cursor location to the end of the current line</li><li>d0 current cursor location to the beginning of the line</li><li>d^ current cursor location to the first non-whitespace character</li><li>dG current line to the end of the line</li><li>d20G current line to the 20th line of the file</li></ul><div> </div><div> </div><div>The 'd' command not only deletes text, it also cuts text. Each time we use the</div><div>'d' command, the deletion is copied into a paste buffer that we can later recall</div><div>with the 'p' command to paste the contents of the buffer either before or after</div><div>the cursor.</div><div> </div><div>The 'y' command is used to yank or copy text in much the same way the 'd'</div><div>command is used to cut text. </div><div> </div><ul><li>yy current line</li><li>5yy current line and the next 4 lines</li><li>yW from current cursor position to beginning of next word</li><li>y$ from current cursor location to end of the current line</li><li>y0 from current cursor location to beginning of the line</li><li>y^ from current cursor location to first non-whitespace character in line</li><li>yG from current line to the end of the line</li><li>y20G from current line to the 20th line of the file</li></ul><div> </div><div> </div><div>Vim is rather strict about its idea of a line. Normally, it is not possible to</div><div>move the cursor to the end of a line and delete the end of line character to</div><div>join one line with the one below it. Because of this, vim provides a specific</div><div>command, 'J', to join lines together.</div><div> </div><div>Vim also has the capability to move the cursor to locations based on searches.</div><div>It can do this either on a single line or over an entire file. It can also</div><div>perform text replacements with or without confirmation from the user.</div><div> </div><div>The 'f' command searches a line and moves the cursor to the next instance of a</div><div>specified character. For example, the command 'fa' would move the cursor to the</div><div>next occurrence of the character 'a' within the current line. After performing a</div><div>character search within the line, the search may be repeated by typing a</div><div>semicolon.</div><div> </div><div>To move the cursor to the next occurrence of a word or phrase, the '/' command</div><div>is used. This works the same way as we learned earlier in the 'less' program.</div><div>When you type the '/' command, a '/' will appear at the bottom of the screen.</div><div>Next, type the word or phrase to be searched for, followed by the 'enter' key.</div><div>The cursor will move to the next location containing the search string. A search</div><div>may be repeated using the previous search string with the 'n' command.</div><div> </div><div>Vim uses an 'ex' command to perform search and replace operations over a range</div><div>of lines or the entire file. To change the word Line to line for the entire</div><div>file, we would enter the following command:</div><div> </div><div><code>:%s/Line/line/g</code></div><div> </div><div>: colon character starts an 'ex' command</div><div>% specifies the range of lines for the operation</div><div>s specifies the operation, search and replace</div><div>g means global in the sense that the search and replace is performed on</div><div>ever instance of the search string in the line.</div><div> </div><div>It is often useful to edit more than one file at a time. You might need to make</div><div>changes to multiple files, or you might need to copy content from one file into</div><div>another. With vim, we can open multiple files for editing by specifying them on</div><div>the command line.</div><div> </div><div>To switch from one file to the next, use this 'ex' command:</div><div> </div><div><code>:bn</code></div><div> </div><div>To move back to the previous file:</div><div> </div><div><code>:bp</code></div><div> </div><div>While we can move from one file to another, vim enforces a policy that prevents</div><div>us from switching files if the current file has unsaved changes. To force vim to</div><div>switch files and abandon your changes, add an exclamation point to the command.</div><div> </div><div>In addition to the switching method already described, vim provides some</div><div>'ex' commands that make multiple files easier to manage. We can view a list of</div><div>files being edited with the :buffers command. Doing so will display a list of</div><div>the files at the bottom of the display. </div><div> </div><div><code>:buffers</code></div><div> </div><div>To switch to another file type, :buffer followed by the number of the buffer you</div><div>want to edit. For example, to switch from buffer 1 containing a file to buffer</div><div>2 containing another file, we would type this:</div><div> </div><div><code>:buffer 2</code></div><div> </div><div>Our screen now displays the second file. Another way we can change buffers is to</div><div>use the :bn and :bp commands mentioned earlier.</div><div> </div><div>It is also possible to add files to our current session. The 'ex' command ':e',</div><div>short for edit, followed by a filename will open an additional file. Let us end</div><div>our current editing session and return to the command line.</div><div> </div><div><code>:e sample.py</code></div><div> </div><div>Often while editing multiple files, we will want to copy a portion of one file</div><div>into another file that we are editing. This is easily done using the usual yank</div><div>and paste commands we used earlier. </div><div> </div><div>It is also possible to insert an entire file into one we are editing. To see</div><div>this in action, let us end our vim session and start a new one with just a</div><div>single file.</div><div> </div><div><code>vim sample.py</code></div><div> </div><div>The :r command inserts the specified file below the cursor position. </div><div> </div><div>Like everything else in vim, there are several different ways to save our edited</div><div>files. We have already covered the ex command :w but there are some others we</div><div>may also find useful. In command mode, 'zz' will save the current file and exit</div><div>vim. Likewise, the ex command :wq will combine the :w and :q commands into one</div><div>that will both save the file and exit. </div><div> </div><div>The :w command may also specify an optional filename. This acts like save as.</div><div> </div><h2 id="mcetoc_1ib7v7d3ie" class="align-center"><span style="color: #236fa1;"><strong>Customizing Your Prompt</strong></span></h2><p><span style="color: #169179;"><strong>Adjusting Your Prompt</strong></span><br>The shell prompt can be greatly configured. It can be very useful to learn about<br>it and that will be the purpose of this section. The default prompt will contain<br>information such as our username, hostname, and current working directory. The<br>prompt is defined by an environment variable named "PS1". We can view the<br>contents of "PS1" with the echo command. <br><br><code>echo $PS1</code><br><br>From the results, we can see that "PS1" contains a few of the characters we see<br>in our prompt such as the brackets, the at-sign, and the dollar sign, but the<br>rest are a mystery. <br><br>With this list of special characters, we can change the prompt to see the<br>effect. We can back up the existing prompt string so we can restore it later. To<br>do this, we will copy the existing string into another shell variable that we<br>create ourselves.<br><br><code>ps1_old="PS1"</code><br><br>We create a new variable called ps1_old and assign the value of PS1 to it. We<br>can verify that the string has been copied by using the echo command.<br><br><code>echo $ps1_old</code><br><br>We can restore the original prompt at any time during our terminal session by<br>simply reversing the process. <br><br><code>PS1="ps1_old"</code><br><br>Now that we are ready to proceed, let us see what happens if we have an empty<br>prompt string.<br><br><code>PS1=</code><br><br>If we assign nothing to the prompt string, we get nothing. No prompt string at<br>all. The prompt is still there but displays nothing, just as we asked it to do.<br>We can replace it with a minimal prompt.<br><br><code>PS1="\$ "</code><br><br>Notice the trailing space within the double quotes. This provides the space<br>between the dollar sign and the cursor when the prompt is displayed. <br><br><code>PS1="\A \h \$ "</code><br><br>Adding time of day is useful if we need to keep up track of when we do things.<br>Now this prompt is similar to what we started with.<br><br><code>PS1="&lt;\u!\h \W&gt;\$ "</code><br><br><span style="color: #169179;"><strong>Colors</strong></span><br>Most terminal emulator programs respond to certain non-printing character<br>sequences to control such things as character attributes and cursor position. <br><br>Character color is controlled by sending the terminal emulator an ANSI code<br>embedded in the stream of characters to be displayed. The control code does not<br>print out on the display, it is interpreted by the terminal as an instruction.<br>An ANSI escape code begins with an octal 033, escape key, followed by an<br>optional character attribute, followed by an instruction. For example, the code<br>to set the text color to normal black text is:<br><br><code>\033[0;30m</code><br><br>The following table lists the available colors.<br><br>\033[0;30m    black    <br>\033[0;31m    red<br>\033[0;32m    green<br>\033[0;33m    brown<br>\033[0;34m    blue<br>\033[0;35m    purple<br>\033[0;36m    cyan<br>\033[0;37m    light gray<br>\033[1;30m    dark gray<br>\033[1;31m    light red<br>\033[1;32m    light green<br>\033[1;33m    yellow<br>\033[1;34m    light blue<br>\033[1;35m    light purple<br>\033[1;36m    light cyan<br>\033[1;37m    white<br><br>We can also set the background color. <br><br>\033[0;40m    black<br>\033[0;41m    red<br>\033[0;42m    green<br>\033[0;43m    brown<br>\033[0;44m    blue<br>\033[0;45m    purple<br>\033[0;46m    cyan<br>\033[0;47m    light gray<br><br>We can create a prompt with a red background:<br><br><code>PS1="\[\033[0;41m\]&lt;\u@\h \W&gt;\$\[\033[0m\] "</code><br><br><br>Besides the normal(0) and bold(1) attributes, text may be given underscore(4),<br>blinking(5), and inverse(7) attributes. However, some terminal emulators refuse<br>to honor the blinking attribute. <br><br><span style="color: #169179;"><strong>Moving the Cursor</strong></span><br>Escape codes can be used to position the cursor. This is commonly used to<br>provide a clock or some other kind of information at a different location on the<br>screen, such as in an upper corner each time the prompt is drawn.</p><p>\033[1;cH    move the cursor to line 1 at column c<br>\033[nA        move the cursor up n lines<br>\033[nB        move the cursor down n lines<br>\033[nC        move the cursor forward n characters<br>\033[nD        move the cursor backward n characters<br>\033[2J        clear the screen and move cursor to upper-left corner<br>\033[K        clear from the cursor position to end of the current line<br>\033[s        store the current cursor position<br>\033[u        recall the stored cursor position<br><br></p><p>Obviously, we do not want to be typing these control codes in all the time so we<br>need to store our prompt to make it easier. We can make the prompt permanent by<br>adding it to our .bashrc file. To do so, add your prompt that you like followed<br>by "export PS1" and then save the file. </p><h2 id="mcetoc_1ilrsbqka1o" class="align-center"><span style="color: #236fa1;"><strong>Managing Software</strong></span></h2><p>Software is managed in Linux through its package management system. Each<br>distribution has a different system. They are each different in ways but<br>basically do the same things. Software is released in packages that your<br>package management system can work with. It can download, update, and other cool<br>things. <br><br>Learning to use your package management system is a great advantage to the Linux<br>user. It allows you to do much more, if you want to, than using a graphical<br>counterpart. By the way, a package from one system will not be compatible with<br>another system. The Debian and Red Hat systems are the most popular but there<br>are many other good systems associated with their distributions.<br><br>Almost all of the software can be found on a distribution's website. They are<br>very clear about what they have and what they do not. These bits of software are<br>in the form of packages. These packages are compressed and can contain many<br>different programs. One or more people create these packages for you to download<br>and they maintain it also. <br><br>Packages live in repositories. These repositories are holding bins for software.<br>They contain all the software for the distribution. Their dependencies are kept<br>in a similar manner. These shared resources are used by many programs and vital<br>to a distribution. Package management systems install these dependencies and<br>related packages any time you are trying to install a piece of software.<br><br>Now, in any particular distribution there can be multiple tools for installing<br>and updating software. I like using Fedora because it has a lot of nice features<br>and I like the software that comes with it. Fedora, for example, uses "rpm" for<br>installing package files and "dnf" for installing dependencies. The tools are<br>different for every distribution. <br><br><code>dnf search terminal</code><br><br>This command will search repositories for packages related to the search term<br>"terminal". You can then install anything that looks appealing.<br><br><code>dnf search neovim</code><br><br>Again, this searches for anything related to the neovim editor. Use it this way<br>to see what is out there for tools that you like to use. I use the neovim editor<br>so am always looking for other cool things to try with it.<br><br>To install packages that you like, use the "install" option.<br><br><code>dnf install neovim</code><br><br>This installs neovim and any dependencies that it needs. <br><br>If you already have a package file on your computer, you can just install it<br>directly. Use the "rpm" command for this.<br><br><code>rpm -i neovim.rpm</code><br><br>This will install your package assuming you had a package named "neovim" already<br>downloaded on your computer. <br><br>You can uninstall packages just as easy.<br><br><code>dnf remove neovim</code><br><br>However, the most common task is to update our software. Do it like this:<br><br><code>dnf update -y</code><br><br>We can directly update package files.<br><br><code>rpm -u neovim.rpm</code><br><br>To see all the packages on a system:<br><br><code>rpm -qa</code><br><br>We might have packages on our computer that are not installed. We can see if a<br>particular package is installed by using:<br><br><code>rpm -q neovim.rpm</code><br><br>This command lets you know if a package named "neovim.rpm" is installed or not. <br><br>You can see information on any particular package:<br><br><code>dnf info neovim</code><br><br>We can also see what package installed any particular file on your system:<br><br><code>rpm -qf neovim</code><br><br>You might have to supply paths to some of these commands. It will depend on<br>where you are in your own system and the distribution you are using. Just<br>something to keep in mind.</p><h2 id="mcetoc_1io9e0qg015" class="align-center"><span style="color: #236fa1;"><strong>Managing Storage Devices</strong></span></h2><p>Working with storage devices is important in Linux. It is much easier than it<br>used to be. There are some good commands that make storage easy and fun. The<br>first step is to attach the device to our file system. This is called mounting<br>the device to our file system and allows the device to talk to our operating<br>system. Linux has a single file system tree for all its devices. Windows<br>differs in that it has a separate tree for every device. As long as you<br>understand that difference, working with devices in Linux should be a breeze.<br><br>The "fstab" file contains a list of the devices that are supposed to be mounted<br>when your system boots. "Fstab" stands for file system table. We can use the<br>"mount" command to see what is currently mounted on your system.<br><br><code>mount</code><br><br>We can unmount a device when needed. It could be a USB drive or something<br>similar. Be careful what you unmount. Make sure it is supposed to be. Get the<br>name after running the mount command. When you find it, type:<br><br><code>unmount /dev/sda</code><br><br>We can mount a new device just as easily. It is done by first creating a new<br>mount point. This can be anywhere on the file system tree. The easiest way is to<br>create a directory just for this device.<br><br><code>mkdir /mnt/new-device</code><br><br>We can mount our "sda" device at this new mount point.<br><br><code>mount /dev/sda /mnt/new-device</code><br><br>Part of working with storage devices is knowing how to create new file systems.<br>This is done on system drives as well as USB drives. So, knowing how to do it is<br>helpful. The fist thing to do is unmount the drive if it is currently attached<br>to your system. Use a USB drive for this while learning so you don't destroy your<br>system.<br><br><code>unmount /dev/xda</code><br><br>You will get the name of your USB device from the "mount" command.<br>Now we will use the "fdisk" command to create partitions on our USB device.<br><br><code>fdisk /dev/xda</code><br><br>Enter an "m" for the program menu. You will see several options. In fact, a<br>whole chapter could be on just how to use this command. It does a lot. Now we<br>type p:<br><br>p<br><br>This option will print the partition table. Look at the code under the ID field<br>and remember it just in case. <br>Now we want to go back to the menu and find out what the Linux ID is. <br>Use the "l" option that says "list known partition types".<br>See what the Linux ID is.<br>Now we want to use the "t" option to change a partition's system ID.<br>We put in the previously found code for Linux.<br>Finally, we write the modified partition table to the device and exit. Use "w":<br><br>w<br><br>We have now changed the partition type on our USB. The next step is to create a<br>new file system that will work on our USB. We use the "mkfs" command. It stands<br>for make file system. <br><br><code>mkfs -t ext4 /dev/xda1</code><br><br>I chose the "ext4" file system but there are others. That is something else for<br>another chapter it seems.<br><br>Anytime you want to test a device, there is a command built for that. Run on the<br>device of your choice.<br><br><code>fsck /dev/xda1</code><br><br>It will show you the status of your device or drive. It is good to run this<br>every once in a while. Every six months to a year I would say for a start.<br>Adjust as necessary.<br><br>Since we have been working with storage, we need a way to transfer data and<br>clone devices. Thankfully, Linux has a tool made for this. It is the "dd" tool.<br>It is used like this:<br><br><code>dd if=input-file of=output-file</code><br><br>If I had two USB devices named "xda1" and "xda2" and I wanted to copy xda1 to<br>xda2 then I would do this:<br><br><code>dd if=/dev/xda1 of=/dev/xda2</code><br><br>We can also use this command to copy data to a file.<br><br><code>dd if=/dev/xda1 of=USB-backup</code></p><h2 id="mcetoc_1iq6p7ei129" class="align-center"><br><span style="color: #236fa1;"><strong>Networking</strong></span></h2><p>Knowing how networking works is a vital skill today. You do not have to be a master but some basic knowledge goes a long way. Knowing what an IP address is, for example, helps you in many ways.<br><br>The ping command is where most tutorials start at and for good reason. It is the most basic and easiest to use. What it does is send an "icmp echo_request" to a specific host. This is a special type of network packet. The host, or most other network devices, will reply back and verify the connection. As an admin, you can block ping requests  on the host or firewall side if you do not want this traffic. Let us try some examples:<br><br><code>ping aindien.com</code><br><br>It pings my website until I stop it with ctrl-z. The IP address you see is where you are sending from. The other important bit is the time it takes. That is the last field. This makes ping a useful way to see if a website is responding as it should. <br><br>The next command we will discuss is traceroute. It lists all the destinations from the origin until it reaches its destination. <br><br><code>traceroute aindien.com</code><br><br>After running this, you will see several lines. These are stops along the way,<br>usually routers. This is also useful for diagnostics. If you are having trouble<br>reaching a certain site, such as google.com, then do a traceroute with that<br>name. The destination where it drops off at will tell you where the problem is.<br>This also shows that it isn't your equipment at fault. You can examine each line<br>and see that some of the routers provide information about themselves, such as who they are. <br><br>The next utility is ip. It can do many things and give you a lot of information. With ip, we can see a system's net work interfaces and routing table. <br><br><code>ip a</code><br><br>When running this command, we can see our network interfaces. We have a loopback device which is what the system uses to talk to itself and an ethernet device. They are probably labeled differently on each system. Look to see that your devices are enabled. <br><br><code>ip addr show</code><br><br>This will show your addresses for all devices. <br>To see the ip address of a particular device then use this:<br><br><code>ip addr show dev eth0</code><br><br>You can see information about your devices by using:<br><br><code>ip link show</code><br><br>To see information about a certain interface use:<br><br><code>ip link show dev eth0</code><br><br>To see the routing:<br><br><code>ip route</code><br><br>For looking in depth at your network, the netstat command is the one to use. It<br>can show settings and statistics. With its various options, you can look closely<br>at your interfaces should you need to. <br><br><code>netstat -ie</code><br><br>This set of options shows your interfaces and all their glory details. Notice<br>the hardware and ip addresses, both very useful details. <br><br>We can also see our routing table. This is how the network is configured. <br><br><code>netstat -r</code><br><br>That shows some nice information if you know what you are looking at. <br><br>To see which ports are waiting for a connection use:<br><br><code>netstat -l</code><br><br>To see all listening server sockets use:<br><br><code>netstat -lt</code><br><br>To see all listening udp ports use:<br><br><code>netstat -lu</code><br><br>To see network statistics use:<br><br><code>netstat -s</code><br><br>The netstat command can do a lot more also.<br><br>Another very interesting command is wget. It downloads files and can use http or<br>ftp protocols. It can also download entire websites. <br><br><code>wget https://aindien.com/downloads/fedora.iso</code><br><br>This would download a single file named fedora.iso, assuming it exists and in<br>that location. <br><br><code>wget --input urls.txt</code><br><br>This will download multiple urls that are included in the text file.<br><br><code>wget --execute robots=off --recursive --no-parent --continue --no-clobber</code><br><code>https://example.com</code><br><br>The above command will mirror an entire site.<br>There are many more options and things you can do with wget. It is very<br>versatile.<br><br>The next command I want to talk about is ssh. It is used to connect to remote<br>systems. It will do so securely. We just have to set it up and configure it<br>properly. It does this authenticating and encrypting traffic. The ssh protocol<br>consists of a server and a client. <br><br>The server listens for connection on port 22 of the remote server. The client is on the local system where you are. You can change the port number to something else to make it more secure. It will be in the ssh config file. For a system to receive remote connections, the ssh server program must be running. <br><br>To connect to a remote system, assuming we have permission, use:<br><br><code>ssh example.com</code><br><br>Type yes when given the option. Then enter your password. The admin of the<br>remote host will give you the password. If it is also your machine, you will<br>have to configure that part. </p><h2 id="mcetoc_1h4km0vek1o" class="align-center"><span style="color: #236fa1;"><strong>Rsync</strong></span></h2><p><span style="font-weight: 400;">Rsync stands for remote synchronization and it transfers and syncs files. It can do this locally and remotely. It is a very good tool. Though it has a learning curve, it is not hard to pick up. Its main use is to copy files and directories between two different computers. It can look at files and only send what has been changed. It can preserve all kinds of links and metadata.   </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"> </span></p><p class="align-left"><span style="color: #169179;"><strong>Installing Rsync  </strong><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"> </span></p><p><span style="font-weight: 400;">If you do not already have it installed on your system, you will need to install it. I am running Fedora. If you are running another distribution, use whatever package manager you have to install it.</span></p><p> </p><p><span style="font-weight: 400;">On Fedora run:</span></p><p><code><span style="font-weight: 400;">dnf update -y</span></code></p><p> </p><p><span style="font-weight: 400;">This will update your files. Then:</span></p><p><code><span style="font-weight: 400;">dnf install rsync -y</span></code></p><p> </p><p><span style="font-weight: 400;">This will install rsync to your system if it is not already there.</span></p><p> </p><p><span style="font-weight: 400;">Now run:</span></p><p><code><span style="font-weight: 400;">which rsync</span></code></p><p> </p><p><span style="font-weight: 400;">This will show you where it is installed on your system</span></p><p><span style="font-weight: 400;">Then run:</span></p><p><code><span style="font-weight: 400;">rsync –version</span></code></p><p> </p><p><span style="font-weight: 400;">That shows you the version you have.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Files</strong></span></p><p><span style="font-weight: 400;">Copying files is really easy. It is:</span></p><p> </p><p><code><span style="font-weight: 400;">rsync -v </span><span style="font-weight: 400;"></span><span style="font-weight: 400;">source </span><span style="font-weight: 400;"></span><span style="font-weight: 400;">destination</span></code></p><p> </p><p><span style="font-weight: 400;">The -v option means output will be given verbosely</span></p><p><span style="font-weight: 400;">Source is the full path of the source file unless you are in its directory already.</span></p><p><span style="font-weight: 400;">Destination should be the full path unless it is in your current path too.</span></p><p><span style="font-weight: 400;">It looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">rsync -v program1.cpp Documents</span></code></p><p> </p><p><span style="font-weight: 400;">In the above example I was already in the directory of the file I wanted to copy. You should do that when you can. I transferred it to the Documents folder.</span></p><p><span style="font-weight: 400;">Another example that is slightly different:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/documents /home/jason/Writing/</span></code></p><p> </p><p><span style="font-weight: 400;">This command copies all the files in Documents to my Writing folder.</span></p><p><span style="font-weight: 400;">You can use the ls command to look and make sure everything is transferred as expected.</span></p><p> </p><p><code><span style="font-weight: 400;">Ls Writing/</span></code></p><p> </p><p><span style="font-weight: 400;">There are many reasons to make copies of your files. Backing up important files to another remote location is something we should all do more.</span></p><p> </p><p><span style="font-weight: 400;">Whenever you do a file transfer, it is a good idea to switch to that location and make sure it is copied over. Doing this a few times will instill confidence in your command line abilities.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>The Trailing /</strong></span></p><p><span style="font-weight: 400;">The trailing slash at the end of a path dictates whether rsync will copy the contents of a directory or the entire directory with the folder included. Excluding the / from the source path copies the directory to the source destination.</span></p><p> </p><p><span style="font-weight: 400;"># This command will copy the Writing directory and its contents to the backup drive</span></p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/Writing /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;"># This command will only copy the files in the Writing directory to the backup drive.</span></p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/Writing/ /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">This is a small difference but it is very important to get right.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Contents of Directories</strong></span></p><p><span style="font-weight: 400;">It is often very useful to copy entire directories at once. It is easy to do this. Use:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av     /source/     /destination/</span></code></p><p> </p><p><span style="font-weight: 400;">Just use the full paths of the source and destination</span></p><p><span style="font-weight: 400;">So, something like this should get the job done:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Documents/ /home/jason/Backup/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directories to other Directories</strong></span></p><p><span style="font-weight: 400;">If we want to copy a folder to another folder then we do this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Documents /home/jason/Backup/</span></code></p><p> </p><p><span style="font-weight: 400;">You should look inside the directory to make sure you typed the command over correctly. You should see the folder nested in there.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying A File Remotely</strong></span></p><p><span style="font-weight: 400;">Rsync lets you connect to different machines. This makes copying files to other machines an easy practice. You will need:</span></p><ol><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">File path from local machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">IP address of remote machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">File path on remote machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Root access to remote machine</span></li></ol><p><span style="font-weight: 400;">The command will look something like this depending on what you need to do:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -v /path/from/local/machine     root@123.45.56.678:/root/remote/path</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directory To Another Drive</strong></span></p><p><span style="font-weight: 400;">This is very handy and gives you better protection. It is also easy to implement. </span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Writing /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">As usual, go and look to make sure everything happened the way you expect. After a while, you will not feel the need to do this.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directories Remotely</strong></span></p><p><span style="font-weight: 400;">Rsync can handle remote directories just as easily as single files. When you run this command, you will be asked for its password. So, be prepared on this front. The command looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av   /local/path   root@123.45.56.678:/root/remote/path/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Compressing Files</strong></span></p><p><span style="font-weight: 400;">Rsync can compress files that it tries to transfer. This will speed up a transfer. If your transfer is very small, you will not see a difference. However, if you are doing lots of video, for example, this will be of great benefit. Do it like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/video /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;">This command will copy the Video folder over to my backup drive.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Monitoring Your Progress</strong></span></p><p><span style="font-weight: 400;">If we are doing a long transfer, we can monitor the progress. I like statistics so this is useful for me. The command looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avz –info=progress2  /home/jason/Video /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;">This will give you the results of your transfer.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Syncing Directories</strong></span></p><p><span style="font-weight: 400;">Syncing directories is easily done. Keep in mind that sometimes files will be deleted and they will be gone. So, use this command after careful consideration. We use the –delete option with the regular command plus source and destination paths. This will look at the source directory and then make the destination directory match it. It looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -aP –delete /home/jason/Writing/ /path/BackupDrive/Writing/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Excluding Files and Directories</strong></span></p><p><span style="font-weight: 400;">Rsync can easily look the other way during a command if you want it to. So, if I want to exclude a subfolder of my Writing folder, it will do that. Here is how.</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avzP –exclude=Algebra /home/jason/Writing /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">We can also exclude files from a transfer or sync operation. If I want to exclude .mp3 files it looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avzP –exclude=*.mp3 /home/jason/Music/ /path/BackupDrive</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Options</strong></span></p><ul><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-a = –archive mode and equal to several other flags at once. It tells rsync to sync recursively,transfer special and block devices, preserve symbolic links,modification times, groups, ownership, and permissions</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-z = –compress. This option compresses the data that is sent to the destination machine.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-P = –partial and –progress. Using this option shows a progress bar during the transfer and keeps track of partially transferred files.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">–delete. When you use this option, it will delete extra files from the destination folder that are not in the source folder. It is how you mirror directories.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-q or –quiet. Use this when you don’t want to see error messages</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-e. Use this when you want to choose the remote shell to use</span></li></ul></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on July 26, 2025</p><ul class="post__tag"><li><a href="https://aindien.com/linux/">Linux</a></li></ul><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Faindien.com%2Flinux-essentials-.html" class="js-share facebook" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/share?url=https%3A%2F%2Faindien.com%2Flinux-essentials-.html&amp;via=_Aindien&amp;text=Learning%20the%20Linux%20Operating%20System" class="js-share twitter" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span></a></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://aindien.com/authors/jason-moore/" class="invert" rel="author">Jason Moore</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://aindien.com/powershell-essentials.html" class="invert post__nav-link" rel="prev"><span>Previous</span> Powershell Explained</a></div><div class="post__nav-next"><a href="https://aindien.com/r-essentials.html" class="invert post__nav-link" rel="next"><span>Next</span> R Programming Explained </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2023-12-27T13:09" class="feed__date">December 27, 2023</time></div><h3 class="h1"><a href="https://aindien.com/windows-essentials.html" class="invert">Learning the Windows Operating System</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2020-08-04T22:58" class="feed__date">August 4, 2020</time></div><h3 class="h1"><a href="https://aindien.com/networking-essentials.html" class="invert">Learning TCP/IP Networking</a></h3></article></div></div><div class="banner banner--after-post"><div class="wrapper"><link href="//cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel="stylesheet" type="text/css"><style type="text/css">#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
	/* Add your own Mailchimp form style overrides in your site stylesheet or in this style block.
	   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */</style><div id="mc_embed_signup"><form action="https://aindien.us11.list-manage.com/subscribe/post?u=5aefa50c3a5900492b165a83f&amp;id=1c348b805a" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate><div id="mc_embed_signup_scroll"><h2>Subscribe</h2><div class="indicates-required"><span class="asterisk">*</span> indicates required</div><div class="mc-field-group"><label for="mce-EMAIL">Email Address <span class="asterisk">*</span></label> <input type="email" name="EMAIL" class="required email" id="mce-EMAIL"></div><div class="mc-field-group"><label for="mce-FNAME">First Name</label> <input type="text" name="FNAME" id="mce-FNAME"></div><div class="mc-field-group"><label for="mce-LNAME">Last Name</label> <input type="text" name="LNAME" id="mce-LNAME"></div><div id="mce-responses" class="clear"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5aefa50c3a5900492b165a83f_1c348b805a" tabindex="-1"></div><div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div></div></form></div><script type="text/javascript" src="//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js"></script><script type="text/javascript">(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';}(jQuery));var $mcj = jQuery.noConflict(true);</script></div></div></main><footer class="footer"><div class="footer__copyright"><p>Jason Moore 2022</p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://aindien.com/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>