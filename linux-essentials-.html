<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux Explained - Jason&#x27;s Computing Guides</title><meta name="description" content="Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://aindien.com/linux-essentials-.html"><link rel="alternate" type="application/atom+xml" href="https://aindien.com/feed.xml"><link rel="alternate" type="application/json" href="https://aindien.com/feed.json"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://aindien.com/assets/css/style.css?v=166a31b4480c68773db8a06507216db7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://aindien.com/linux-essentials-.html"},"headline":"Linux Explained","datePublished":"2021-07-05T22:23","dateModified":"2024-09-17T14:30","image":{"@type":"ImageObject","url":"https://aindien.com/media/posts/53/linux-0.jpg","height":3000,"width":3000},"description":"Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you.","author":{"@type":"Person","name":"Jason Moore","url":"https://aindien.com/authors/jason-moore/"},"publisher":{"@type":"Organization","name":"Jason Moore"}}</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-393JFJ482L"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-393JFJ482L');</script><script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/5aefa50c3a5900492b165a83f/93dcd5a76da18d3becc7e677f.js");</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://aindien.com/">Jason&#x27;s Computing Guides</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://aindien.com/about-me.html" target="_self">Andromeda</a></li><li><a href="https://aindien.com/python-basics.html" target="_self">Python</a></li><li class="active"><a href="https://aindien.com/linux-essentials-.html" target="_self">Linux</a></li><li><a href="https://aindien.com/getting-started-with-git.html" target="_self">Git</a></li><li><a href="https://aindien.com/networking-essentials.html" target="_self">Networking</a></li><li><a href="https://aindien.com/r-essentials.html" target="_self">R</a></li><li><a href="https://aindien.com/c-essentials.html" target="_self">C++</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://aindien.com/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://aindien.com/media/posts/53/linux-0.jpg" srcset="https://aindien.com/media/posts/53/responsive/linux-0-xs.jpg 300w, https://aindien.com/media/posts/53/responsive/linux-0-sm.jpg 480w, https://aindien.com/media/posts/53/responsive/linux-0-md.jpg 768w, https://aindien.com/media/posts/53/responsive/linux-0-lg.jpg 1024w, https://aindien.com/media/posts/53/responsive/linux-0-xl.jpg 1360w, https://aindien.com/media/posts/53/responsive/linux-0-2xl.jpg 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="3000" width="3000" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2021-07-05T22:23">July 5, 2021</time></div><h1>Linux Explained</h1><div class="post__meta post__meta--author"><a href="https://aindien.com/authors/jason-moore/" class="feed__author invert">Jason Moore</a></div></div></header></div><div class="wrapper post__entry"><p>Linux is the alternative to Windows. While it is free and opensource, the main attraction to Linux is that it doesn't track you.</p><p><a target="_blank" href="https://amzn.to/3y97zia" rel="noopener">Samsung Store on Amazon! If you buy something, I get a small commission and that makes it easier to keep on writing. Thank you in advance if you buy something.</a></p><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1f9st1def88s">Introduction To Linux</a></li><li><a href="#mcetoc_1f9sus8jj8cu">Things To Know Before You Install Linux</a></li><li><a href="#mcetoc_1hu4eo8ea3">Exploring Your Linux System</a></li><li><a href="#mcetoc_1hipjg8uvng">Using The Shell In Linux </a></li><li><a href="#mcetoc_1f9sus8jj8cv">Doing More With The Shell</a></li><li><a href="#mcetoc_1f9v9jt1i957">Filtering Text In Linux</a></li><li><a href="#mcetoc_1i2s6qiqc4">Working With Files</a></li><li><a href="#mcetoc_1i5cbf0acbr">Commands in Linux</a></li><li><a href="#mcetoc_1h4km0vek1o">Rsync</a></li><li><a href="#mcetoc_1i80ndtv0f">Input and Output Redirection</a></li></ul></div><h2 id="mcetoc_1f9st1def88s" class="align-center"><span style="color: #236fa1;"><strong>Introduction To Linux</strong></span></h2><p>Linux is a direct descendant of the Unix operating system. Unix was created by government researchers who needed some custom tools. It spread to universities and students popularized it greatly.</p><p>Berkeley also played an important part because they modified it extensively. This became known as BSD, the Berkeley Software Distribution. At the same time there was also Unix System V, which came from the version maintained by Bell Labs.</p><p id="mcetoc_1eim2v6td1" class="align-left"><span style="color: #169179;"><strong>Linus Torvalds</strong></span></p><p>Torvalds was a Finnish student in the early 90s. He was working on the core of that would be the Linux kernel as we know it. After it was finished, he combined it with the GNU operating system for the applications.</p><p>Linux the name comes from the combination of Linus and Unix.</p><p id="mcetoc_1eim2vdh32" class="align-left"><span style="color: #169179;"><strong>Distributions</strong></span></p><p>Neither a kernel nor applications make a complete operating system. So putting them together was a must. It just so happened that different parties each the separate part ready. Others have since as well.</p><p>The combination of a kernel and related packages that run on that system are known as a distribution. There are hundreds of distributions today.</p><p>They include development systems, word processing, spreadsheet software, music players, and many other nice utilities. Fedora, Opensuse, and Ubuntu are great ones to get started with.</p><p id="mcetoc_1eim2vkp23" class="align-left"><span style="color: #169179;"><strong>Software</strong></span></p><p>There are tons of nice packages available for Linux systems today. Most are free, but you can buy some also that will include extras like nice support built in. Graphics tools, web servers, and networking utilities are some of the most popular packages.</p><p id="mcetoc_1eim2vqpr4" class="align-left"><span style="color: #169179;"><strong>Supported Platforms</strong></span></p><p>Almost everything today will run Linux. Intel, Mac, IBM, and Arm based computers all run Linux and does so very well. In fact, Linux is only getting more popular.</p><p id="mcetoc_1eim300dg5" class="align-left"><span style="color: #169179;"><strong>Portability</strong></span></p><p>Originally, Unix messed this part up because vendors made versions all for themselves. So the market was very fragmented. However, Linux was written most in the &lt;C&gt; language.</p><p>This allowed it to be portable between other systems. Doing so allowed it to spread much quicker than Unix ever could.</p><p>Now, Linux is used everywhere and for any type of system.</p><p id="mcetoc_1eim3081a6" class="align-left"><span style="color: #169179;"><strong>The Kernel</strong></span></p><p>The kernel’s job is to distribute the computer’s resources. The resources of a computer are things like cpu and memory. Peripherals need access to these items as well, so the kernel will make sure each one gets what it needs.</p><p>Software will request resources through system calls. The kernel then gives the software what it needs.</p><p id="mcetoc_1eim30dqk7" class="align-left"><span style="color: #169179;"><strong>Multiuser Support</strong></span></p><p>A Linux system is designed to have many users on one computer. This gives them each their own little area of the operating system and storage. This makes cost a lot less. In fact, this was often done to save money.</p><p>An organization could have one nice machine and dumb terminals to access located anywhere in the building. It is probably still a good idea if you think about it. Another advantage to this is that it makes the machine more cost efficient.</p><p>No one can use all of a machine’s resources constantly. So if one person is using it then most of the resources are going unused. This goes hand in hand with the task system.</p><p>Since Linux is designed to handle multiple users, it can also handle many concurrent tasks at the same time too. This means that each user can run many processes at the same time.</p><p id="mcetoc_1eim30lce8" class="align-left"><span style="color: #169179;"><strong>Bash And Other Shells</strong></span></p><p>A shell is a command interpreter. This is just an interface to the core of the operating system. It allows you to run commands and have them act instantly. It is a very powerful concept.</p><p>Bash is the most popular shell, but there are many other ones. Some are older, but there are newer ones too. Each user on a machine can use his own shell if that is his preference. This allows for nice customization.</p><p id="mcetoc_1eim30qqj9" class="align-left"><span style="color: #169179;"><strong>Desktops</strong></span></p><p>Originally, computers were mostly used with shells. This involved users issuing commands as needed on a machine. They could do calculations, manage a server or use a text editor.</p><p>Eventually, however, a GUI was created, and these were the first desktops. When I say desktop, I am referring to the graphical system that lets you do the same tasks as a shell.</p><p>The Gnome, Cinnamon, and KDE desktop environments are some of the most popular today. They each have a very different style, but they are also fun to learn. They are fun because each has its own advantages.</p><p>Today, you can even get desktops with certain spins built in to them. A spin means they come with certain software packages that do a certain role.</p><p>For example, I could download an Astronomy spin that would include many types of Astronomy software. That is a really cool feature, by the way.</p><p id="mcetoc_1eim314h5a" class="align-left"><span style="color: #169179;"><strong>Utilities</strong></span></p><p>Linux comes with many types of useful programs called utilities. These all do some unique task and do it very well. These are the basis behind the commands that you use in a terminal window.</p><p>I can check the speed of my system, disk space, free memory, cpu usage by process and the list could go on and on.</p><p id="mcetoc_1eim31c4rb" class="align-left"><span style="color: #169179;"><strong>Application Development</strong></span></p><p>This is one of my favorite features. Almost every distribution has program development built in to its core. Compilers and interpreters are there. Several text editors are there too. Support for several languages comes right out of the box.</p><p>You can start with C++ or C immediately after an install. In one distribution I have, a very nice Python pdf book is even included along with its support of course. Many times an IDE is also included if you prefer that kind of workflow.</p><p>Whole books have been written about the history and usage of Linux. It is very rich in history and you can spend a lifetime learning useful things that you can with these Linux essentials.</p><p>Did I mention it is free and has the best computing community in the world? While it came from Unix, it has far surpassed its digital parent. There is a distribution for everyone.</p><p>It does everything and more that a Windows and Mac computer can do. This is because 99% of the software is free and easily installed.</p><h2 id="mcetoc_1f9sus8jj8cu" class="align-center"><span style="color: #236fa1;"><strong>Things To Know Before You Install Linux</strong></span></h2><p>Installing Linux is not difficult, but there are some details you should be aware of. You don't want to lose data. </p><p id="mcetoc_1ent5irsm0" class="align-left" data-pm-slice="0 0 []"><span style="color: #169179;">Formatting The Hard Drive</span></p><p>A new hard drive will have to be specially prepared by its manufacturer. They then send it to a retail store or reseller. Once in a consumer’s hand, it can be partitioned. A partition is a logical section on the drive.</p><p>It will have a device name to make it easy to refer to. With certain utilities, you can resize and change most partitions. When you partition a drive, you are creating a partition table and a filesystem. The table contains all the information on the partitions.</p><p>The filesystem is how data is read. It shows where the data is stored on the drive. It does this by mappings called inodes. There are many kinds of filesystems.</p><p>They each have their advantages. Most installation utilities will do these steps automatically if you prefer.</p><p>While formatting is not something you do every day, it is useful to know that it happens. You lose whatever data is on the drive when you format it. If it is a new system, then it is not a concern.</p><p>However, if this is an older drive then you will want to back up your data. Losing good data is not good.</p><p id="mcetoc_1ent5j76f1" class="align-left"><span style="color: #169179;">Setting Up Directories</span></p><p>You have probably heard that everything in Linux is a file. This is really pretty true. Every file in a system has a unique identifier. These are path names. The entire path name is the identifier.</p><p>So, /home/music has a separate identifier than /home/documents. Notice also that Linux systems use the slash that is closest to the right-shift button.</p><p>I admit this may be out of the realm of first users. Setting your own directories in a filesystem is for advanced users. It is possible that you need to do it, so I am mentioning it for this. For instance, you could be asked to by your boss.</p><p id="mcetoc_1ent5je8t2" class="align-left"><span style="color: #169179;">Mount Points</span></p><p>A filesystem needs to be mounted. It will have a specific mount point. A mount point is therefore the directory where the filesystem is placed. Most installation programs will do this automatically.</p><p>However, it is good to know that this takes place in the background. You might want to customize this process in the future. There can be multiple filesystems within a system. They can be different ones and hold different files.</p><p>There is a file that holds the filesystem information and it is called the /etc/fstab file. This is configurable if you want to adjust settings one day.</p><p id="mcetoc_1ent5jko33" class="align-left"><span style="color: #169179;">Making Partitions</span></p><p>Every specific distribution will have its own installation program. These programs will usually take care of steps like partitioning. However, it is important to know that you can usually do it yourself.</p><p>Some people have specific needs for what they want their setup to look like after they finish it. To do this correctly, they will have to manually setup their disk. You can decide what partitions that you want and their sizes.</p><p>This can be very important. If you think you're going to need a large &lt;swap&gt; partition, then you can set this manually. Partition examples include /boot, /root, /swap, and /home.</p><p>There used to be good reasons to set up several other partitions on a Linux system. A lot of those reasons revolved around disk fragmentation. That is not too common anymore, as most new disks are SSD or NVME now.</p><p>These types of disks do not fragment. If you reinstall often, then it could be useful to separate your partitions so you do not have to recreate programs or data as much.</p><p>A /var partition could be useful. If your data changes all the time, then you might want to do this. The /log directory is often in here too. Standardizing where log files are kept is a good idea for everyone.</p><p>They are always the keys to what is wrong with your system, so it is important to know where they are quickly. Another popular partition is /opt. This is where installation packages are on your system.</p><p>It is handy to know where to find certain types of files like I stated above. Packages are no exception. If you need to distribute to other systems on your network, then it is easier if they are all in one place.</p><p id="mcetoc_1ent5jquo4" class="align-left"><span style="color: #169179;">RAID</span></p><p>A redundant array of independent disks system is definitely something to consider. You will want to consider this if this is a server or any other machine with valuable data stored on the disks.</p><p>However, if you store your data on a remote server or a local device, then the extra cost may not be justified.</p><p>A RAID system uses two or more disks, partitions, or some combination of these two. It is a way to protect your data or add performance to your system. There are several RAID modes, and each has its advantages and disadvantages.</p><p>RAID can be hardware or software. Hardware RAID is usually in the form of addon cards within your system. They can contain processing power and often some cache memory. Software RAID is built in to Linux systems through certain utilities and is usually the better choice.</p><p>A long time ago hardware RAID was more popular because system hardware had progressed little. In current times with SSD’s, high-powered processors, and systems with 16-128 GB of ram, software RAID is the way to go.</p><p>The main reason administrators use RAID is to help protect their important data from hardware failure. It should not be the only tactic you use, just like you should not only have one backup of your data.</p><p>Software RAID is what I use when I deem it necessary. It also costs nothing because the Linux kernel controls it. It is also more powerful and gives greater flexibility to your system. The downside is that it takes more skill to set up.</p><p>Understand what mode you desire, how to use the utilities to implement it, and know how to query your system to find out the kinds of devices it has internally.</p><p id="mcetoc_1ent5k1565" class="align-left"><span style="color: #169179;">Logical Volume Manager</span></p><p>LVM is a great utility. It gives you the chance to implement it when you first do any installs. I highly recommend doing so. It gives your system great flexibility. So what does it do? LVM allows you to control your logical volumes at a moment’s notice.</p><p>You can add more space at any time. A logical volume is like a partition, except it is adjustable as you need it. Partitions are not and are pretty much set in stone.</p><p>This works by taking any physical part of your drives, which include disks and partitions and grouping them into a storage pool. With these individual parts in a storage pool, you use the LVM to group them how you need them to appear to your system.</p><p>You can also change these groupings and their allocated space at any time.</p><h2 id="mcetoc_1hu4eo8ea3" class="align-center"><span style="color: #236fa1;"><strong>Exploring Your Linux System</strong></span></h2><p><span style="color: #169179;"><strong>Ls Command</strong></span></p><p><span style="font-weight: 400;">The ls command is one of the most used commands. It lists directory contents. It will quickly become second nature. We can see directory contents and other information about files. It is used like this:</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">We can specify a directory:</span></p><p><code><span style="font-weight: 400;">Ls /Music</span></code></p><p><span style="font-weight: 400;">We can see more detail like this:</span></p><p><code><span style="font-weight: 400;">Ls -l /Music</span></code></p><p> </p><p><span style="font-weight: 400;">As with almost all commands, there are options and arguments you can use with them. These options and arguments modify how the commands work. An option is usually a dash followed by a single character. These are called short options. There are also long options that do the same thing in most cases. A long option is two dashes followed by a word. You can even use more than one option at a time. So we can do things like:</span></p><p><code><span style="font-weight: 400;">Ls -a</span></code></p><p><code><span style="font-weight: 400;">Ls -h</span></code></p><p><code><span style="font-weight: 400;">Ls -ah</span></code></p><p><span style="font-weight: 400;">Options in Linux are case sensitive. It can be easy to forget this so keep it in mind. </span></p><p> </p><p><span style="color: #169179;"><strong>CD Command</strong></span></p><p><span style="font-weight: 400;">The cd command lets you move around your system. It changes directories.</span></p><p><span style="font-weight: 400;">Once we look at our current location with the ls command, we can change to a directory that is listed there if we want to.</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">I am still in my home directory but I see a Music folder. What’s in there I wonder? Let us see.</span></p><p><code><span style="font-weight: 400;">Cd Music</span></code></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">Well, there isn’t anything in there yet. I need to fix that soon. I like music like everyone else. Hopefully you can see how this is helpful. Cd also has other things it can do like move backward one file level.</span></p><p><code><span style="font-weight: 400;">Cd ..</span></code></p><p><code><span style="font-weight: 400;">ls</span></code><span style="font-weight: 400;"><br></span><span style="font-weight: 400;">Now, you see that you are back where you started. That is the basic usage for the cd command. It is enough for now.</span></p><p> </p><p><span style="color: #169179;"><strong>File Command</strong></span></p><p><span style="font-weight: 400;">The file command gives you the file type of the file you are looking at. </span></p><p><code><span style="font-weight: 400;">File .bashrc</span></code></p><p><span style="font-weight: 400;">This shows you it is a text file. Since there are many types of files it is not always obvious what kind of file you are seeing. </span></p><p> </p><p><span style="color: #169179;"><strong>Less Command</strong></span></p><p><span style="font-weight: 400;">The less command lets us look at text files and see a smaller portion. This is helpful when the file in question is many pages long. We look at text files so we can modify them. An example would be a file that controls settings. Another reason is that program code is text and that is how we make programs. We can use it like this:</span></p><p><code><span style="font-weight: 400;">Less .bashrc</span></code></p><p><span style="font-weight: 400;">We can now scroll up and down. I do not recommend changing anything yet, but you need to know how to examine a file. Files are how settings are done in Linux so it is important to know about. </span></p><p><span style="font-weight: 400;">Type q to exit the less program</span></p><p> </p><p><span style="color: #169179;"><strong>Symbolic Links</strong></span></p><p><span style="font-weight: 400;">While you are exploring your system, you might see something that looks pretty weird after you use ls to view a directory’s contents. This is called a symbolic link. In fact, you can identify these symbolic links because they start with an &lt;l&gt;. This special file is also called a soft link. A soft link is like a pointer to a real file. It is useful because a program can change the pointer instead of countless versions of the file itself. This lets your system be much more efficient. </span></p><h2 id="mcetoc_1hipjg8uvng" class="align-center"><span style="color: #236fa1;"><strong>Using The Shell In Linux</strong><span style="font-weight: 400;"> </span></span></h2><p><span style="font-weight: 400;">When people talk about using the command line, they are really referring to the Shell. This is accessed by your terminal window which you run commands in. The shell itself is just a program that works behind the scenes. Almost all distributions of Linux have one included with their version. There are several different versions of Shells also. Some of these are Bash, Zsh, and Fish. </span></p><p> </p><p><span style="font-weight: 400;">There are also pieces of software called terminal emulators. These small programs help you talk to the Shell. This is something like Konsole or Terminal depending on your distribution. </span></p><p> </p><p><span style="font-weight: 400;">Your Shell prompt is where you type in commands. If the last character is a ‘$’ then you are a regular user. If the last character is a ‘#’ you are running as a root user which gives you superpowers in the Linux world. </span></p><p> </p><p><span style="font-weight: 400;">The Shell will give you access to your command history. You see the command history by using the up arrow on your keyboard. Keep pressing the up arrow to see more of your commands you have used. This is useful because you can just use the up arrow to redo commands instead of retyping a long command. Most distributions remember around a thousand of your last commands. </span></p><p> </p><p><span style="font-weight: 400;">Let’s start using some basic commands. Type the command and then hit enter:</span></p><p><code><span style="font-weight: 400;">Date</span></code></p><p><span style="font-weight: 400;">You will see the current time and date pop up.</span></p><p><span style="font-weight: 400;">Now, try the ‘cal’ command:</span></p><p><code><span style="font-weight: 400;">Cal</span></code></p><p><span style="font-weight: 400;">You should get a view of the current month. I like to use the ‘cal’ command as I am always forgetting what day it is and it is quicker to use than most other calendar systems. </span></p><p><span style="font-weight: 400;">Another useful command to use is ‘df’ which tells you how much free space is on your system.</span></p><p><code><span style="font-weight: 400;">Df</span></code></p><p><span style="font-weight: 400;">There is a useful parameter you can run with this command and I recommend using it:</span></p><p><code><span style="font-weight: 400;">Df -h</span></code></p><p><span style="font-weight: 400;">This makes the output easier to read. I will get into parameters and options later on.</span></p><p><span style="font-weight: 400;">The next command to learn is the ‘free’ command. We will also add the ‘-h’ parameter after it:</span></p><p><code><span style="font-weight: 400;">Free -h</span></code></p><p><span style="font-weight: 400;">This output tells you about the memory on your system.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Navigating Your File System</strong></span></p><p><span style="font-weight: 400;">The Linux file system looks very different from a Windows file system. It is mainly because everything is named differently. The file system is organized by directories. These directories can contain either files or more directories. In Windows, they are called folders. I will use directories from here on out though. </span></p><p> </p><p><span style="font-weight: 400;">The first directory in a Linux system is called the ‘root’ directory. It contains everything else on the local system. Linux has a single file system for everything in or attached to that computer. It is important to remember this when navigating. An external storage device is mounted or attached to somewhere in the file system. </span></p><p> </p><p><span style="font-weight: 400;">To see where you are at any time, use the ‘pwd’ command. This stands for present working directory.</span></p><p><code><span style="font-weight: 400;">Pwd</span></code></p><p><span style="font-weight: 400;">It gives a simple one line of output. Mine says:</span></p><p><code><span style="font-weight: 400;">/home/jason</span></code></p><p><span style="font-weight: 400;">Whenever we start our computer session in Linux, we start at ‘/home/username’. My username is Jason of course. We can change that later if we want to but that is not important right now. </span></p><p> </p><p><span style="font-weight: 400;">To see what files are in a directory, we use the ‘ls’ command.</span></p><p><code><span style="font-weight: 400;">Ls</span></code></p><p><span style="font-weight: 400;">This command can be used to see the contents of any directory if you know the path. We already know one because we are part of it. It is our ‘home’ directory.</span></p><p><code><span style="font-weight: 400;">Ls /home</span></code></p><p><span style="font-weight: 400;">You can also see the contents of the whole computer by looking at the ‘root’. To see the ‘root’, we use ‘/’. So try this:</span></p><p><code><span style="font-weight: 400;">Ls /</span></code></p><p><span style="font-weight: 400;">This shows you everything at the ‘root’ level. See the ‘/home’ directory? Your user directory is located within that ‘/home’ directory. Hopefully you can see how your system is organized now. </span></p><p> </p><p><span style="font-weight: 400;">This brings us to moving directories. We move to a different directory for various reasons. Often, we just want to work from that directory. While we can see what is there by using the path or make a file and put it there, it is easier to just be in that directory. To get to that directory we use the ‘cd’ command:</span></p><p><code><span style="font-weight: 400;">Cd /home/jason</span></code></p><p><span style="font-weight: 400;">This is called using an absolute path because we started at the ‘root’ directory denoted by the first ‘/’ and then listed the directory structure until we got to our directory under ‘/home’.  We can also use relative pathnames. It is called this because it is relative to our present directory. So:</span></p><p><code><span style="font-weight: 400;">Cd ..</span></code></p><p><span style="font-weight: 400;">Will move us up one directory from our present working directory. </span></p><p><span style="font-weight: 400;">‘Cd’ is a very helpful command. It allows for fast movement if you use a few tricks.</span></p><p><span style="font-weight: 400;">To instantly go to your ‘/home’ directory:</span></p><p><code><span style="font-weight: 400;">Cd</span></code></p><p><span style="font-weight: 400;">To change the working directory to the previous directory:</span></p><p><code><span style="font-weight: 400;">Cd -</span></code></p><h2 id="mcetoc_1f9sus8jj8cv" class="align-center"><span style="color: #236fa1;"><strong>Doing More With The Shell</strong></span></h2><p>Using a shell gives you great satisfaction. It does have a learning curve but, it is well worth it. I am assuming you have no prior knowledge. Taking it slow and using it every day is the best way.</p><p id="mcetoc_1f9sus8jj8d0" class="align-left"><span style="color: #169179;"><strong>Files and Directories</strong></span></p><p><br>Files are where your data is kept. A file can be many things. When you are storing input, it goes into a file. This can be a text file, a drawing program, or a sound file. These are some Linux essentials you can't forget.</p><p><br>Directories are organizational structures. They can organize your files and other directories. At any one time, you will be in a distinct directory. You have to be logged in to have a current working directory.</p><p id="mcetoc_1f9sus8jj8d1" class="align-left"><br><span style="color: #169179;"><strong>The Shell</strong></span></p><p><br>A shell is the interface to the operating system. It is text based and it accepts input as text. The input will usually invoke small programs or utilities that are installed in the operating system.</p><p>There are many different shells but the most common one is &lt;Bash&gt;. This is part of the history and usage of Linux.</p><p><br>When you first log in, the operating system will put you in your home directory. You can change this behavior, just so you know. When you change directories, you can always find out where you are.</p><p><br>I can enter in the command:</p><p><br><code>pwd</code></p><p>and it will tell me what directory I am currently in.</p><p><br>Now, when you invoke a utility like "pwd" the shell executes this command. What it does and what you will see from then on depends entirely on the utility and what it is designed to do.<br><br>You can also modify commands. This is done by the use of "arguments".</p><p><br><br><code>pwd -L</code>             "use from the environment"</p><p><br><code>pwd -P</code>             "avoid all symbolic links"</p><p><br><code>pwd --version  </code>     "output version information and exit"</p><p><br><code>pwd --help    </code>      "display help and exit"</p><p><br><br>You can also have multiple arguments for a command. This can greatly change its<br>behavior.</p><p><br>Certain commands require certain arguments. A "cp" command, which copies, needs<br>to know what it is copying and where it is copying to.</p><p><br><code>cp directory1 directory2</code><br><br></p><p>You can also have options for any particular command. They are called "options"<br>because you do not have to use them to get the command to work. They work like<br>arguments, however, they extend the behavior of that command.</p><p><br>Options and arguments are usually preceded by a hyphen or two depending on<br>the command. If you need to use multiple arguments and options, then use a<br>single hyphen with the corresponding letters.</p><p><br><code>pwd -LP</code><br><br></p><p>As you can see, there are no spaces in between the options. Most of the time<br>it does not matter in what order you put the arguments or options.</p><p><br>Most utilities will have a help feature.</p><p><br><code>pwd --help</code><br><br></p><p>It works the same for most commands. It will give you a lot of details about<br>the command. Arguments, options, and examples are very helpful to understand<br>how a command is supposed to be used.</p><p id="mcetoc_1f9sus8jj8d2" class="align-left"><br><span style="color: #169179;"><strong>Using Commands</strong></span></p><p><br>You usually have to be in the directory of a utility in order to run it. The<br>exception to this is, of course, how the path is set. The path is a  variable the<br>operating system uses to check directories for programs to run.</p><p>That makes it very useful so you don't always have to be in the /bin directory for example.</p><p><br>Of course, this was never the case as the path variable was always used.<br>However, if you did not have a path set somehow, you would have to be in the<br>directory to use any utility you wanted.</p><p><br>There is a trick to run a program without using the path.</p><p><br><code>./script1.sh</code><br><br></p><p>This lets you run a utility without using the path variable. This can be useful<br>at times. Experienced users should not need to do this much. Keep it in mind as<br>an option though if you need it sometime.</p><p id="mcetoc_1f9sus8jj8d3" class="align-left"><br><span style="color: #169179;"><strong>Redirecting Output</strong></span></p><p><br>You can redirect the output of commands. The output can be sent to another command or even a file.</p><p><br><code>pwd &gt; test.txt</code></p><p><br>This will run the "pwd" command, which tells the present working directory. The results or output will be sent and stored into the test.txt file. This is very flexible and should be used when you need to do something like this.</p><p><br>This operation will delete the file if there is another with the same name. Be careful using it.</p><p id="mcetoc_1f9sus8jj8d4" class="align-left"><br><span style="color: #169179;"><strong>Redirecting Input</strong></span></p><p><br>Just like output, you can redirect input. This is most often done with files. A file can contain a book list, for example. Commands like &lt;cat&gt; or &lt;grep&gt; can have the fileinput sent to it.</p><p><br><code>cat &lt; booklist.txt</code></p><p><br><code>grep Magnus &lt; booklist.txt</code></p><p id="mcetoc_1f9sus8jj8d5" class="align-left"><br><span style="color: #169179;"><strong>Pipelines</strong></span></p><p><br>You can connect two different commands through the use of a pipeline. This is<br>the pipeline symbol &lt; | &gt;. When it is used, it takes the output of the first<br>command and sends it to the input of the second command.</p><p><br>This is very similar to redirecting output and sending it to a file. The difference is that we are just dealing with commands. This makes the pipeline very flexible and good to use when appropriate.</p><p><br><code>ls | lpr</code></p><p><br>The above example takes the output from the &lt;ls&gt; command and sends it to the &lt;lpr&gt; command. The &lt;lpr&gt; command is a print utility, so &lt;lpr&gt; will print the<br>files listed by &lt;ls&gt;.</p><p><br><code> who | sort</code></p><p><br> This example takes the output of the &lt;who&gt; utility and sends it to the &lt;sort&gt;<br> utility. A list of users on your computer will be alphabetically sorted by this one command.</p><p><br> <code>who | grep jmoore</code></p><p><br> This is another good command to use. The &lt;who&gt; utility lists users and the<br> &lt;grep&gt; utility searches for patterns that you specify. We want to search for a user.</p><p>If you have a bunch of users and you need specific information, then use this to get your list and send the output to the &lt;grep&gt; utility.</p><p><br>There are many utilities that will work for this. Don't worry about knowing all at once. Over time, it gets easier to put them together when you need specific information. You can also use three or more utilities at once with pipelines as long as nothing conflicts.</p><p id="mcetoc_1f9sus8jj8d6" class="align-left"><br><span style="color: #169179;"><strong> Background Commands</strong></span></p><p><br> You can run commands or utilities in the foreground or background. Most of<br> your commands will be in the foreground. There are good times when you want<br> to run them in the background though.</p><p>If a command will take a long time to run, then it is a good candidate to run in the background.</p><p><br>The reason you would want to do this is that it frees up your shell for your to run other commands and do other tasks. When you run a command in the background, it is now a job.</p><p>The shell keeps track of it and assigns it a job number. You can even query this job number to check on the progress of the job.</p><p><br>You use the &lt;&amp;&gt; sign to indicate the current command is to run in the background. One thing I do a lot is update computers on my network. I have a script I wrote for this.</p><p><br> <code>updates.sh &amp;</code></p><p><br> This will run my script in the background as a job. I can do other things because it is going to take a long time. This makes it very useful.</p><p><br> To use an earlier example, you can do it with whatever you need to print.</p><p> </p><p><code>ls | lpr &amp;</code></p><p><br>Again, this throws the output of &lt;ls&gt; into the &lt;lpr&gt; print utility and prints everything in the background.</p><p>Commands can have options and arguments that you use after the command. These will modify the behavior of the command itself. When you enter a command it needs to listed in the path variable or you need to be in the current directory of the program.</p><p>You can chain commands through the use of pipelines. Pipelines use the &lt;|&gt; symbol. They take the output of the first command and send it to the input of the second command.</p><p>Commands can also be run in the background. This is another useful feature that will enhance your productivity. If there is a long task to run, start it and have it run in the background.</p><p>It will go away from sight but still be running. You can then use your shell to do other tasks like create new users or modify permissions on files.   </p><h2 id="mcetoc_1f9v9jt1i957" class="align-center"><span style="color: #236fa1;"><strong>Filtering Text In Linux</strong></span></h2><p>Filtering text allows you to do many efficient tasks in Linux. Displaying and sorting text is one of the most common tasks that you will do. This section is an introduction to filters in order to create pipelines for your workflow.</p><p id="mcetoc_1f9v9jt1i958" class="align-left" data-pm-slice="1 1 []"><span style="color: #169179;"><strong>Introduction</strong></span></p><p>Filtering text is the process of capturing text, doing something with it, and then sending it to the output stream. Most commonly, the output from one command is taken and redirected to the input of another command. This is usually accomplished through pipes and stream operators.</p><p id="mcetoc_1f9v9jt1i959" class="align-left"><span style="color: #169179;"><strong>Streams</strong></span></p><p>A stream is a series of data. There are input and output streams. Data flows both ways. Streams can be sent to a terminal, a file, or a network device. There are three main types:</p><ul><li>stdin</li><li>stdout</li><li>stderr</li></ul><p>The first, stdin, sends input to commands. Next, stdout, displays output from commands. Then, stderr, shows errors that were produced.</p><p id="mcetoc_1f9v9jt1i95a" class="align-left"><span style="color: #169179;"><strong>Pipes</strong></span></p><p>The pipe symbol, “|”, is one way to redirect output from one command to the input of another. Input can come from a command or a file. You can make a long sequence of commands using pipes. The output is usually shown in the terminal.</p><p id="mcetoc_1f9v9jt1i95b" class="align-left"><span style="color: #169179;"><strong>Output Redirection</strong></span></p><p>The operator, “&gt;”, can send output to a file. This is what you want to do if you need to save the results. Once you have data in a file, you have many more options. You can show the contents of a file, see any special characters associated with it, and split a file into two pieces.</p><p id="mcetoc_1f9v9jt1i95c" class="align-left"><span style="color: #169179;"><strong>The Cat Command</strong></span></p><p>The cat command can show the contents of a file and create files. By default, it reads from stdin unless you specify a file to read from.</p><p><code>echo -e "1 teamup\n2 unbroken_bonds\n3 unified_minds\n4 cosmic_eclipse" &gt; edition.txt</code></p><p><code>$ cat edition.txt</code><br><code>1 teamup</code><br><code>2 unbroken_bonds</code><br><code>3 unified_minds</code><br><code>4 cosmic_eclipse</code></p><p>In the first snippet we just sent some data to a text file that we created at the same time. Then we showed the contents of the file in the second snippet. This shows you how it works.</p><p>Let's make a second file now.</p><p><code>echo -e "1 breakpoint\n2 breakthrough\n3 ultra_prism\n4 celestial_storm" &gt; edition2.txt</code></p><p>Make sure the output is what we expect.</p><p><code>$ cat edition2.txt</code><br><code>1 breakpoint</code><br><code>2 breakthrough</code><br><code>3 ultra_prism</code><br><code>4 celestial_storm</code></p><p>The cat command also concatenates files. It just so happens that we have two files, ready for joining.</p><p><code>$ cat edition*</code></p><p>The asterisk is short for getting everything that has the partial name of "edition". </p><p><code>1 teamup</code><br><code>2 unbroken_bonds</code><br><code>3 unified_minds</code><br><code>4 cosmic_eclipse</code><br><code>1 breakpoint</code><br><code>2 breakthrough</code><br><code>3 ultra_prism</code><br><code>4 celestial_storm</code></p><p>This sends everything in those two files to the screen output. We can do something else cool, we can just make a third file with the contents of the first two.</p><p><code>$ cat edition.txt edition2.txt &gt; edition3.txt</code></p><p>This makes a third file that contains the contents of the first two.</p><p><code>$ cat edition3.txt</code><br><code>1 teamup</code><br><code>2 unbroken_bonds</code><br><code>3 unified_minds</code><br><code>4 cosmic_eclipse</code><br><code>1 breakpoint</code><br><code>2 breakthrough</code><br><code>3 ultra_prism</code><br><code>4 celestial_storm</code><br><br></p><p>That is really useful text manipulation. This also showcases the flexibility of the "cat" command.</p><p id="mcetoc_1f9v9jt1i95d" class="align-left"><span style="color: #169179;"><strong>Wordcount Command</strong></span></p><p>We can use this utility, "wc", to get more information from a file. This is handy if we know nothing about a file.</p><p><code>$ wc edition3.txt</code><br><code>  8  16 119 edition3.txt</code></p><p>We used this on the file we just created. It shows us the lines, words, and bytes in the file. It is very nice if you need to examine a file. The file may be thousands of lines long, you don't want all of that in your terminal output. If it is huge like that, you have another option.</p><p id="mcetoc_1f9v9jt1i95e" class="align-left"><span style="color: #169179;"><strong>Tail Command</strong></span></p><p>The tail command can show you the last lines of a file. By default, it shows you the last ten lines.</p><p><code>$ tail edition3.txt</code></p><p>My file is small but if it was large, that is the usage you would want to try first. </p><p id="mcetoc_1f9v9jt1i95f"><strong>Head Command</strong></p><p>The head command is the same as tail, except it shows you the first lines of a file. It is used in the same way. </p><h2 id="mcetoc_1i2s6qiqc4" class="align-center"><span style="color: #236fa1;"><strong>Working With Files</strong></span></h2><p>The following commands are what makes working with the command line worth it.<br>All of these tasks can be performed in a graphical environment, but when you get<br>used to the command line, they become much faster.<br><br><span style="color: #169179;"><strong>Wildcards</strong></span><br>Wildcards is one of the things that makes the command line so strong. They give<br>us a lot of flexibility. Wildcards allow you to select filenames based on<br>patterns of characters.<br>*     matches any characters<br>?     matches any single character<br>Using wildcards makes it possible to create complicated search queries. <br>*       all files<br>a*      any file begining with a<br>a*.txt  any file beginning with a followed by characters and ending with .txt<br>file??? any file beginning with the name file and followed by exactly 3<br>        characters.<br>Wildcards can be used with any command that accepts filenames as arguments.<br><br><span style="color: #169179;"><strong>Creating Directories</strong></span><br>The mkdir command is used to create directories.<br><code>mkdir directory-name</code><br>We can also make several directories at once.<br><code>mkdir name1 name2 name3 name4 name5</code><br><br><span style="color: #169179;"><strong>Copying Files</strong></span><br>The cp command is what we use to copy files or directories. <br><code>cp file1 file2</code><br>This copies the single file to another file.<br><code>cp -a file1 file2</code><br>The option -a copies a file with all of its attributes to another file.<br><code>cp -i file1 file2</code><br>The option -i will prompt the user for confirmation when overwriting a file.<br><code>cp -r folder1 folder2</code><br>The -r option will copy folders and all of their contents. <br><code>cp -u file1 file2</code><br>The -u option will only copy files that do not exist or are newer than the<br>existing correspondinf files in the destination directory.<br><code>cp -v folder1 folder2</code><br>The -v option will display extra information as copying is done.<br><br><span style="color: #169179;"><strong>Moving Files</strong></span><br>We move and rename files with the mv command. So, the mv command can be used in<br>multiple ways. <br><code>mv file1 file2</code><br>This will rename file1 to file2.<br><code>mv file1 folder1</code><br>When used like this, it moves file1 to folder 1. <br><code>mv -i file1 file1</code><br>The -i option will confirm you want to complete the action.<br><code>mv -u file1 file2</code><br>This will again only move files that do not exist or are newer than the files in<br>the destination folder.<br><code>mv -v file1 folder1</code><br>The -v will also give extra information when moving file1 to folder 1.<br><br><span style="color: #169179;"><strong>Removing Files</strong></span><br>The rm command is used to remove files and folders.<br><code>rm file1</code><br>That will remove a file.<br><code>rm -i file1</code><br>This will ask for confirmation because of the -i option.<br><code>rm -r folder1</code><br>This will remove a folder and all of its subdirectories. You must use this<br>option to delete folders. <br><code>rm -v file1</code><br>The -v gives extra information when performing this task.<br><br><span style="color: #169179;"><strong>Creating Links</strong></span><br>We create links using the ln command. Links can be either hard or soft. Hard<br>links are an older way of doing things, while soft links are the modern way. <br>This creates a hard link:<br><code>ln file link</code><br>This creates a soft link:<br><code>ln -s file link</code><br><code>ln -s folder link</code><br>As you can see, you cannot make a hard link of a folder or directory. That must<br>be done with a soft link. <br><br>Every file has a hard link associated with it. When a hard link is created, we<br>are making another way to refernce the file. Hard links cannot reference<br>anything outside its original file system. It also cannot reference a directory. <br><br>Soft links were made to overcome the limitations of hard links. When you create<br>a soft link, you are creating a unique file that contains a pointer to the<br>original file or directory. When you wrtie information to the soft link, the<br>original file is updated. So unless you go looking, it is hard to tell the<br>difference between the two. However, when you delete the link, the original file<br>is untouched. If the file is deleted first, the link stays but points to<br>nothing. </p><h2 id="mcetoc_1i5cbf0acbr" class="align-center"><span style="color: #236fa1;"><strong>Commands in Linux</strong></span></h2><p>In Linux, a command can be a program, something in the shell, a shell function,<br>and an alias. Programs are those in the /usr/bin directory. There can be many<br>different types.</p><p>Commands in the shell are built in to the shell. A shell<br>function is a small script that does something useful, hopefully. Aliases are<br>commands that we make ourselves, that come from other commands.<br><br><span style="color: #169179;"><strong>Type</strong></span><br>It can be useful to know what kind of command you are using. You can find out by<br>typing:</p><p><br><code>type free or</code><br><code>type dnf</code></p><p>You could get a different result for each command, depending on what you type.<br>The reason is, as mentioned above, there are a few different types of commands.<br>So, don't freak out when you see multiple types. <br><br><span style="color: #169179;"><strong>Which</strong></span><br>The which command gives you the location of an executable.</p><p> <br><code>which free</code></p><p>It only works for executable programs.<br><br><span style="color: #169179;"><strong>Documentation</strong></span><br>We can now get the documentation for a command. Use "help" for the built in<br>commands.</p><p><br><code>help cd</code></p><p>It will give a description of what the command does as well as options. Also,<br>when square brackets appear in the description of a command's syntax, they<br>indicate optional items. A vertical bar character indicates mutually exclusive<br>items. There is a help option after these commands, so you can get help either<br>way you like.</p><p><br><code>free --help</code></p><p>This gives you usage and options related to the command in question.<br><br><span style="color: #169179;"><strong>Man</strong></span><br>Most programs will have a manual page. It can be abbreviated as "man".</p><p><br><code>man free</code></p><p>This will give you almost everything related to the "free" command. Probably<br>more than you care to know, honestly. Just know it is available. Most do not<br>provide examples and are just a reference. <br><br><span style="color: #169179;"><strong>Apropos</strong></span><br>This will display appropriate commands related to a search term.</p><p> <br><code>apropos free</code></p><p>This will give different man pages that might be helpful. The first column is<br>the name of the man page and afterwards, a description. <br><br><span style="color: #169179;"><strong>Whatis</strong></span><br>This command will display one line manual page descriptions.</p><p><br><code>whatis dnf</code></p><p>It is a simplified view but can be useful.<br><br><span style="color: #169179;"><strong>Info</strong></span><br>This will display a program's info entry.</p><p> <br><code>info dnf</code></p><p>It gives you a lot of information but it is well formatted. It contains<br>hyperlinks to help you move around in the directory structure. use page up or<br>page down to move quickly. Hit enter with a hyperlink selected. Then, Q to quit<br>the info program.<br><br><span style="color: #169179;"><strong>Readme Files</strong></span><br>A lot of software packages that are installed on your system have documentation<br>files. These files are located in the /usr/share/doc directory. Most of these<br>are stored in text format and can be viewed with the less command. Some are also<br>in HTML format and can be viewed in a web browser. <br><br><span style="color: #169179;"><strong>Creating Aliases</strong></span><br>We can create our own commands, or aliases, for other commands and associated<br>options. The first thing we do is see if there is an alias for a command you are<br>thinking of. If I want to check for freem, for free memory, I would type:</p><p><br><code>type fr</code></p><p>It will say not found if it is available. So, you might use the same aliases on<br>every system you are on. Sometimes I can't remember what I have done on a<br>system, that is why it is useful to check. To make an alias:</p><p><br><code>alias fr='free -h'</code></p><p>As you can see, we aren't just making a shorter command to type less. We<br>included an option there too. We are typing a lot less when we do this command<br>several times a day. We can again use the type command and we can see our alias<br>now.</p><p> <br><code>type fr</code></p><p>You can see what we just did, which is cool! The aliases will go away when your<br>session ends, so remember that. We will go over how to make them permanent<br>later, which is very useful. </p><h2 id="mcetoc_1h4km0vek1o" class="align-center"><span style="color: #236fa1;"><strong>Rsync</strong></span></h2><p><span style="font-weight: 400;">Rsync stands for remote synchronization and it transfers and syncs files. It can do this locally and remotely. It is a very good tool. Though it has a learning curve, it is not hard to pick up. Its main use is to copy files and directories between two different computers. It can look at files and only send what has been changed. It can preserve all kinds of links and metadata.   </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"> </span></p><p class="align-left"><span style="color: #169179;"><strong>Installing Rsync  </strong><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"></span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"> </span></p><p><span style="font-weight: 400;">If you do not already have it installed on your system, you will need to install it. I am running Fedora. If you are running another distribution, use whatever package manager you have to install it.</span></p><p> </p><p><span style="font-weight: 400;">On Fedora run:</span></p><p><code><span style="font-weight: 400;">dnf update -y</span></code></p><p> </p><p><span style="font-weight: 400;">This will update your files. Then:</span></p><p><code><span style="font-weight: 400;">dnf install rsync -y</span></code></p><p> </p><p><span style="font-weight: 400;">This will install rsync to your system if it is not already there.</span></p><p> </p><p><span style="font-weight: 400;">Now run:</span></p><p><code><span style="font-weight: 400;">which rsync</span></code></p><p> </p><p><span style="font-weight: 400;">This will show you where it is installed on your system</span></p><p><span style="font-weight: 400;">Then run:</span></p><p><code><span style="font-weight: 400;">rsync –version</span></code></p><p> </p><p><span style="font-weight: 400;">That shows you the version you have.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Files</strong></span></p><p><span style="font-weight: 400;">Copying files is really easy. It is:</span></p><p> </p><p><code><span style="font-weight: 400;">rsync -v </span><span style="font-weight: 400;"></span><span style="font-weight: 400;">source </span><span style="font-weight: 400;"></span><span style="font-weight: 400;">destination</span></code></p><p> </p><p><span style="font-weight: 400;">The -v option means output will be given verbosely</span></p><p><span style="font-weight: 400;">Source is the full path of the source file unless you are in its directory already.</span></p><p><span style="font-weight: 400;">Destination should be the full path unless it is in your current path too.</span></p><p><span style="font-weight: 400;">It looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">rsync -v program1.cpp Documents</span></code></p><p> </p><p><span style="font-weight: 400;">In the above example I was already in the directory of the file I wanted to copy. You should do that when you can. I transferred it to the Documents folder.</span></p><p><span style="font-weight: 400;">Another example that is slightly different:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/documents /home/jason/Writing/</span></code></p><p> </p><p><span style="font-weight: 400;">This command copies all the files in Documents to my Writing folder.</span></p><p><span style="font-weight: 400;">You can use the ls command to look and make sure everything is transferred as expected.</span></p><p> </p><p><code><span style="font-weight: 400;">Ls Writing/</span></code></p><p> </p><p><span style="font-weight: 400;">There are many reasons to make copies of your files. Backing up important files to another remote location is something we should all do more.</span></p><p> </p><p><span style="font-weight: 400;">Whenever you do a file transfer, it is a good idea to switch to that location and make sure it is copied over. Doing this a few times will instill confidence in your command line abilities.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>The Trailing /</strong></span></p><p><span style="font-weight: 400;">The trailing slash at the end of a path dictates whether rsync will copy the contents of a directory or the entire directory with the folder included. Excluding the / from the source path copies the directory to the source destination.</span></p><p> </p><p><span style="font-weight: 400;"># This command will copy the Writing directory and its contents to the backup drive</span></p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/Writing /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;"># This command will only copy the files in the Writing directory to the backup drive.</span></p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/Writing/ /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">This is a small difference but it is very important to get right.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Contents of Directories</strong></span></p><p><span style="font-weight: 400;">It is often very useful to copy entire directories at once. It is easy to do this. Use:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av     /source/     /destination/</span></code></p><p> </p><p><span style="font-weight: 400;">Just use the full paths of the source and destination</span></p><p><span style="font-weight: 400;">So, something like this should get the job done:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Documents/ /home/jason/Backup/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directories to other Directories</strong></span></p><p><span style="font-weight: 400;">If we want to copy a folder to another folder then we do this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Documents /home/jason/Backup/</span></code></p><p> </p><p><span style="font-weight: 400;">You should look inside the directory to make sure you typed the command over correctly. You should see the folder nested in there.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying A File Remotely</strong></span></p><p><span style="font-weight: 400;">Rsync lets you connect to different machines. This makes copying files to other machines an easy practice. You will need:</span></p><ol><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">File path from local machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">IP address of remote machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">File path on remote machine</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Root access to remote machine</span></li></ol><p><span style="font-weight: 400;">The command will look something like this depending on what you need to do:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -v /path/from/local/machine     root@123.45.56.678:/root/remote/path</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directory To Another Drive</strong></span></p><p><span style="font-weight: 400;">This is very handy and gives you better protection. It is also easy to implement. </span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av /home/jason/Writing /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">As usual, go and look to make sure everything happened the way you expect. After a while, you will not feel the need to do this.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Copying Directories Remotely</strong></span></p><p><span style="font-weight: 400;">Rsync can handle remote directories just as easily as single files. When you run this command, you will be asked for its password. So, be prepared on this front. The command looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -av   /local/path   root@123.45.56.678:/root/remote/path/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Compressing Files</strong></span></p><p><span style="font-weight: 400;">Rsync can compress files that it tries to transfer. This will speed up a transfer. If your transfer is very small, you will not see a difference. However, if you are doing lots of video, for example, this will be of great benefit. Do it like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avz /home/jason/video /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;">This command will copy the Video folder over to my backup drive.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Monitoring Your Progress</strong></span></p><p><span style="font-weight: 400;">If we are doing a long transfer, we can monitor the progress. I like statistics so this is useful for me. The command looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avz –info=progress2  /home/jason/Video /path/BackupDrive/</span></code></p><p> </p><p><span style="font-weight: 400;">This will give you the results of your transfer.</span></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Syncing Directories</strong></span></p><p><span style="font-weight: 400;">Syncing directories is easily done. Keep in mind that sometimes files will be deleted and they will be gone. So, use this command after careful consideration. We use the –delete option with the regular command plus source and destination paths. This will look at the source directory and then make the destination directory match it. It looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -aP –delete /home/jason/Writing/ /path/BackupDrive/Writing/</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Excluding Files and Directories</strong></span></p><p><span style="font-weight: 400;">Rsync can easily look the other way during a command if you want it to. So, if I want to exclude a subfolder of my Writing folder, it will do that. Here is how.</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avzP –exclude=Algebra /home/jason/Writing /path/BackupDrive</span></code></p><p> </p><p><span style="font-weight: 400;">We can also exclude files from a transfer or sync operation. If I want to exclude .mp3 files it looks like this:</span></p><p> </p><p><code><span style="font-weight: 400;">Rsync -avzP –exclude=*.mp3 /home/jason/Music/ /path/BackupDrive</span></code></p><p> </p><p class="align-left"><span style="color: #169179;"><strong>Options</strong></span></p><ul><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-a = –archive mode and equal to several other flags at once. It tells rsync to sync recursively,transfer special and block devices, preserve symbolic links,modification times, groups, ownership, and permissions</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-z = –compress. This option compresses the data that is sent to the destination machine.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-P = –partial and –progress. Using this option shows a progress bar during the transfer and keeps track of partially transferred files.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">–delete. When you use this option, it will delete extra files from the destination folder that are not in the source folder. It is how you mirror directories.</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-q or –quiet. Use this when you don’t want to see error messages</span></li><li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">-e. Use this when you want to choose the remote shell to use</span></li></ul><h2 id="mcetoc_1i80ndtv0f" class="align-center"><span style="color: #236fa1;"><strong>Input and Output Redirection</strong></span></h2><p><span style="color: #169179;"><strong>Standard Input and Output</strong></span><br>Many of the programs we have used so far produce output of some kind. This<br>output consists of two types. The programs's results like when the data is<br>designed to produce something. It also produces status and error messages that<br>tell us about the program in question.<br><br>If we look at a command like ls, we can see that it displays its results and its<br>error messages on screen. Programs such as ls send their results to a special<br>file called standard output and their status messages to another file called<br>standard error. By default, both standard output and standard error are linked<br>to the screen and not saved into a disk file. In addition, many programs take<br>input from a facility called the standard input, which by default is attached to<br>the keyboard.<br><br>Input and output redirection allows us to change where output goes and where<br>input comes from. Normally, output goes to the screen and input comes from the<br>keyboard, but with redirection, we can change that.<br><br><span style="color: #169179;"><strong>Redirecting Output</strong></span><br>Redirection allows us to redefine where standard output goes. To redirect<br>standard output to another file instead of the screen, we use the redirection<br>operator "&gt;" followed by the name of the file. <br><br><code>ls -l /usr/bin &gt; ls-output.txt</code><br><br>Here, we created a long listing of the /usr/bin directoryt and sent the results<br>to the ls-output.txt file. If it is a long file we can use the less command:<br><br><code>less ls-output.txt</code><br><br>If we want to append information to the file instead of reqriting it, we use the<br>"&gt;&gt;" redirection operator.<br><br><code>ls -l /usr/bin &gt;&gt; ls-output.txt</code><br><br>Using the &gt;&gt; operator will result in the output being appended to the file. If<br>the file does not exist, it is created.<br><br><span style="color: #169179;"><strong>Redirecting Standard Error</strong></span><br>Redirecting standard error lacks the ease of a dedicated redirection operator.<br>To redirect standard error, we must refer to its file descriptor. A program can<br>produce output on any of several numbered file streams. While we have referred<br>to the first three of these file streams as standard input, output, and error,<br>the shell references them internally as file descriptors 0, 1, and 2. The shell<br>provides a notation for redirecting files using the file descriptor number.<br>Because standard error is number 2, we can redirect standard error like this:<br><br><code>ls -l /bin/usr 2&gt; ls-error.txt</code><br><br>The file descriptor 2 is placed immediately before the redirection operator to<br>perform the redirection of standard error to the file ls-error.txt. There are<br>cases in which we may want to capture all of the output of a command to a single<br>file. To do this, we must redirect both standard output and standard error at<br>the same time. <br><br><code>ls -l /usr/bin &gt; ls-output.txt 2&gt;&amp;1</code><br><br>Using this method, we perform two redirections. First we redirect standard<br>output and then we redirect file descriptor 2 to file descriptor 1 using the<br>notation 2&gt;&amp;1.<br><br>Sometimes, we do not want output from a command. This usually applies to error<br>and status messages. The system provides a way to do this by redirecting output<br>to a special file called /dev/null. This file is a system device often referred<br>to as a bit bucket, which accepts input and does nothing with it. <br><br><code>ls -l /usr/bin 2&gt; /dev/null</code><br><br>Redirecting Standard Input<br>Up to now, we have not encountered many commands that make use of standard<br>input. The "cat" command reads one or more files and copies them to standard<br>output.<br><br><code>cat filename</code><br><br>You can use it to display files without paging. <br><br><code>cat ls-output.txt</code><br><br>It is often used to display short text files. Because "cat" can accept more than<br>one file as an argument, it can also be used to join files together.<br><br><span style="color: #169179;"><strong>Pipelines</strong></span><br>The capability of commands to read data from standard input and send to standard<br>output is utilized by a shell feature called pipelines. Using the pipe operator<br>|, the standard output of one command can be piped into the standard input of<br>another.<br><br><code>ls -l /usr/bin | less</code><br><br>Using this technique, we can conveniently examine the output of any command that<br>produces standard output.<br><br>Pipelines are often used to perform complex operations on data. It is possible<br>to put several commands together into a pipeline. Frequently, the commands used<br>in this way are referred to as filters. Filters take input, change it, then<br>output it. <br><br><code>ls /bin /usr/bin | sort | less</code><br><br>Because we specified two directories, the output of ls would have consisted of<br>two sorted lists, one for each directory. By including sort in our pipeline, we<br>changed the data to produce a single sorted list.<br><br>The "uniq" command is often used in conjunction with "sort". It accepts a sorted<br>list of data from either standard input or a single filename argument then<br>removes any duplicates from the list. <br><br><code>ls /bin /usr/bin | sort |uniq | less</code><br><br>We use "uniq" to remove any duplicates from the output of the "sort" command. If<br>we want to see the list of duplicates, we add the "-d" option to "uniq".<br><br><code>ls /bin /usr/bin | sort | uniq -d | less</code><br><br>The "wc" command is used to display the number of lines, words, and bytes<br>contained in files.<br><br><code>wc ls-output.txt</code><br><br>In this case, it prints out three numbers: lines, words, and bytes. Like our<br>previous commands, if executed without command line arguments, "wc" accepts<br>standard input. The "-l" option limits its output to report only lines. Adding<br>it to a pipeline is a handy way to count things. To see the number of items we<br>have in our sorted list we can do this:<br><br><code>ls /bin /usr/bin | sort uniq | wc -l</code><br><br>The command "grep" is a powerful program used to find text patterns within<br>files. It is used like this:<br><br><code>grep pattern filename</code><br><br>When "grep" encounters a pattern in the file, it prints out the lines containing<br>it. The patterns that "grep" can match can be very complex. Suppose we wanted to<br>find all the files in our list of programs that had the word zip embedded in the<br>name. Such a search might give us an idea of some of the programs on our system<br>that had something to do with file compression.<br><br><code>ls /bin /usr/bin | sort | uniq | grep zip</code><br><br>There are a couple handy options for "grep".<br>The option "-i" causes "grep" to ignore case when performing the search.<br>the option "-v" tells "grep" to print only those lines that do not match the<br>pattern. <br><br>Sometimes, you do not want all the output from a command. You might want only<br>the first few lines or the last few lines. The "head" command prints the first<br>10 lines of a file, and the "tail" command prints the last 10 lines. By default,<br>both commands print 10 lines of text, but this can be adjusted with the "-n"<br>option.<br><br><code>head -n 5 ls-output.txt</code><br><br>The "tail" command operates the same way:<br><br><code>tail -n 5 ls-output.txt</code><br><br>The "tail" command also has an option to let you view files in real time. This<br>is useful for watching the progress of files as they are being written. <br><br><code>tail -f /var/log/messages</code><br><br>Using the "-f" option, "tail" continues to monitor the file, and when new lines<br>are appended, they immediately appear on the display. This continues until you<br>type "ctrl-c".<br><br>The "tee" command reads standard input and copies it to both standard output and<br>to one or more files. This is useful for capturing a pipeline's contents at an<br>intermediate stage of processing. <br><br><code>ls /usr/bin | tee ls.txt | grep zip</code><br><br>As always, check out the documentation of each of the commands we have covered.<br>We have seen only the most basic usage but have a number of interesting options.<br>You will see that the redirection feature of the command line is very useful for<br>solving specialized problems.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on September 17, 2024</p><ul class="post__tag"><li><a href="https://aindien.com/linux/">Linux</a></li></ul><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Faindien.com%2Flinux-essentials-.html" class="js-share facebook" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/share?url=https%3A%2F%2Faindien.com%2Flinux-essentials-.html&amp;via=_Aindien&amp;text=Linux%20Explained" class="js-share twitter" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span></a></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://aindien.com/authors/jason-moore/" class="invert" rel="author">Jason Moore</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://aindien.com/how-to-use-strings-in-c.html" class="invert post__nav-link" rel="prev"><span>Previous</span> How To Use Strings In C++</a></div><div class="post__nav-next"><a href="https://aindien.com/using-variables-in-c.html" class="invert post__nav-link" rel="next"><span>Next</span> Using Variables in C++ </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2021-08-07T08:43" class="feed__date">August 7, 2021</time></div><h3 class="h1"><a href="https://aindien.com/managing-input-and-output-streams-in-the-linux-shell.html" class="invert"> Managing Input and Output Streams in the Linux Shell</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2021-07-15T23:08" class="feed__date">July 15, 2021</time></div><h3 class="h1"><a href="https://aindien.com/managing-files-in-a-linux-environment.html" class="invert">Managing Files In A Linux Environment</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2021-04-27T22:35" class="feed__date">April 27, 2021</time></div><h3 class="h1"><a href="https://aindien.com/the-linux-shell-for-beginners.html" class="invert">The Linux Shell For Beginners</a></h3></article></div></div><div class="banner banner--after-post"><div class="wrapper"><link href="//cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel="stylesheet" type="text/css"><style type="text/css">#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
	/* Add your own Mailchimp form style overrides in your site stylesheet or in this style block.
	   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */</style><div id="mc_embed_signup"><form action="https://aindien.us11.list-manage.com/subscribe/post?u=5aefa50c3a5900492b165a83f&amp;id=1c348b805a" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate><div id="mc_embed_signup_scroll"><h2>Subscribe</h2><div class="indicates-required"><span class="asterisk">*</span> indicates required</div><div class="mc-field-group"><label for="mce-EMAIL">Email Address <span class="asterisk">*</span></label> <input type="email" name="EMAIL" class="required email" id="mce-EMAIL"></div><div class="mc-field-group"><label for="mce-FNAME">First Name</label> <input type="text" name="FNAME" id="mce-FNAME"></div><div class="mc-field-group"><label for="mce-LNAME">Last Name</label> <input type="text" name="LNAME" id="mce-LNAME"></div><div id="mce-responses" class="clear"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_5aefa50c3a5900492b165a83f_1c348b805a" tabindex="-1"></div><div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div></div></form></div><script type="text/javascript" src="//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js"></script><script type="text/javascript">(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';}(jQuery));var $mcj = jQuery.noConflict(true);</script></div></div></main><footer class="footer"><div class="footer__copyright"><p>Jason Moore 2022</p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://aindien.com/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://aindien.com/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>